package MissionSoftware
public
	with SMACCM_SYS;
	with SMACCM_DATA;
	with Base_Types;

	system top
	end top;

	system implementation top.i
		subcomponents
			proc: process MissionSoftware.i;
		properties
			SMACCM_SYS::OS => CAmkES;
			SMACCM_SYS::HW => ODROID;
	end top.i;

	process MissionSoftware
	end MissionSoftware;

	process implementation MissionSoftware.i
		subcomponents
			uart_driver: thread UART_driver;
			decrypt: thread Decrypt;
			encrypt: thread Encrypt;
			server: thread Server;
			can_framing: thread CAN_framing;
			can_driver: thread CAN_driver;
			virtual_machine: thread Virtual_Machine;

		connections
			recv_rx: port uart_driver.send_packet -> decrypt.get_packet;
			recv_resp: port uart_driver.recv_resp -> encrypt.recv_response;
			send_translate: port encrypt.send_packet -> uart_driver.get_packet;
			decrypt_conn: port decrypt.send_gidl -> server.get_input;
			send_can: port server.send_can -> can_framing.from_server;
			get_can: port can_framing.to_server -> server.get_can;
			encrypt_conn: port server.send_output -> encrypt.get_gidl;

			-- can framing to can driver
			frag_req: port can_framing.fragment_request -> can_driver.send;
			frag_com: port can_framing.fragment_complete -> can_driver.send;
			status: port can_driver.status -> can_framing.get_status;
			reasm: port can_driver.receive -> can_framing.fragment_reassembly;

			cam: port virtual_machine.camera_data -> server.camera_data;
	end MissionSoftware.i;

	thread UART_driver
		features
			recv_resp: out event data port Base_Types::Boolean;
			get_packet: in event data port SMACCM_DATA::UartPacket.i;
			send_packet: out event data port SMACCM_DATA::UartPacket.i;
		properties
			SMACCM_SYS::Is_External => true;
			Dispatch_Protocol => Sporadic;
			SMACCM_SYS::Thread_Type => Active;
			Compute_Execution_Time => 10 us .. 100 us;
			SMACCM_SYS::Sends_Events_To => "{{}}";
	end UART_driver;

	thread Decrypt
		features
		--not sure what the dimension of this array should be
			get_packet: in event data port SMACCM_DATA::UartPacket.i;
			send_gidl: out event data port SMACCM_DATA::Array.U8_80;
		properties
			Dispatch_Protocol => Periodic;
			SMACCM_SYS::Thread_Type => Active;
			Priority => 150;
			Stack_Size => 1024 Bytes;
			Compute_Execution_Time => 10 us .. 100 us;
			Period => 5 ms;
			SMACCM_SYS::Sends_Events_To => "{{}}";
			SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
			Initialize_Entrypoint_Source_Text => "component_init";

			--SMACCM_SYS::Sends_Events_To => "{{send_gidl 1}}";

	end Decrypt;

	thread Encrypt
		features
		--not sure what the dimension of this array should be
			get_gidl: in event data port SMACCM_DATA::Array.U8_80;
			recv_response: in event data port Base_Types::Boolean;
			send_packet: out event data port SMACCM_DATA::UartPacket.i;
		properties
			Dispatch_Protocol => Periodic;
			SMACCM_SYS::Thread_Type => Active;
			Priority => 150;
			Stack_Size => 1024 Bytes;
			Compute_Execution_Time => 10 us .. 100 us;
			Period => 5 ms;
			SMACCM_SYS::Sends_Events_To => "{{}}";
			SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
			Initialize_Entrypoint_Source_Text => "component_init";
			--SMACCM_SYS::Sends_Events_To => "{{send_packet 1}, {}}";

	end Encrypt;

	thread Server
		features
			send_output: out event data port SMACCM_DATA::Array.U8_80;
			send_can: out event data port SMACCM_DATA::Array.U8_80;
			get_input: in event data port SMACCM_DATA::Array.U8_80;
			get_can: in event data port SMACCM_DATA::Array.U8_80;
			camera_data: in data port SMACCM_DATA::camera_data.i;
		properties
			Dispatch_Protocol => Periodic;
			SMACCM_SYS::Thread_Type => Active;
			Priority => 150;
			Stack_Size => 1024 Bytes;
			Compute_Execution_Time => 10 us .. 100 us;
			SMACCM_SYS::Sends_Events_To => "{{}}";
			SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
			Initialize_Entrypoint_Source_Text => "component_init";
			Period => 5 ms;
	end Server;

	thread CAN_framing
		features
			to_server: out data port SMACCM_DATA::Array.U8_80;
			fragment_request: out event data port SMACCM_DATA::can_message.i;
			fragment_complete: out event data port SMACCM_DATA::can_message.i;
			from_server: in event data port SMACCM_DATA::Array.U8_80;
			get_status: in event data port Base_Types::Boolean;
			fragment_reassembly: in event data port SMACCM_DATA::can_message.i;
		properties
			Dispatch_Protocol => Periodic;
			SMACCM_SYS::Thread_Type => Active;
			Priority => 150;
			Stack_Size => 1024 Bytes;
			Compute_Execution_Time => 10 us .. 100 us;
			SMACCM_SYS::Sends_Events_To => "{{}}";
			SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
			Initialize_Entrypoint_Source_Text => "component_init";
			Period => 5 ms;
	end CAN_framing;

	thread CAN_driver
		features
			receive: out event data port SMACCM_DATA::can_message.i;
			status: out event data port Base_Types::Boolean;
			send: in event data port SMACCM_DATA::can_message.i;
		properties
			SMACCM_SYS::Is_External => true;
			Dispatch_Protocol => Sporadic;
			SMACCM_SYS::Thread_Type => Active;
			Compute_Execution_Time => 10 us .. 100 us;
			SMACCM_SYS::Sends_Events_To => "{{}}";
	end CAN_driver;

	thread Virtual_Machine
		features
			camera_data: out data port SMACCM_DATA::camera_data.i;
		properties
			SMACCM_SYS::Is_External => true;
			Dispatch_Protocol => Sporadic;
			SMACCM_SYS::Thread_Type => Active;
			Compute_Execution_Time => 10 us .. 100 us;
	end Virtual_machine;
end MissionSoftware;
