package MissionSoftware
public
	with SMACCM_SYS;
	with SMACCM_DATA;
  with Base_Types;

system top
end top;

system implementation top.i
	subcomponents
		proc : process MissionSoftware.i;
	properties
		SMACCM_SYS::OS => CAmkES;
		SMACCM_SYS::HW => QEMU;
end top.i;
	
process MissionSoftware
end MissionSoftware;	

process implementation MissionSoftware.i
	subcomponents
		uart_hw : thread UART_HW;
		uart_in : thread UART_in;
        uart_out : thread UART_out;
		server : thread Server;
		can : thread CAN;
		can_hw : thread CAN_hw;
		vm : thread VM;
		
	connections
		recv_rx : port uart_hw.send_packet -> uart_in.get_packet;
		recv_resp : port uart_hw.recv_resp -> uart_out.recv_response;
		send_translate : port uart_out.send_packet -> uart_hw.get_packet;
		decrypt : port uart_in.send_gidl -> server.get_input;
		send_can : port server.send_can -> can.from_server;
		get_can : port can.to_server -> server.get_can;
		encrypt : port server.send_output -> uart_out.get_gidl;
		
		-- can to can_hw connections
		send_abort : port can.send_abort -> can_hw.get_abort;
		frag_req : port can.fragment_request -> can_hw.fragment_request;
		frag_com : port can.fragment_complete -> can_hw.fragment_complete;
		status : port can_hw.send_status -> can.get_status;
		reasm : port can_hw.fragement_reassembly -> can.fragement_reasembly;
		
    cam : port VM.camera_data -> server.camera_data;
	
end MissionSoftware.i;

thread UART_HW
	features
		recv_resp : out event data port Base_Types::Boolean;
		get_packet : in event data port SMACCM_DATA::ivory_string_HXCyphertext.i;
    send_packet : out event data port SMACCM_DATA::ivory_string_UartPacket.i;
	properties
	    SMACCM_SYS::Is_External => true;
	    Dispatch_Protocol => Sporadic;
	    SMACCM_SYS::Thread_Type => Active;
	    Compute_Execution_Time => 10 us .. 100 us;
      SMACCM_SYS::Sends_Events_To => "{{}}";
	    Source_Text => ();
	    Period => 100ms;
end UART_HW;
	
thread UART_in
	features
		--not sure what the dimension of this array should be
		get_packet : in event data port SMACCM_DATA::ivory_string_UartPacket.i;
		send_gidl: out event data port SMACCM_DATA::Array.U8_80;
	properties
		Dispatch_Protocol => Periodic;
		SMACCM_SYS::Thread_Type => Active;
		Priority => 1;
		Stack_Size => 1024 Bytes;
	  Compute_Execution_Time => 10 us .. 100 us;
	  Period => 100ms;
	  Source_Text => ("usercode/UART_in.c");
    SMACCM_SYS::Sends_Events_To => "{{}}";
    SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
    Initialize_Entrypoint_Source_Text => "component_init";
	  
    --SMACCM_SYS::Sends_Events_To => "{{send_gidl 1}}";
end UART_in;

thread UART_out
  features
    --not sure what the dimension of this array should be
    get_gidl: in event data port SMACCM_DATA::Array.U8_80;
    recv_response: in event data port Base_Types::Boolean;
    send_packet : out event data port SMACCM_DATA::ivory_string_HXCyphertext.i;
  properties
    Dispatch_Protocol => Periodic;
    SMACCM_SYS::Thread_Type => Active;
    Priority => 1;
    Stack_Size => 1024 Bytes;
    Compute_Execution_Time => 10 us .. 100 us;
    Period => 100ms;
    Source_Text => ("usercode/UART_out.c");
    SMACCM_SYS::Sends_Events_To => "{{}}";
    SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
    Initialize_Entrypoint_Source_Text => "component_init";
    --SMACCM_SYS::Sends_Events_To => "{{send_packet 1}, {}}";
end UART_out;

thread Server
	features  
    send_output : out event data port SMACCM_DATA::Array.U8_80;
    send_can : out event data port SMACCM_DATA::Array.U8_80;
    get_input : in event data port SMACCM_DATA::Array.U8_80;
    get_can : in event data port SMACCM_DATA::Array.U8_80;  
    camera_data : in data port SMACCM_DATA::camera_data.i;
	properties
		Dispatch_Protocol => Periodic;
		SMACCM_SYS::Thread_Type => Active;
		Priority => 1;
		Stack_Size => 1024 Bytes;
	  Compute_Execution_Time => 10 us .. 100 us;
	  Source_Text => ("usercode/Server.c");
	  SMACCM_SYS::Sends_Events_To => "{{}}";
    SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
    Initialize_Entrypoint_Source_Text => "component_init";
	  Period => 100ms;
end Server;

thread CAN
	features
    to_server : out data port SMACCM_DATA::Array.U8_80;
    send_abort : out event data port Base_Types::Boolean;
    fragment_request : out event data port SMACCM_DATA::can_message.i;
    fragment_complete : out event data port SMACCM_DATA::can_message.i;
    from_server : in event data port SMACCM_DATA::Array.U8_80;
    get_status : in event data port Base_Types::Boolean;
    fragement_reasembly : in event data port SMACCM_DATA::can_message.i;
	properties
    Dispatch_Protocol => Periodic;
    SMACCM_SYS::Thread_Type => Active;
    Priority => 1;
    Stack_Size => 1024 Bytes;
    Compute_Execution_Time => 10 us .. 100 us;
    Source_Text => ("usercode/CAN.c");
    SMACCM_SYS::Sends_Events_To => "{{}}";
    SMACCM_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
    Initialize_Entrypoint_Source_Text => "component_init";
    Period => 100ms;
end CAN;

thread CAN_hw
  features
    fragement_reassembly : out event data port SMACCM_DATA::can_message.i;
    send_status : out event data port Base_Types::Boolean;
    get_abort : in event data port Base_Types::Boolean;
    fragment_request : in event data port SMACCM_DATA::can_message.i;
    fragment_complete : in event data port SMACCM_DATA::can_message.i;
  properties
      SMACCM_SYS::Is_External => true;
      Dispatch_Protocol => Sporadic;
      SMACCM_SYS::Thread_Type => Active;
      Compute_Execution_Time => 10 us .. 100 us;
      SMACCM_SYS::Sends_Events_To => "{{}}";
      Source_Text => ();
end CAN_hw;

thread VM
	features
		camera_data : out data port SMACCM_DATA::camera_data.i;
	properties
		SMACCM_SYS::Is_External => true;
	  Dispatch_Protocol => Sporadic;
	  SMACCM_SYS::Thread_Type => Active;
	  Compute_Execution_Time => 10 us .. 100 us;
	  Source_Text => ();
end VM;
	
end MissionSoftware;