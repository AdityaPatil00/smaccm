package HacmsTiming
public
  with Base_Types;

system A1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A1;

system A2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A2;

system M1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end M1;

system M2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 2.0;
  **};
    
end M2;

system M3
  features
    input1 : in event data port Base_Types::Integer;
    input2 : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 3.0;
  **};
    
end M3;

system top_level
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
    
  annex agree {**
  	eq t : real;
  	
  **};
end top_level;

system implementation top_level.i
  subcomponents
    a1 : system A1;
    a2 : system A2;
--    m1 : system M1;
--    m2 : system M2;
--    m3 : system M3;
    
  connections
    in_a1 : port input -> a1.input;
    in_a2 : port input -> a2.input;
--    a1_m1 : port a1.output -> m1.input;
--    a2_m2 : port a2.output -> m2.input;
--    m1_m3 : port m1.output -> m3.input1;
--    m2_m3 : port m2.output -> m3.input2;
--    m3_out : port m3.output -> output;
    
  annex agree {**
  	
  	 synchrony : asynchronous;
  	 
  	 const a1_period : real = 20.0;
  	 const a2_period : real = 10.0;
  	
  	 eq clock_a1 : bool = a1._CLK;
  	 eq clock_a2 : bool = a2._CLK;

  	 
  	 --these variables indicate the last time that a signal's period has passed
  	 eq a1_sig_last : real =  0.0 -> if t < pre(a1_sig_last) + a1_period then
  	                           pre(a1_sig_last)
  	                         else
  	                           pre(a1_sig_last) + a1_period;
  	 
  	 eq a2_sig_last : real =  0.0 -> if t < pre(a2_sig_last) + a2_period then
  	                           pre(a2_sig_last)
  	                         else
  	                           pre(a2_sig_last) + a2_period;
  	 
  	 --these variables indicate the last time that a component ticked                          
  	 eq a1_sig_cleared : real = if clock_a1 then t else prev(a1_sig_cleared, -1.0);
  	 eq a2_sig_cleared : real = if clock_a2 then t else prev(a2_sig_cleared, -1.0);           
                 
     --these variables are true if a component has yet to execute during its period           
  	 eq sig_a1 : bool = a1_sig_last >= prev(a1_sig_cleared, -1.0);
  	 eq sig_a2 : bool = a2_sig_last >= prev(a2_sig_cleared, -1.0);
  	 

     --time is positive and always increasing
	 assert t >= 0.0 and (true -> t > pre(t)); 

  	 --figure out how much time has progressed. Note that more time
  	 --may pass between clock ticks than just the execution time of a component
  	 assert clock_a1 => t >= prev(t,0.0) + a1.exec_time;
  	 assert clock_a2 => t >= prev(t,0.0) + a2.exec_time;
  	  
  	 --no two clocks tick at the same time
  	 assert not(clock_a1 and clock_a2);
--  	        and not(clock_a1 and clock_m1) and
--  	        not(clock_a1 and clock_m2) and not(clock_a1 and clock_m3) and
--  	        not(clock_a2 and clock_m1) and not(clock_a2 and clock_m2) and
--  	        not(clock_a2 and clock_m3) and not(clock_m1 and clock_m2) and
--  	        not(clock_m1 and clock_m3) and not(clock_m2 and clock_m3);
	
	 --at least one clock ticks
	 assert clock_a1 or clock_a2;
	  	  
	
	 --schedule constraints. This makes a1 have a higher priority than a2
	 assert if sig_a1 then clock_a1 else
	        if sig_a2 then clock_a2 else true;
--	        if sig_m1 then clock_m1 else
--	        if sig_m2 then clock_m2 else
--	        if sig_m3 then clock_m3 else true;
	        
	 --clocks only tick if they have been signaled
	 assert (clock_a1 => sig_a1) and (clock_a2 => sig_a2);
--	         and 
--	        (clock_m1 => sig_m1) and (clock_m2 => sig_m2) and 
--	        (clock_m3 => sig_m3);
  
     --assert that clocks meet their deadlines
     assert true -> pre(a1_sig_last) != a1_sig_last => 
       (pre(a1_sig_last) <= a1_sig_cleared and a1_sig_cleared <= a1_sig_last);
       
     assert true -> pre(a2_sig_last) != a2_sig_last => 
       (pre(a2_sig_last) <= a2_sig_cleared and a2_sig_cleared <= a2_sig_last);
       
     lemma "check for consistency" : true;
  	  
  **};
    
    
end top_level.i;


end HacmsTiming;
