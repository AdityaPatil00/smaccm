package HacmsTiming
public
  with Base_Types;

system A1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A1;

system A2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A2;

system M1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end M1;

system M2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end M2;

system M3
  features
    input1 : in event data port Base_Types::Integer;
    input2 : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end M3;

system top_level
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
    
  annex agree {**
  	eq t : real;
  	
  	guarantee "time is always positive" : t >= 0.0;
  	guarantee "time is always increasing" : true -> t > pre(t);
  	
  **};
end top_level;

system implementation top_level.i
  subcomponents
    a1 : system A1;
    a2 : system A2;
    m1 : system M1;
    m2 : system M2;
    m3 : system M3;
    
  connections
    in_a1 : port input -> a1.input;
    in_a2 : port input -> a2.input;
    a1_m1 : port a1.output -> m1.input;
    a2_m2 : port a2.output -> m2.input;
    m1_m3 : port m1.output -> m3.input1;
    m2_m3 : port m2.output -> m3.input2;
    m3_out : port m3.output -> output;
    
  annex agree {**
  	
  	 synchrony : asynchronous;
  	 
  	 const a1_period : real = 10.0;
  	 const a2_period : real = 5.0;
  	
  	 eq clock_a1 : bool = a1._CLK;
  	 eq clock_a2 : bool = a2._CLK;
  	 eq clock_m1 : bool = m1._CLK;
  	 eq clock_m2 : bool = m2._CLK;
  	 eq clock_m3 : bool = m3._CLK;
  	 
  	 eq sig_a1 : bool;
  	 eq sig_a2 : bool;
  	 eq sig_m1 : bool;
  	 eq sig_m2 : bool;
  	 eq sig_m3 : bool;
  	 
  	 eq a1_last: real =  0.0 -> if(not pre(sig_a1) and sig_a1) then t else pre(a1_last);
  	 eq a2_last: real =  0.0 -> if(not pre(sig_a2) and sig_a2) then t else pre(a2_last);
--  	 eq m1_last: real =  0 -> if(not pre(sig_m1) and sig_m1) then t else pre(m1_last);
--  	 eq m2_last: real =  0 -> if(not pre(sig_m2) and sig_m2) then t else pre(m2_last);
--  	 eq m3_last: real =  0 -> if(not pre(sig_m3) and sig_m3) then t else pre(m3_last); 
  	 
  	 --figure out how much time has progressed
  	 assert t = if (clock_a1) then prev(t,0.0) + a1.exec_time else 
  	            if (clock_a2) then prev(t,0.0) + a2.exec_time else 
  	            if (clock_m1) then prev(t,0.0) + m1.exec_time else 
  	            if (clock_m2) then prev(t,0.0) + m2.exec_time else 
  	            if (clock_m3) then prev(t,0.0) + m3.exec_time else -1.0;
  	  
  	 --no two clocks tick at the same time
  	 assert not(clock_a1 and clock_a2) and not(clock_a1 and clock_m1) and
  	        not(clock_a1 and clock_m2) and not(clock_a1 and clock_m3) and
  	        not(clock_a2 and clock_m1) and not(clock_a2 and clock_m2) and
  	        not(clock_a2 and clock_m3) and not(clock_m1 and clock_m2) and
  	        not(clock_m1 and clock_m3) and not(clock_m2 and clock_m3);
  	  
	 --if a period has passed, send a signal to be scheduled
	 assert if a1_last + a1_period < t then sig_a1 else true -> sig_a1 = pre(sig_a1);
	 assert if a2_last + a2_period < t then sig_a2 else true -> sig_a2 = pre(sig_a2);
	 
	 --events cause signals
	 assert event(m1.input) and clock_a1 => sig_m1;
	 assert event(m2.input) and clock_a2 => sig_m2;
	 assert event(m3.input1) and clock_m1 => sig_m3;
	 assert event(m3.input2) and clock_m2 => sig_m3;
	
	 --schedule constraints
	 assert if sig_a1 then clock_a1 else
	        if sig_a2 then clock_a2 else
	        if sig_m1 then clock_m1 else
	        if sig_m2 then clock_m2 else
	        if sig_m3 then clock_m3 else true;
	        
	 --clocks only tick if they have been signaled
	 assert clock_a1 => sig_a1 and clock_a2 => sig_a2 and 
	        clock_m1 => sig_m1 and clock_m2 => sig_m2 and 
	        clock_m3 => sig_m3;
	 
	
	 --need to find away to get rid fo signals. there
	 --shoudl be a cleaner way than this
	 assert true -> (pre(clock_a1) => not sig_a1) and
	                (pre(clock_a2) => not sig_a2) and
	                (pre(clock_m1) => not sig_m1) and
	                (pre(clock_m2) => not sig_m2) and
	                (pre(clock_m3) => not sig_m3);
	
	 lemma "a1 never misses its deadline" : 2.0*a1_period > t - a1_last;
	 lemma "a2 never misses its deadline" : 2.0*a2_period > t - a2_last;
	 
	 
  	  
  **};
    
    
end top_level.i;


end HacmsTiming;