package HacmsTiming
public
  with Base_Types;

system A1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A1;

system A2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 2.0;
  **};
    
end A2;

system M1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end M1;

system M2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 2.0;
  **};
    
end M2;

system M3
  features
    input1 : in event data port Base_Types::Integer;
    input2 : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 3.0;
  **};
    
end M3;

system top_level
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
    
  annex agree {**
  	eq t : real;
  	
  **};
end top_level;

system implementation top_level.i
  subcomponents
    a1 : system A1;
    a2 : system A2;
--    m1 : system M1;
--    m2 : system M2;
--    m3 : system M3;
    
  connections
    in_a1 : port input -> a1.input;
    in_a2 : port input -> a2.input;
--    a1_m1 : port a1.output -> m1.input;
--    a2_m2 : port a2.output -> m2.input;
--    m1_m3 : port m1.output -> m3.input1;
--    m2_m3 : port m2.output -> m3.input2;
--    m3_out : port m3.output -> output;
    
  annex agree {**
  	
  	 synchrony : asynchronous;
  	 
  	 const a1_period : real = 20.0;
  	 eq a2_period : real;-- = 10.0;
  	 
  	 assert 8.0 <= a2_period and a2_period <= 12.0;
  	
  	 eq clock_a1 : bool = a1._CLK;
  	 eq clock_a2 : bool = a2._CLK;
  	 
  	 
  	 node getLastSignal(time : real, period : real) returns (ret : real);
  	 let
  	   ret = 0.0 -> if time < pre(ret) + period then
  	                  pre(ret)
  	                else
  	                  pre(ret + period);
  	 tel;
  	 
  	 node getSignalCleared(time : real, clock : bool, exec_time : real) returns (ret : real);
  	 let
  	   ret = if clock then time - exec_time else prev(ret, -1.0);
  	 tel;
  	 
  	 --these variables indicate the last time that a signal's period has passed
  	 eq a1_sig_last : real = getLastSignal(t, a1_period);
  	 eq a2_sig_last : real = getLastSignal(t, a2_period);
  	 
  	 --these variables indicate the last time that a component ticked                          
  	 eq a1_sig_cleared : real = getSignalCleared(t, clock_a1, a1.exec_time);
  	 eq a2_sig_cleared : real = getSignalCleared(t, clock_a2, a2.exec_time); 
                 
     --these variables are true if a component has yet to execute during its period           
  	 eq sig_a1 : bool = true -> a1_sig_last > pre(a1_sig_cleared);
  	 eq sig_a2 : bool = true -> a2_sig_last > pre(a2_sig_cleared);

     --time is positive and always increasing
	 assert t >= 0.0 and (true -> t > pre(t)); 
	 
	 --something executes right away
	 assert t = a1.exec_time or t = a2.exec_time -> true;
	 
	 --if something was ready to execute in the last step but did not, 
	 --then it should execute in this step if it has the highest priority
	 assert true -> if pre(sig_a1) and not pre(clock_a1) then --this is actually not possible
	                  t - pre(t) = a1.exec_time 
	                else if pre(sig_a2) and not pre(clock_a2) then
	 				  t - pre(t) = a2.exec_time
	 				else 
	 				  t = pre(a2_sig_last) + a2_period; --this should always be the minimum period
  	  
  	 --no two clocks tick at the same time
  	 assert not(clock_a1 and clock_a2);
--  	        and not(clock_a1 and clock_m1) and
--  	        not(clock_a1 and clock_m2) and not(clock_a1 and clock_m3) and
--  	        not(clock_a2 and clock_m1) and not(clock_a2 and clock_m2) and
--  	        not(clock_a2 and clock_m3) and not(clock_m1 and clock_m2) and
--  	        not(clock_m1 and clock_m3) and not(clock_m2 and clock_m3);
	
	 --at least one clock ticks
	 assert clock_a1 or clock_a2;
	  	  
	
	 --schedule constraints. This makes a1 have a higher priority than a2
	 assert if sig_a1 then clock_a1 else
	        if sig_a2 then clock_a2 else true;
--	        if sig_m1 then clock_m1 else
--	        if sig_m2 then clock_m2 else
--	        if sig_m3 then clock_m3 else true;
	        
	 --clocks only tick if they have been signaled
	 assert (clock_a1 => sig_a1) and (clock_a2 => sig_a2);
--	         and 
--	        (clock_m1 => sig_m1) and (clock_m2 => sig_m2) and 
--	        (clock_m3 => sig_m3);
  
     --assert that clocks meet their deadlines
     lemma "a1 never misses its deadline" : true -> pre(a1_sig_last) != a1_sig_last => 
       pre(clock_a1) or clock_a1 or (pre(a1_sig_last) <= a1_sig_cleared and a1_sig_cleared <= a1_sig_last);
       
     lemma "a2 never misses its deadline" : true -> pre(a2_sig_last) != a2_sig_last => 
       pre(clock_a2) or clock_a2 or (pre(a2_sig_last) <= a2_sig_cleared and a2_sig_cleared <= a2_sig_last);
         	  
  **};
    
    
end top_level.i;


end HacmsTiming;
