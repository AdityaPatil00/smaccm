package HacmsTiming
public
  with Base_Types;

system A1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A1;

system A2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end A2;

system M1
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 1.0;
  **};
    
end M1;

system M2
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 2.0;
  **};
    
end M2;

system M3
  features
    input1 : in event data port Base_Types::Integer;
    input2 : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
  
  annex agree {**
  	const exec_time : real = 3.0;
  **};
    
end M3;

system top_level
  features
    input : in event data port Base_Types::Integer;
    output : out event data port Base_Types::Integer;
    
  annex agree {**
  	eq t : real;
  	
  	guarantee "time is always positive" : t >= 0.0;
  	guarantee "time is always increasing" : true -> t > pre(t);
  	
  **};
end top_level;

system implementation top_level.i
  subcomponents
    a1 : system A1;
    a2 : system A2;
    m1 : system M1;
    m2 : system M2;
    m3 : system M3;
    
  connections
    in_a1 : port input -> a1.input;
    in_a2 : port input -> a2.input;
    a1_m1 : port a1.output -> m1.input;
    a2_m2 : port a2.output -> m2.input;
    m1_m3 : port m1.output -> m3.input1;
    m2_m3 : port m2.output -> m3.input2;
    m3_out : port m3.output -> output;
    
  annex agree {**
  	
  	 synchrony : asynchronous;
  	 
  	 node sig_monitor(event_sig : bool, sender_clock : bool, receiver_clock : bool) returns (ret : bool);
  	 let
  	   ret = false -> if pre(event_sig and sender_clock) then
  	                   true
  	                 else if pre(receiver_clock) then
  	                   false
  	                 else
  	                   pre(ret);
  	 tel;
  	 
  	 node clock_counter(clock : bool) returns (ret : int);
  	 let
  	   ret = prev(ret, 0) + (if clock then 1 else 0); 
  	 tel;
  	 
  	 
  	 const a1_period : real = 20.0;
  	 const a2_period : real = 10.0;
  	
  	 eq clock_a1 : bool = a1._CLK;
  	 eq clock_a2 : bool = a2._CLK;
  	 eq clock_m1 : bool = m1._CLK;
  	 eq clock_m2 : bool = m2._CLK;
  	 eq clock_m3 : bool = m3._CLK;
  	 
  	 eq sig_a1_count : int = floor(t/a1_period) + 1;
  	 eq sig_a2_count : int = floor(t/a2_period) + 1;
  	 
  	 eq clock_a1_count : int = clock_counter(clock_a1);
  	 eq clock_a2_count : int = clock_counter(clock_a2);
  	 
--  	 eq sig_a2 : bool = a2_last + a2_period <= t;
  	 
  	 eq sig_a1 : bool = sig_a1_count > prev(clock_a1_count,0);
  	 eq sig_a2 : bool = sig_a2_count > prev(clock_a2_count,0);
  	 eq sig_m1 : bool = sig_monitor(event(m1.input), clock_a1, clock_m1);
  	 eq sig_m2 : bool = sig_monitor(event(m2.input), clock_a2, clock_m2);
  	 eq sig_m3 : bool = sig_monitor(event(m3.input1), clock_m1, clock_m3) or 
  	                    sig_monitor(event(m3.input2), clock_m2, clock_m3);
 	 
  	 --figure out how much time has progressed
  	 assert t = if (clock_a1) then prev(t,0.0) + a1.exec_time else 
  	            if (clock_a2) then prev(t,0.0) + a2.exec_time else 
  	            if (clock_m1) then prev(t,0.0) + m1.exec_time else
  	            if (clock_m2) then prev(t,0.0) + m2.exec_time else 
  	            if (clock_m3) then prev(t,0.0) + m3.exec_time else -1.0;
  	  
  	 --no two clocks tick at the same time
  	 assert not(clock_a1 and clock_a2) and not(clock_a1 and clock_m1) and
  	        not(clock_a1 and clock_m2) and not(clock_a1 and clock_m3) and
  	        not(clock_a2 and clock_m1) and not(clock_a2 and clock_m2) and
  	        not(clock_a2 and clock_m3) and not(clock_m1 and clock_m2) and
  	        not(clock_m1 and clock_m3) and not(clock_m2 and clock_m3);
  	  
	
	 --schedule constraints
	 assert if sig_a1 then clock_a1 else
	        if sig_a2 then clock_a2 else
	        if sig_m1 then clock_m1 else
	        if sig_m2 then clock_m2 else
	        if sig_m3 then clock_m3 else true;
	        
	 --clocks only tick if they have been signaled
	 assert (clock_a1 => sig_a1) and (clock_a2 => sig_a2) and 
	        (clock_m1 => sig_m1) and (clock_m2 => sig_m2) and 
	        (clock_m3 => sig_m3);
	
	 lemma "a1 never misses its deadline" : sig_a1_count = clock_a1_count or sig_a1_count = clock_a1_count + 1;
	 lemma "a2 never misses its deadline" : sig_a2_count = clock_a2_count or sig_a2_count = clock_a2_count + 1;	 
  	  
  **};
    
    
end top_level.i;


end HacmsTiming;