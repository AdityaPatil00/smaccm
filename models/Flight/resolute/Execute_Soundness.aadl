package Execute_Soundness
  public 
    with SMACCM;    
    annex resolute {**

execute_soundness() <= 
  ** "The UAV motors only execute commands from the Ground Station" **
  only_gs_encrypt() and motors_only_receive_decrypt()

only_gs_encrypt() <= 
  ** "Only the Ground Station can send commands that pass Decrypt" **
  let algo1 : string =
    property_lookup(flight_gen::decryptTask_uart5, SMACCM::Encryption_Algorthim);
  let algo2 : string =
    property_lookup(flight_gen::decryptTask_uart1, SMACCM::Encryption_Algorthim);
  algo1 = algo2 and
  authenticated_encryption(algo1) and  
  private_key()

authenticated_encryption(e : string) <=
  ** "The encryption algorithm " e " is strong and authenticated. "
     "Messages cannot be forged or manipulated" **
  e = "AES-128-GCM" or e = "AES-128-CTR-HMAC-SHA1"

private_key() <=
  ** "The encryption key is private to the UAV and Ground Station" **
  key_randomly_generated() and
  gs_private_key() and
  transmit_private_key() and
  uav_private_key() and
  uav_private_key_unchanged()

key_randomly_generated() <=
  ** "The encryption key is randomly generated and cannot be guessed" **
  true

gs_private_key() <=
  ** "The Ground Station does not leak the encryption key" **
  true

transmit_private_key() <=
  ** "The encryption key is securely transmitted to the UAV and Ground Station" **
  true
 
uav_private_key() <=
  ** "The UAV does not leak the encryption key" ** 
  true
  
uav_private_key_unchanged() <=
  ** "The encryption key is unmodified while on the UAV" **
  true

MOTORS : {component} = instances(PX4IOAR::Motor)
MAIN_LOOP : component = instance(flight_gen::flight_gen_process)

motors_only_receive_decrypt() <=
	** "The UAV motors only execute commands that pass Decrypt" **
	motors_only_receive_from_mainloop(MAIN_LOOP) and
	all_commands_to_mainloop_pass_decrypt_before_motors(MAIN_LOOP)
	
-- TODO: What should we say about non-data port connections?
motors_only_receive_from_mainloop(mainloop : component) <=
	** "The UAV motors only receive commands from " mainloop **
	forall (m : MOTORS).
	  forall (c : m.connections).
	    is_data_port(c) => comes_from_mainloop(c, mainloop)

comes_from_mainloop(c : connection, mainloop : component) <=
	** c " comes from " mainloop **
	 subcomponent_of(conn_source(c), mainloop)

all_commands_to_mainloop_pass_decrypt_before_motors(mainloop : component) <=
  ** "All commands to " mainloop " pass Decrypt before reaching UAV motors" **
  all_inputs_decrypt_or_sensors(mainloop)
	
all_inputs_decrypt_or_sensors(mainloop : component) <=
    ** "All inputs to " mainloop " are sensor data or pass Decrypt before reaching UAV motors" **
	forall (f : mainloop.features).
	    is_incomming(f, mainloop) =>
	      is_sensor_data(f) or feature_confined_to_decrypt(f, mainloop)

is_incomming(f : feature, x : component) : bool =
  exists (c : connections(f)). subcomponent_of(conn_dest(c), x)

is_sensor_data(f : feature) <=
  ** f " only receives sensor data" **
  has_type(f) and
  (type(f) = DATATYPES::Magnetometer_Data or
   type(f) = DATATYPES::Barometric_Data or
   type(f) = DATATYPES::Motion_Data or
   type(f) = DATATYPES::Motion_Data.Impl or
   type(f) = DATATYPES::Battery_Data or
   type(f) = DATATYPES::GPS_Data or
   type(f) = DATATYPES::Reset_Data)

  
feature_confined_to_decrypt(f : feature, mainloop : component) <=
  ** "Commands to " f " pass through Decrypt before reaching the UAV motors" **
  forall (c : connections(f)).
    subcomponent_of(conn_dest(c), mainloop) =>
      component_confined_to_decrypt(conn_dest(c), mainloop)
      
component_confined_to_decrypt(c : component, mainloop : component) <=
  ** "Commands to " c " pass through Decrypt before reaching the UAV motors" **
  let reach : {component} = predecrypt_reach(c, mainloop);
    component_confined_to_decrypt_by_set(c, reach)
    
predecrypt_reach(c : component, mainloop : component) : {component} =
  recursive_predecrypt_reach(singleton(c))
  
recursive_predecrypt_reach(curr : {component}) : {component} =
  let next : {component} = curr union next_predecrypt_reach(curr);
  if next = curr then
    curr
  else
    recursive_predecrypt_reach(next)
   
next_predecrypt_reach(curr : {component}) : {component} =
  {conn_dest(conn) for (x : curr) (conn : x.connections) |
	conn_source(conn) = x and not is_decrypt(x)}

is_decrypt(comp : component) : bool =
  class_of(comp, flight_gen::decryptTask_uart1) or
  class_of(comp, flight_gen::decryptTask_uart5)

component_confined_to_decrypt_by_set(x : component, reach : {component}) <=
  ** "Commands to " x " not passing through decrypt are confined and "
     "cannot reach UAV motors. Confinement set: " reach **
  forall (y : reach). cannot_reach_UAV_motors(y)

cannot_reach_UAV_motors(x : component) <=
  ** x " cannot communicate directly to UAV motors" **
  forall (conn : x.connections).
    conn_source(conn) = x => not (conn_dest(conn) in MOTORS)

unalterable_channel(c : connection) <=
  ** "The connection " c " delivers data without alteration" **
  (is_process(conn_source(c)) => memory_protected(conn_source(c)))
  and
  (is_process(conn_dest(c)) => memory_protected(conn_dest(c)))
  
 
-- The connection c delivers data without alteration.
-- "contained" means write permissions
--unalterable_channel(c : connection) <=
--  ** "The connection " c " delivers data without alteration" **
--  (exists (p1 : allProcesses) (p2 : allProcesses). 
--        conn_source(c) = p1 
--    and conn_dest(c) = p2
--    and p1 <> p2
--    and memory_protected(p1) 
--    and memory_protected(p2))
--  or
--  (exists (p : allProcesses).
--  	contained(conn_source(c), p) and
--  	contained(conn_dest(c), p) and
--  	memory_protected(p))
 
memory_protected_system() <=
  ** "Every processes is memory protected" **
  forall(p : process) . memory_protected(p)

memory_protected(p : component) <=
  ** "The memory of process " p " is protected from alterations by other processes" **
  property_lookup(p, SMACCM::OS) = "SeL4" or
  (property_lookup(p, SMACCM::OS) = "Breakaway-RTOS" and
   forall (mem : allMemory). bound(p, mem) =>
     forall (q : allProcesses). bound(q, mem) => memory_safe_process(q))

memory_safe_process(p : process) <=
  ** "The process " p " only writes to its own memory space" **
  forall (t : allThreads). contained(t, p) => memory_safe_thread(t)

memory_safe_thread(t : thread) <=
  ** "The thread " t " only writes to its own memory space" **
  ivory_thread(t)
  
ivory_thread(t : thread) <=
  ** "The thread " t " is generated from Ivory" **
  property_exists(t, SMACCM::Language) and
  property_lookup(t, SMACCM::Language) = "Ivory"
  
--component lists

allProcesses : {process} = {x for (x : process) }
allMemory : {memory} = {x for (x : memory) }
allThreads : {thread} = {x for (x : thread) }

--debugging
  
print_empty() <= ** "" ** true

print_aadl(a : aadl) <=
  ** a **
  true
  
print_set(s : {aadl}) <=
  ** s **
  true
  
**};
    
end Execute_Soundness;
