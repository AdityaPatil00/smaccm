package Execute_Soundness
  public 
    with SMACCM;    
    annex resolute {**

--component lists

allProcesses : {process} = {x for (x : process) | true}
allMemory : {memory} = {x for (x : memory) | true}
allThreads : {thread} = {x for (x : thread) | true}


connected_comps_via_cc(x : component) : {component} =
	{conn_source(c) for (c : x.connections) | command_channel(c)}

only_receive_gs(x : component) <= 
  ** x " only receives messages from the Ground Station" **
  only_gs_encrypt() and memory_protected_system() and only_receive_decrypt(x, identity(x))

only_gs_encrypt() <= 
  ** "Only the Ground Station can send messages that pass Decrypt" ** 
  authenticated_encryption(encrypt_algorithm1) and 
  authenticated_encryption(encrypt_algorithm2) and  
  private_key()

-- The encryption algorithm used by the Ground Station and Decrypt is e.
encrypt_algorithm1 : string =
  property_lookup(flight_gen::decryptTask_uart5, SMACCM::Encryption_Algorthim) 
  
encrypt_algorithm2 : string =
  property_lookup(flight_gen::decryptTask_uart1, SMACCM::Encryption_Algorthim) 

authenticated_encryption(e : string) <=
  ** "The encryption algorithm " e " is strong and authenticated. "
     "Messages cannot be forged or manipulated" **
  e = "AES-128-GCM" or e = "AES-128-CTR-HMAC-SHA1"

private_key() <=
  ** "The encryption key is private to the UAV and Ground Station" **
  key_randomly_generated() and gs_private_key() and transmit_private_key() and uav_private_key()

key_randomly_generated() <=
  ** "The encryption key is randomly generated and cannot be guessed" **
  true

gs_private_key() <=
  ** "The Ground Station does not leak the encryption key" **
  true

transmit_private_key() <=
  ** "The encryption key is securely transmitted to the UAV and Ground Station" **
  true
 
uav_private_key() <=

  ** "The UAV does not leak the encryption key" ** 
  true
	
only_receive_decrypt(x : component, v : {component}) <=
	** "The component " x " only receives messages that pass Decrypt" **
	forall(z : connected_comps_via_cc(x)).
	(not (z in v)) =>
		  proc_or_thread(z)
		  and
          ((class_of(x, flight_gen::decryptTask_uart1) or class_of(x, flight_gen::decryptTask_uart5)) 
          	or only_receive_decrypt(z, v union identity(z)))

proc_or_thread(x : component) <=
	** "component " x "is a processes or a thread." **
	is_process(x) or is_thread(x)
	
       
-- The connection c potentially carries commands
-- Non command datatypes must be explicitly whitelisted here
command_channel(c : connection) : bool =
  (not has_type(c)) or

  (type(c) <> sensors_type::sensors_result.impl
   --type(c) <> Base_Types::Float or
   --type(c) <> gps_type::position.impl or
   --type(c) <> Base_Types::Unsigned_32 or
   --type(c) <> gcsstream_timing::gcsstream_timing or
   --type(c) <> data_rate::data_rate_state.impl or 
   --type(c) <> Base_Types::Integer_16 or
   --type(c) <> Base_Types::Integer_8 or
   --type(c) <> flight_gen::ArrTy_80TyBase_Types_Unsigned_8 
   --type(c) <> 
   or true
  )


unalterable_channel(c : connection) <=
  ** "The connection " c " delivers data without alteration" **
  (is_process(conn_source(c)) => memory_protected(conn_source(c)))
  and
  (is_process(conn_dest(c)) => memory_protected(conn_dest(c)))
  
 
-- The connection c delivers data without alteration.
-- "contained" means write permissions
--unalterable_channel(c : connection) <=
--  ** "The connection " c " delivers data without alteration" **
--  (exists (p1 : allProcesses) (p2 : allProcesses). 
--        conn_source(c) = p1 
--    and conn_dest(c) = p2
--    and p1 <> p2
--    and memory_protected(p1) 
--    and memory_protected(p2))
--  or
--  (exists (p : allProcesses).
--  	contained(conn_source(c), p) and
--  	contained(conn_dest(c), p) and
--  	memory_protected(p))
 
memory_protected_system() <=
  ** "Every processes is memory protected" **
  forall(p : process) . memory_protected(p)

memory_protected(p : component) <=
  ** "The memory of process " p " is protected from alterations by other processes" **
  property_lookup(p, SMACCM::OS) = "SeL4" or
  (property_lookup(p, SMACCM::OS) = "Breakaway-RTOS" and
   forall (mem : allMemory). bound(p, mem) =>
     forall (q : allProcesses). bound(q, mem) => memory_safe_process(q))

memory_safe_process(p : process) <=
  ** "The process " p " only writes to its own memory space" **
  forall (t : allThreads). contained(t, p) => memory_safe_thread(t)

memory_safe_thread(t : thread) <=
  ** "The thread " t " only writes to its own memory space" **
  ivory_thread(t)
  
ivory_thread(t : thread) <=
  ** "The thread " t " is generated from Ivory" **
  property_exists(t, SMACCM::Language) and
  property_lookup(t, SMACCM::Language) = "Ivory"
  
**};
    
end Execute_Soundness;
