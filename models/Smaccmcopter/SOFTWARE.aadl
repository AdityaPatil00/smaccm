package SOFTWARE
public
  with UAV;
  with DATATYPES;
  with IVORY;
  with IVORY_TYPES;
  with Static_Analysis;
  with SMACCM;
  with Mode_Properties;
  with Base_Types;

  system Software
    features
      motors_and_radios: feature group UAV::motors_and_radios;
      sensors: feature group UAV::sensors;
  end Software;
  
  system implementation Software.Impl 
    subcomponents
      ML: process Main_Loop.Impl;
             
    connections
      feature group motors_and_radios <-> ML.motors_and_radios;
      feature group sensors <-> ML.sensors;
  end Software.Impl;
  
  process Main_Loop
    features
      motors_and_radios: feature group UAV::motors_and_radios;
      sensors: feature group UAV::sensors;
      
      -- These are disconnected until we want to specify exactly 
      -- the transition conditions. We would leave them out, but AADL
      -- requires some condition on each mode transition.
      e1: in event port;
      e2: in event port;
      e3: in event port;
      e4: in event port;
      
      
       annex agree {**

			guarantee "test " : true;
			
				
	**};
      
  end Main_Loop;
    
  abstract environment
  	features
  		motor_input : in data port DATATYPES::Motor_Commands.Impl;
  		sensor_output : out data port DATATYPES::Sensor_Data.Impl;
  end environment;
  
  process implementation Main_Loop.Impl
    subcomponents
      SS: thread Sensors in modes (Boot, Normal, Defensive);
      CCT: thread Command_Control_Telemetry in modes (Normal);
      BC: thread Backup_Commands in modes (Defensive);
      RC: thread Radio_Control in modes (Normal);
      SN: thread Stability_Navigation in modes (Normal, Defensive);
      MC: thread Motor_Control in modes (Normal, Defensive);
      DC: thread Decrypt in modes (Normal);
      ENV: abstract environment;
      
    connections
      feature group sensors <-> SS.sensors_in 
      {Communication_Properties::Timing => immediate;}  
      in modes (Normal, Defensive, Boot) ;
      port motors_and_radios.flight_control_commands -> RC.commands_in in modes (Normal);
      port motors_and_radios.mavlink -> DC.encrypt_in in modes (Normal);
      port DC.decrypt_out -> CCT.mavlink_in in modes (Normal);
      
      port SS.sensors_out -> SN.sensors
      {Communication_Properties::Timing => immediate;}
      in modes (Normal, Defensive, Boot);
      
      port RC.commands_out -> SN.rc_commands in modes (Normal);
      port CCT.mavlink_out -> SN.mavlink  in modes (Normal);
      port BC.mavlink_out -> SN.mavlink  in modes (Defensive);
      
      port SN.motor_commands -> MC.motor_commands in modes (Normal, Defensive);
      port MC.servo1_commands -> motors_and_radios.motor1 in modes (Normal, Defensive);      
      port MC.servo2_commands -> motors_and_radios.motor2 in modes (Normal, Defensive);      
      port MC.servo3_commands -> motors_and_radios.motor3 in modes (Normal, Defensive);      
      port MC.servo4_commands -> motors_and_radios.motor4 in modes (Normal, Defensive);
      
      --connect motors and sensors to the environment for agree
      
    modes
      Boot: initial mode;
      Maintenance: mode;
      Normal: mode;
      Defensive: mode;
      
      Boot -[e1]-> Normal;
      Boot -[e2]-> Normal;
      Normal -[e3]-> Defensive;
      Defensive -[e4]-> Normal;
      
      --  +------+     +--------+     +-----------+
      --  | Boot |---->| Normal |<--->| Defensive |
      --  +------+     +--------+     +-----------+
      --      |
      --      v
      --  +-------------+
      --  | Maintenance |
      --  +-------------+
      
    properties 
      SMACCM::OS => "Breakaway-RTOS";
      
    annex resolute {** 
    	prove no_external_commands(this.SN, this) modes: Defensive 
    	-- This property should fail:
    	-- prove no_external_commands(this.SN, this) modes: Normal
    	
    	prove schedulable(this) modes: Normal
    	prove schedulable(this) modes: Defensive 
    	 
    	prove no_radio_commands(this.SN) modes: Defensive
    	
    	prove receives_mavlink(this.SN) modes: Defensive
    	prove receives_mavlink(this.SN) modes: Normal
    	      
    	prove only_receive_gs(this.MC) modes: Normal
    **};
    
    annex agree {**
    	assert true;
    **};

  end Main_Loop.Impl;
  
  thread Decrypt
  	features 
  	    private_key : in data port DATATYPES::Private_Key_Data;
  		encrypt_in  : in data port DATATYPES::EncryptMAVlink;
  		decrypt_out : out data port DATATYPES::MAVlink;
  		signal_input : in data port Base_Types::Integer;
        receive_signal : in data port Base_Types::Boolean;
        
  	properties
  	  Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
  	  Dispatch_Protocol => Aperiodic;
  	  SMACCM::Encryption_Algorthim => "AES-128-GCM";
  	  SMACCM::Always_Sends_Message => true;
  	  SMACCM::Language => "Ivory";
  end Decrypt;
  
  thread User_Interface 
    features
      flight_mode_out: out data port Ivory_Types::flightmode;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
      
      Source_Text => ("app/stabilize_hil/main.cpp");
      Initialize_Entrypoint_Source_Text => "main";
      Compute_Entrypoint_Source_Text => "main_task";
      
      Static_Analysis::Writes_to_buffers => ("motorsoutput_shared_state");
      Static_Analysis::Reads_from_buffers => ("userinput_shared_state",
        "sensors_shared_state", "gcs_shared_state");
        
      SMACCM::Language => "Ivory";
  end User_Interface;

  thread Stability_Navigation
    features
      rc_commands: in data port DATATYPES::Flight_Control_Commands.Impl;
      mavlink: in data port DATATYPES::MAVLink;
      sensors: in data port DATATYPES::Sensor_Data.Impl;
      motor_commands: out data port DATATYPES::Motor_Commands.Impl;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
      
      Source_Text => ("app/stabilize_hil/main.cpp");
      Initialize_Entrypoint_Source_Text => "main";
      Compute_Entrypoint_Source_Text => "main_task";
      
      Static_Analysis::Writes_to_buffers => ("motorsoutput_shared_state");
      Static_Analysis::Reads_from_buffers => ("userinput_shared_state",
        "sensors_shared_state", "gcs_shared_state");

      SMACCM::Language => "Ivory"; 
      
      
  end Stability_Navigation;
 
  thread Backup_Commands
    features
      mavlink_out: out data port DATATYPES::MAVLink;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
    properties
    
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
    
      Dispatch_Protocol => Aperiodic;
      
      Source_Text => ("src/gcs_receive.c");
      Initialize_Entrypoint_Source_Text => "gcs_receive_init";
      Compute_Entrypoint_Source_Text => "gcs_receive_task";
      
      Static_Analysis::Writes_to_buffers => ("gcs_shared_state");
      SMACCM::Always_Sends_Message => true;
      SMACCM::Language => "Ivory";
  end Backup_Commands;

  thread Command_Control_Telemetry
    features
      mavlink_in: in event data port DATATYPES::MAVLink;
      mavlink_out: out data port DATATYPES::MAVLink;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
      
    properties
    
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
    
      Dispatch_Protocol => Aperiodic;
      Dispatch_Trigger => (reference (mavlink_in));
      
      Source_Text => ("src/gcs_receive.c");
      Initialize_Entrypoint_Source_Text => "gcs_receive_init";
      Compute_Entrypoint_Source_Text => "gcs_receive_task";
      
      Static_Analysis::Writes_to_buffers => ("gcs_shared_state");
      SMACCM::Always_Sends_Message => true;
      SMACCM::Language => "Ivory";
  end Command_Control_Telemetry;
  
  thread Radio_Control
    features
      commands_in: in data port DATATYPES::Flight_Control_Commands.Impl;
      commands_out: out data port DATATYPES::Flight_Control_Commands.Impl;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
    
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      Dispatch_Protocol => Periodic;
      Compute_Execution_Time => 1 ms .. 3 ms;
      
      Source_Text => ("src/userinput.cpp");
      Initialize_Entrypoint_Source_Text => "userinput_init";
      Compute_Entrypoint_Source_Text => "userinput_task";
      
      Static_Analysis::Writes_to_buffers => ("userinput_shared_state");
      SMACCM::Language => "Ivory";
  end Radio_Control;

  thread Sensors
    features
      sensors_in: feature group UAV::sensors;
      sensors_out: out data port DATATYPES::Sensor_Data.Impl;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
	
      Source_Text => ("src/sensors.cpp");
      Initialize_Entrypoint_Source_Text => "sensors_init";
      Compute_Entrypoint_Source_Text => "sensors_task";
      
      Static_Analysis::Writes_to_buffers => ("sensors_shared_state");
      SMACCM::Language => "Ivory";
      
  end Sensors;

  thread Motor_Control
    features
      motor_commands: in data port DATATYPES::Motor_Commands;
      servo1_commands: out data port DATATYPES::Servo_Commands;
      servo2_commands: out data port DATATYPES::Servo_Commands;
      servo3_commands: out data port DATATYPES::Servo_Commands;
      servo4_commands: out data port DATATYPES::Servo_Commands;
      signal_input : in data port Base_Types::Integer;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 20ms;
      
      Dispatch_Protocol => Periodic;
      Compute_Execution_Time => 1 ms .. 3 ms;
      
      Source_Text => ("src/motorsoutput.cpp");
      Initialize_Entrypoint_Source_Text => "motorsoutput_init";
      Compute_Entrypoint_Source_Text => "motorsoutput_task";
      
      Static_Analysis::Reads_from_buffers => ("motorsoutput_shared_state");
      SMACCM::Language => "Ivory";
      
      annex agree {**
      	
      	eq poll0 : bool;
      	eq poll1 : bool;
      	eq poll2 : bool;
      	eq poll3 : bool;
      	eq poll4 : bool;
      	eq poll5 : bool;
      	eq poll6 : bool;
      	eq poll7 : bool;
      	
      	eq pend0 : bool = if(sent0) then true else if(poll0) then false else prev(pend0, false);
        eq pend1 : bool = if(sent1) then true else if(poll1) then false else prev(pend1, false);
        eq pend2 : bool = if(sent2) then true else if(poll2) then false else prev(pend2, false);
        eq pend3 : bool = if(sent3) then true else if(poll3) then false else prev(pend3, false);
        eq pend4 : bool = if(sent4) then true else if(poll4) then false else prev(pend4, false);
        eq pend5 : bool = if(sent5) then true else if(poll5) then false else prev(pend5, false);
        eq pend6 : bool = if(sent6) then true else if(poll6) then false else prev(pend6, false);
        eq pend7 : bool = if(sent7) then true else if(poll7) then false else prev(pend7, false);
      	
      	eq sig : int = signal_input;
      	eq sent0 : bool = Agree_Nodes.mod2(sig) != 0;
      	eq sent1 : bool = Agree_Nodes.mod4(sig) != 0;
      	eq sent2 : bool = Agree_Nodes.mod8(sig) != 0;
      	eq sent3 : bool = Agree_Nodes.mod16(sig) != 0;
      	eq sent4 : bool = Agree_Nodes.mod32(sig) != 0;
      	eq sent5 : bool = Agree_Nodes.mod64(sig) != 0;
      	eq sent6 : bool = Agree_Nodes.mod128(sig) != 0;
      	eq sent7 : bool = Agree_Nodes.mod256(sig) != 0;
      	
      	-- contstraints to guarantee single polling
      	guarantee "poll0" : poll0 => not(poll1 or poll2 or poll3 or poll4 or poll5 or poll6 or poll7);
      	guarantee "poll1" : poll1 => not(poll0 or poll2 or poll3 or poll4 or poll5 or poll6 or poll7);
      	guarantee "poll2" : poll2 => not(poll0 or poll1 or poll3 or poll4 or poll5 or poll6 or poll7);
      	guarantee "poll3" : poll3 => not(poll0 or poll1 or poll2 or poll4 or poll5 or poll6 or poll7);
      	guarantee "poll4" : poll4 => not(poll0 or poll1 or poll2 or poll3 or poll5 or poll6 or poll7);
      	guarantee "poll5" : poll5 => not(poll0 or poll1 or poll2 or poll3 or poll4 or poll6 or poll7);
      	guarantee "poll6" : poll6 => not(poll0 or poll1 or poll2 or poll3 or poll4 or poll5 or poll7);
      	guarantee "poll7" : poll7 => not(poll0 or poll1 or poll2 or poll3 or poll4 or poll5 or poll6);
      	
      	--constraints to guarantee historical pending
      	
      	eq k : int;
      	guarantee "k val" : k >= 0;
      	guarantee "pend0" : Agree_Nodes.true_since(pend0, k) => Agree_Nodes.false_since(sent0, k);
      	guarantee "pend1" : Agree_Nodes.true_since(pend1, k) => Agree_Nodes.false_since(sent1, k);
      	guarantee "pend2" : Agree_Nodes.true_since(pend2, k) => Agree_Nodes.false_since(sent2, k);
      	guarantee "pend3" : Agree_Nodes.true_since(pend3, k) => Agree_Nodes.false_since(sent3, k);
      	guarantee "pend4" : Agree_Nodes.true_since(pend4, k) => Agree_Nodes.false_since(sent4, k);
      	guarantee "pend5" : Agree_Nodes.true_since(pend5, k) => Agree_Nodes.false_since(sent5, k);
      	guarantee "pend6" : Agree_Nodes.true_since(pend6, k) => Agree_Nodes.false_since(sent6, k);
      	guarantee "pend7" : Agree_Nodes.true_since(pend7, k) => Agree_Nodes.false_since(sent7, k);
      	
      	
      	
      **};
      
  end Motor_Control;
end SOFTWARE;