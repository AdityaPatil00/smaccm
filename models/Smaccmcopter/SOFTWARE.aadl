package SOFTWARE
public
  with UAV;
  with DATATYPES;
  with IVORY;
  with IVORY_TYPES;
  with Static_Analysis;
  with SMACCM;
  with Base_Types;

  system Software
    features
      motors_and_radios: feature group UAV::motors_and_radios;
      sensors: feature group UAV::sensors;
  end Software;
  
  system implementation Software.Impl 
    subcomponents
      ML: process Main_Loop.Impl;
             
    connections
      conn0: feature group motors_and_radios <-> ML.motors_and_radios;
      conn1: feature group sensors <-> ML.sensors;
  end Software.Impl;
  
  process Main_Loop
    features
      motors_and_radios: feature group UAV::motors_and_radios;
      sensors: feature group UAV::sensors;
      
      -- These are disconnected until we want to specify exactly 
      -- the transition conditions. We would leave them out, but AADL
      -- requires some condition on each mode transition.
      e1: in event port;
      e2: in event port;
      e3: in event port;
      e4: in event port;
  end Main_Loop;
    
  abstract environment
  	features
  		motor_input : in data port DATATYPES::Motor_Commands.Impl;
  		sensor_output : out data port DATATYPES::Sensor_Data.Impl;
  end environment;
  
  process implementation Main_Loop.Impl
    subcomponents
      SS: thread Sensors;
      CCT: thread Command_Control_Telemetry;
      RC: thread Radio_Control;
      SN: thread Stability_Navigation;
      MC: thread Motor_Control;
      DC: thread Decrypt;
      ENV: abstract environment;
      
    connections
      conn: feature group sensors <-> SS.sensors_in;
      -- Not supported in current version of Osate: 
      -- {Communication_Properties::Timing => immediate;}
      conn0: port motors_and_radios.flight_control_commands -> RC.commands_in;
      conn1: port motors_and_radios.mavlink -> DC.encrypt_in;
      conn2: port DC.decrypt_out -> CCT.mavlink_in;
      
      conn3: port SS.sensors_out -> SN.sensors
      {Communication_Properties::Timing => immediate;};
      
      --conn4: port RC.commands_out -> SN.rc_commands;
      conn5: port CCT.mavlink_out -> SN.mavlink;
      
      conn7: port SN.motor_commands -> MC.motor_commands;
      conn8: port MC.servo1_commands -> motors_and_radios.motor1;      
      conn9: port MC.servo2_commands -> motors_and_radios.motor2;      
      conn10: port MC.servo3_commands -> motors_and_radios.motor3;   
      conn11: port MC.servo4_commands -> motors_and_radios.motor4;

    properties 
      SMACCM::OS => "Breakaway-RTOS";
      
    annex resolute {** 
    	prove only_receive_gs(this.MC)
    	prove schedulable(this)
    **};
  end Main_Loop.Impl;
  
  thread Decrypt
  	features 
  	    private_key : in data port DATATYPES::Private_Key_Data;
  		encrypt_in  : in data port DATATYPES::EncryptMAVlink;
  		decrypt_out : out data port DATATYPES::MAVlink;
  		signal_input : in data port Base_Types::Integer;
        receive_signal : in data port Base_Types::Boolean;
        
  	properties
  	  Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
  	  Dispatch_Protocol => Aperiodic;
  	  SMACCM::Encryption_Algorthim => "AES-128-GCM";
  	  SMACCM::Always_Sends_Message => true;
  	  SMACCM::Language => "Ivory";
  end Decrypt;
  
  thread User_Interface 
    features
      flight_mode_out: out data port Ivory_Types::flightmode;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
      
      Source_Text => ("app/stabilize_hil/main.cpp");
      Initialize_Entrypoint_Source_Text => "main";
      Compute_Entrypoint_Source_Text => "main_task";
      
      Static_Analysis::Writes_to_buffers => ("motorsoutput_shared_state");
      Static_Analysis::Reads_from_buffers => ("userinput_shared_state",
        "sensors_shared_state", "gcs_shared_state");
        
      SMACCM::Language => "Ivory";
  end User_Interface;

  thread Stability_Navigation
    features
      rc_commands: in data port DATATYPES::Flight_Control_Commands.Impl;
      mavlink: in data port DATATYPES::MAVLink;
      sensors: in data port DATATYPES::Sensor_Data.Impl;
      motor_commands: out data port DATATYPES::Motor_Commands.Impl;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
      
      Source_Text => ("app/stabilize_hil/main.cpp");
      Initialize_Entrypoint_Source_Text => "main";
      Compute_Entrypoint_Source_Text => "main_task";
      
      Static_Analysis::Writes_to_buffers => ("motorsoutput_shared_state");
      Static_Analysis::Reads_from_buffers => ("userinput_shared_state",
        "sensors_shared_state", "gcs_shared_state");

      SMACCM::Language => "Ivory"; 
      
      
  end Stability_Navigation;
 
  thread Backup_Commands
    features
      mavlink_out: out data port DATATYPES::MAVLink;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
    properties
    
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
    
      Dispatch_Protocol => Aperiodic;
      
      Source_Text => ("src/gcs_receive.c");
      Initialize_Entrypoint_Source_Text => "gcs_receive_init";
      Compute_Entrypoint_Source_Text => "gcs_receive_task";
      
      Static_Analysis::Writes_to_buffers => ("gcs_shared_state");
      SMACCM::Always_Sends_Message => true;
      SMACCM::Language => "Ivory";
  end Backup_Commands;

  thread Command_Control_Telemetry
    features
      mavlink_in: in event data port DATATYPES::MAVLink;
      mavlink_out: out data port DATATYPES::MAVLink;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
      
    properties
    
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
    
      Dispatch_Protocol => Aperiodic;
      Dispatch_Trigger => (reference (mavlink_in));
      
      Source_Text => ("src/gcs_receive.c");
      Initialize_Entrypoint_Source_Text => "gcs_receive_init";
      Compute_Entrypoint_Source_Text => "gcs_receive_task";
      
      Static_Analysis::Writes_to_buffers => ("gcs_shared_state");
      SMACCM::Always_Sends_Message => true;
      SMACCM::Language => "Ivory";
  end Command_Control_Telemetry;
  
  thread Radio_Control
    features
      commands_in: in data port DATATYPES::Flight_Control_Commands.Impl;
      commands_out: out data port DATATYPES::Flight_Control_Commands.Impl;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
    
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      Dispatch_Protocol => Periodic;
      Compute_Execution_Time => 1 ms .. 3 ms;
      
      Source_Text => ("src/userinput.cpp");
      Initialize_Entrypoint_Source_Text => "userinput_init";
      Compute_Entrypoint_Source_Text => "userinput_task";
      
      Static_Analysis::Writes_to_buffers => ("userinput_shared_state");
      SMACCM::Language => "Ivory";
  end Radio_Control;

  thread Sensors
    features
      sensors_in: feature group UAV::sensors;
      sensors_out: out data port DATATYPES::Sensor_Data.Impl;
      signal_input : in data port Base_Types::Integer;
      receive_signal : in data port Base_Types::Boolean;
      
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
	
      Source_Text => ("src/sensors.cpp");
      Initialize_Entrypoint_Source_Text => "sensors_init";
      Compute_Entrypoint_Source_Text => "sensors_task";
      
      Static_Analysis::Writes_to_buffers => ("sensors_shared_state");
      SMACCM::Language => "Ivory";
      
  end Sensors;

  thread Motor_Control
    features
      motor_commands: in data port DATATYPES::Motor_Commands;
      servo1_commands: out data port DATATYPES::Servo_Commands;
      servo2_commands: out data port DATATYPES::Servo_Commands;
      servo3_commands: out data port DATATYPES::Servo_Commands;
      servo4_commands: out data port DATATYPES::Servo_Commands;
      send_signal : in data port DATATYPES::Thread_Signal.Impl_8;
      
      
    properties
      Period => 200ms; 
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 20ms;
      
      Dispatch_Protocol => Periodic;
      Compute_Execution_Time => 1 ms .. 3 ms;
      
      Source_Text => ("src/motorsoutput.cpp");
      Initialize_Entrypoint_Source_Text => "motorsoutput_init";
      Compute_Entrypoint_Source_Text => "motorsoutput_task";
      
      Static_Analysis::Reads_from_buffers => ("motorsoutput_shared_state");
      SMACCM::Language => "Ivory";
      
      annex agree {**
      	-- true if signal n has been polled
      	eq poll0 : bool;
      	eq poll1 : bool;
      	eq poll2 : bool;
      	eq poll3 : bool;
      	eq poll4 : bool;
      	eq poll5 : bool;
      	eq poll6 : bool;
      	eq poll7 : bool;
      	
      	-- true if signal n is pending
      	eq pend0 : bool;
      	eq pend1 : bool;
      	eq pend2 : bool;
      	eq pend3 : bool;
      	eq pend4 : bool;
      	eq pend5 : bool;
      	eq pend6 : bool;
      	eq pend7 : bool;
      	
      	--true of signal n has been sent
      	eq sent0 : bool = send_signal.sig0;
      	eq sent1 : bool = send_signal.sig1;
      	eq sent2 : bool = send_signal.sig2;
      	eq sent3 : bool = send_signal.sig3;
      	eq sent4 : bool = send_signal.sig4;
      	eq sent5 : bool = send_signal.sig5;
      	eq sent6 : bool = send_signal.sig6;
      	eq sent7 : bool = send_signal.sig7;
      	
      	--helper var for guarantess
      	eq k : int;
      	
      	--eq pend0 : bool = if(sent0) then true else if(poll0) then false else prev(pend0, false);
        --eq pend1 : bool = if(sent1) then true else if(poll1) then false else prev(pend1, false);
        --eq pend2 : bool = if(sent2) then true else if(poll2) then false else prev(pend2, false);
        --eq pend3 : bool = if(sent3) then true else if(poll3) then false else prev(pend3, false);
        --eq pend4 : bool = if(sent4) then true else if(poll4) then false else prev(pend4, false);
        --eq pend5 : bool = if(sent5) then true else if(poll5) then false else prev(pend5, false);
        --eq pend6 : bool = if(sent6) then true else if(poll6) then false else prev(pend6, false);
        --eq pend7 : bool = if(sent7) then true else if(poll7) then false else prev(pend7, false);
      
 		eq sent_at_time0 : int;
 		eq sent_at_time1 : int;
 		eq sent_at_time2 : int;
 		eq sent_at_time3 : int;
 		eq sent_at_time4 : int;
 		eq sent_at_time5 : int;
 		eq sent_at_time6 : int;
 		eq sent_at_time7 : int;
 		
 		-- all time values are positive
      	guarantee "k val is positive" : k >= 0;
      	guarantee "sent times are positive" : sent_at_time0 >= 0 
      		and sent_at_time1 >= 0 and sent_at_time2 >= 0 and sent_at_time3 >= 0
      		and sent_at_time4 >= 0 and sent_at_time5 >= 0 and sent_at_time6 >= 0
      		and sent_at_time7 >= 0;
      	 
      	-- If a signal is pending, then there exists a time in the past when it was sent, and it has not been polled at all times in between.
      	guarantee "rtos prop 5" : pend0 => sent_at_time0 <= k and Agree_Nodes.at_time(sent0, sent_at_time0);
      	
      	-- If a pending signal is not polled within k steps then it is still pending.
      	guarantee "still_pend0" : Agree_Nodes.true_since(pend0, k) => Agree_Nodes.false_since(poll0, k);
      	guarantee "still_pend1" : Agree_Nodes.true_since(pend1, k) => Agree_Nodes.false_since(poll1, k);
      	guarantee "still_pend2" : Agree_Nodes.true_since(pend2, k) => Agree_Nodes.false_since(poll2, k);
      	guarantee "still_pend3" : Agree_Nodes.true_since(pend3, k) => Agree_Nodes.false_since(poll3, k);
      	guarantee "still_pend4" : Agree_Nodes.true_since(pend4, k) => Agree_Nodes.false_since(poll4, k);
      	guarantee "still_pend5" : Agree_Nodes.true_since(pend5, k) => Agree_Nodes.false_since(poll5, k);
      	guarantee "still_pend6" : Agree_Nodes.true_since(pend6, k) => Agree_Nodes.false_since(poll6, k);
      	guarantee "still_pend7" : Agree_Nodes.true_since(pend7, k) => Agree_Nodes.false_since(poll7, k);
      **};
      
  end Motor_Control;
end SOFTWARE;