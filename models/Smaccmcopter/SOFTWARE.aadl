package SOFTWARE
public
  with UAV;
  with DATATYPES;
  with IVORY;
  with IVORY_TYPES;
  with Static_Analysis;
  with SMACCM;
  with Mode_Properties;

  system Software
    features
      motors_and_radios: feature group UAV::motors_and_radios;
      sensors: feature group UAV::sensors;
  end Software;
  
  system implementation Software.Impl
    subcomponents
      ML: process Main_Loop.Impl;
             
    connections
      feature group motors_and_radios <-> ML.motors_and_radios;
      feature group sensors <-> ML.sensors;
  end Software.Impl;
  
  process Main_Loop
    features
      motors_and_radios: feature group UAV::motors_and_radios;
      sensors: feature group UAV::sensors;
      
      -- These are disconnected until we want to specify exactly 
      -- the transition conditions. We would leave them out, but AADL
      -- requires some condition on each mode transition.
      e1: in event port;
      e2: in event port;
      e3: in event port;
      e4: in event port;
      
      
       annex agree {**

			const max_accel : real = 5.0; 
			eq tv_speed : real = motors_and_radios.flight_control_commands.f1;
			eq av_speed : real = sensors.motion_data.vertical_speed;

			assume "target speed is positive" : tv_speed >= 0.0;
			assume "reasonable target speed" : tv_speed < 150.0;
			assume "zero initial speed" : (av_speed = 0.0) -> true;
			
			property const_tar_speed = 
				Agree_Nodes.H(tv_speed = prev(tv_speed,tv_speed)); 
			
			guarantee "actual speed is less than constant target speed" : 
				const_tar_speed => (av_speed <= tv_speed);
			
			guarantee "acceleration is limited" : 
				Agree_Nodes.abs(av_speed - prev(av_speed, 0.0)) < max_accel;
				
	**};
      
  end Main_Loop;
    
  abstract environment
  	features
  		motor_input : in data port DATATYPES::Motor_Commands.Impl;
  		sensor_output : out data port DATATYPES::Sensor_Data.Impl;
  end environment;
  
  process implementation Main_Loop.Impl
    subcomponents
      SS: thread Sensors in modes (Boot, Normal, Defensive);
      CCT: thread Command_Control_Telemetry in modes (Normal);
      BC: thread Backup_Commands in modes (Defensive);
      --RC: thread Radio_Control in modes (Normal);
      SN: thread Stability_Navigation in modes (Normal, Defensive);
      MC: thread Motor_Control in modes (Normal, Defensive);
      DC: thread Decrypt in modes (Normal);
      ENV: abstract environment;
      
    connections
      feature group sensors <-> SS.sensors_in 
      {Communication_Properties::Timing => immediate;} 
      in modes (Normal, Defensive, Boot) ;
      -- port motors_and_radios.flight_control_commands -> RC.commands_in in modes (Normal);
      port motors_and_radios.mavlink -> DC.encrypt_in in modes (Normal);
      port DC.decrypt_out -> CCT.mavlink_in in modes (Normal);
      
      port SS.sensors_out -> SN.sensors
      {Communication_Properties::Timing => immediate;}
      in modes (Normal, Defensive, Boot);
      
      -- port RC.commands_out -> SN.rc_commands in modes (Normal);
      port CCT.mavlink_out -> SN.mavlink  in modes (Normal);
      port BC.mavlink_out -> SN.mavlink  in modes (Defensive);
      
      port SN.motor_commands -> MC.motor_commands in modes (Normal, Defensive);
      port MC.servo1_commands -> motors_and_radios.motor1 in modes (Normal, Defensive);      
      port MC.servo2_commands -> motors_and_radios.motor2 in modes (Normal, Defensive);      
      port MC.servo3_commands -> motors_and_radios.motor3 in modes (Normal, Defensive);      
      port MC.servo4_commands -> motors_and_radios.motor4 in modes (Normal, Defensive);
      
      --connect motors and sensors to the environment for agree
      
    modes
      Boot: initial mode;
      Maintenance: mode;
      Normal: mode;
      Defensive: mode;
      
      Boot -[e1]-> Normal;
      Boot -[e2]-> Normal;
      Normal -[e3]-> Defensive;
      Defensive -[e4]-> Normal;
      
      --  +------+     +--------+     +-----------+
      --  | Boot |---->| Normal |<--->| Defensive |
      --  +------+     +--------+     +-----------+
      --      |
      --      v
      --  +-------------+
      --  | Maintenance |
      --  +-------------+
      
    properties 
      SMACCM::OS => "Breakaway-RTOS";
      
    annex resolute {** 
    	prove no_external_commands(this.SN, this) modes: Defensive
    	-- This property should fail:
    	-- prove no_external_commands(this.SN, this) modes: Normal
    	
    	prove schedulable(this) modes: Normal
    	prove schedulable(this) modes: Defensive 
    	 
    	prove no_radio_commands(this.SN) modes: Defensive
    	
    	prove receives_mavlink(this.SN) modes: Defensive
    	prove receives_mavlink(this.SN) modes: Normal
    	      
    	prove only_receive_gs(this.MC) modes: Normal
    **};
    
    annex agree {**

    	assert av_speed = prev(av_speed, 0.0) + 0.1 * SN.motor_commands.val;
    	assert motors_and_radios.flight_control_commands.f1 = SN.rc_commands.f1;
    	assert SN.sensors.speed = av_speed;
    	
    **};

  end Main_Loop.Impl;
  
  thread Decrypt
  	features 
  	    private_key : in data port DATATYPES::Private_Key_Data;
  		encrypt_in  : in data port DATATYPES::EncryptMAVlink;
  		decrypt_out : out data port DATATYPES::MAVlink;
  	properties
  	  Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
  	  Dispatch_Protocol => Aperiodic;
  	  SMACCM::Encryption_Algorthim => "AES-128-GCM";
  	  SMACCM::Always_Sends_Message => true;
  	  SMACCM::Language => "Ivory";
  end Decrypt;
  
  thread User_Interface 
    features
      flight_mode_out: out data port Ivory_Types::flightmode;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
      
      Source_Text => ("app/stabilize_hil/main.cpp");
      Initialize_Entrypoint_Source_Text => "main";
      Compute_Entrypoint_Source_Text => "main_task";
      
      Static_Analysis::Writes_to_buffers => ("motorsoutput_shared_state");
      Static_Analysis::Reads_from_buffers => ("userinput_shared_state",
        "sensors_shared_state", "gcs_shared_state");
        
      SMACCM::Language => "Ivory";
  end User_Interface;

  thread Stability_Navigation
    features
      rc_commands: in data port DATATYPES::Flight_Control_Commands.Impl;
      mavlink: in data port DATATYPES::MAVLink;
      sensors: in data port DATATYPES::Sensor_Data.Impl;
      motor_commands: out data port DATATYPES::Motor_Commands.Impl;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
      
      Source_Text => ("app/stabilize_hil/main.cpp");
      Initialize_Entrypoint_Source_Text => "main";
      Compute_Entrypoint_Source_Text => "main_task";
      
      Static_Analysis::Writes_to_buffers => ("motorsoutput_shared_state");
      Static_Analysis::Reads_from_buffers => ("userinput_shared_state",
        "sensors_shared_state", "gcs_shared_state");

      SMACCM::Language => "Ivory"; 
      
      annex agree {** 
		eq e : real = rc_commands.f1 - sensors.speed;
		eq e_int : real = prev(e, 0.0) + e; 
		eq e_dot : real = prev(e, 0.0) - e;
		
		eq u : real = 0.2*e + 0.1*e_dot + 0.1*e_int;
		guarantee "Acuator_Behavior" : motor_commands.val = u;
	  **}; 
      
      
  end Stability_Navigation;
 
  thread Backup_Commands
    features
      mavlink_out: out data port DATATYPES::MAVLink;
      
    properties
    
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
    
      Dispatch_Protocol => Aperiodic;
      
      Source_Text => ("src/gcs_receive.c");
      Initialize_Entrypoint_Source_Text => "gcs_receive_init";
      Compute_Entrypoint_Source_Text => "gcs_receive_task";
      
      Static_Analysis::Writes_to_buffers => ("gcs_shared_state");
      SMACCM::Always_Sends_Message => true;
      SMACCM::Language => "Ivory";
  end Backup_Commands;

  thread Command_Control_Telemetry
    features
      mavlink_in: in event data port DATATYPES::MAVLink;
      mavlink_out: out data port DATATYPES::MAVLink;
      
    properties
    
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
    
      Dispatch_Protocol => Aperiodic;
      Dispatch_Trigger => (reference (mavlink_in));
      
      Source_Text => ("src/gcs_receive.c");
      Initialize_Entrypoint_Source_Text => "gcs_receive_init";
      Compute_Entrypoint_Source_Text => "gcs_receive_task";
      
      Static_Analysis::Writes_to_buffers => ("gcs_shared_state");
      SMACCM::Always_Sends_Message => true;
      SMACCM::Language => "Ivory";
  end Command_Control_Telemetry;
  
  thread Radio_Control
    features
      commands_in: in data port DATATYPES::Flight_Control_Commands.Impl;
      commands_out: out data port DATATYPES::Flight_Control_Commands.Impl;
    
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      Dispatch_Protocol => Periodic;
      Compute_Execution_Time => 1 ms .. 3 ms;
      
      Source_Text => ("src/userinput.cpp");
      Initialize_Entrypoint_Source_Text => "userinput_init";
      Compute_Entrypoint_Source_Text => "userinput_task";
      
      Static_Analysis::Writes_to_buffers => ("userinput_shared_state");
      SMACCM::Language => "Ivory";
  end Radio_Control;

  thread Sensors
    features
      sensors_in: feature group UAV::sensors;
      sensors_out: out data port DATATYPES::Sensor_Data.Impl;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 10ms;
      
      Dispatch_Protocol => Periodic;
	
      Source_Text => ("src/sensors.cpp");
      Initialize_Entrypoint_Source_Text => "sensors_init";
      Compute_Entrypoint_Source_Text => "sensors_task";
      
      Static_Analysis::Writes_to_buffers => ("sensors_shared_state");
      SMACCM::Language => "Ivory";
      
  end Sensors;

  thread Motor_Control
    features
      motor_commands: in data port DATATYPES::Motor_Commands;
      servo1_commands: out data port DATATYPES::Servo_Commands;
      servo2_commands: out data port DATATYPES::Servo_Commands;
      servo3_commands: out data port DATATYPES::Servo_Commands;
      servo4_commands: out data port DATATYPES::Servo_Commands;
      
    properties
      Period => 200ms;
      Deadline => 200ms;
      SMACCM::WC_Execution_Time => 20ms;
      
      Dispatch_Protocol => Periodic;
      Compute_Execution_Time => 1 ms .. 3 ms;
      
      Source_Text => ("src/motorsoutput.cpp");
      Initialize_Entrypoint_Source_Text => "motorsoutput_init";
      Compute_Entrypoint_Source_Text => "motorsoutput_task";
      
      Static_Analysis::Reads_from_buffers => ("motorsoutput_shared_state");
      SMACCM::Language => "Ivory";
  end Motor_Control;
end SOFTWARE;