package Mission_Software
public
  with software_types;
with SMACCM;
  
system software
  features
    mission_out : out event data port software_types::can_data;
    mission_in : in event data port software_types::can_data;
    enc_mavlink_in : in event data port software_types::EncryptMAVLink;
    enc_mavlink_out : out event data port software_types::EncryptMAVLink;
    
  annex agree {**
  		
  	eq time : real;
  	
  	guarantee "if no message is received on the mavlink then nothing is passed to the mission board" : true;
  	
  	guarantee "if messasage fails to decrypt then nothing is sent to the mission board" : true;
  	
  **};
    
end software;
 
system implementation software.i
  subcomponents
    decrypt : process decrypt_t;
    receive : process receive_t;
    nav : process nav_t;
    mavlink : process mavlink_t;
    can : process can_a15_t;
    transmit : process transmit_t;
    encrypt : process encrypt_t;
    
  connections
    conn0 : port enc_mavlink_in -> decrypt.enc_mavlink;
    conn1 : port decrypt.mavlink_out -> receive.mavlink_in;
    
    conn2 : port receive.nav_mav -> nav.mavlink_in;
    conn3 : port receive.user_input_mav -> mavlink.mavlink_in;
    
    conn4 : port mavlink.user_input -> can.user_input;
    conn5 : port mavlink.control_law_out -> can.control_law;
    
    conn6 : port nav.waypoints -> can.waypoints;
    
    conn7 : port can.sensor_data -> transmit.sensor_data;
    conn8 : port can.control_data -> transmit.control_data;
    conn9 : port can.motmix_data -> transmit.motmix_data;
    
    conn10 : port transmit.mavlink_out -> encrypt.mavlink;
    conn11 : port encrypt.enc_mavlink -> enc_mavlink_out;
    
    conn12 : port can.mission_out -> mission_out;
    conn13 : port mission_in -> can.mission_in;
    
  properties
    SMACCM::OS => "seL4";
    
  annex agree {**
  		
  	synchrony : asynchronous;
  	
  	const DECRYPT_EXEC_TIME : real = 5.0;
  	const ENCRYPT_EXEC_TIME : real = 5.0;
  	const NAV_EXEC_TIME : real = 5.0;
  	const MAVLINK_EXEC_TIME : real = 5.0;
  	const CAN_EXEC_TIME : real = 5.0;
  	const TRANSMIT_EXEC_TIME : real = 5.0;
  	const RECEIVE_EXEC_TIME : real = 5.0;
  	
  	const RECEIVE_PERIOD : real = 50.0;
  	
  	eq decrypt_clock : bool = decrypt._CLK;
  	eq encrypt_clock : bool = encrypt._CLK;
  	eq nav_clock : bool = nav._CLK;
  	eq mavlink_clock : bool = mavlink._CLK;
  	eq can_clock : bool = can._CLK;
  	eq transmit_clock : bool = transmit._CLK;
  	eq receive_clock : bool = receive._CLK;
  	
  	--assert that no one can preempt
  	assert decrypt_clock =>
  	  not (rise(encrypt_clock) or rise(nav_clock) or rise(mavlink_clock) or
  	  	   rise(can_clock) or rise(transmit_clock) or rise(receive_clock));
  	
  	assert encrypt_clock =>
  	  not (rise(decrypt_clock) or rise(nav_clock) or rise(mavlink_clock) or
  	  	   rise(can_clock) or rise(transmit_clock) or rise(receive_clock));
  	
  	assert nav_clock =>
  	  not (rise(encrypt_clock) or rise(decrypt_clock) or rise(mavlink_clock) or
  	  	   rise(can_clock) or rise(transmit_clock) or rise(receive_clock));
  	
  	assert mavlink_clock =>
  	  not (rise(encrypt_clock) or rise(nav_clock) or rise(decrypt_clock) or
  	  	   rise(can_clock) or rise(transmit_clock) or rise(receive_clock));
  	
  	assert can_clock =>
  	  not (rise(encrypt_clock) or rise(nav_clock) or rise(mavlink_clock) or
  	  	   rise(decrypt_clock) or rise(transmit_clock) or rise(receive_clock));
  	
  	assert transmit_clock =>
  	  not (rise(encrypt_clock) or rise(nav_clock) or rise(mavlink_clock) or
  	  	   rise(can_clock) or rise(decrypt_clock) or rise(receive_clock));
  	  	   
  	--assert that a thread only begins computation if it is scheduled or 
  	--event driven to do so
  	assert rise(receive_clock) => receive_scheduled;
  	assert rise(decrypt_clock) => event(decrypt.enc_mavlink);
  	
  	
  	eq time_of_next_receive : real = RECEIVE_PERIOD ->
  	  if time < pre(time_of_next_receive) then
  	    pre(time_of_next_receive)
  	  else
  	    pre(time_of_next_receive) + RECEIVE_PERIOD;
  	
  	eq receive_scheduled : bool = true ->
  	  if time = pre(time_of_next_receive) then
  	    true
  	  else if pre(receive_clock) then
  	    false
  	  else
  	    pre(receive_scheduled);
  	  	   
  	node rise (clock : bool) returns (ret : bool);
  	let
  	  ret = clock -> not pre(clock) and clock;
  	tel;
  	
  	node fall (clock : bool) returns (ret : bool);
  	let
  	  ret = false -> pre(clock) and not clock;
  	tel;
  	
  **};
    
end software.i;

process decrypt_t
  features
    enc_mavlink : in event data port software_types::EncryptMAVLink;
    mavlink_out : out event data port software_types::MAVLink;
    
  properties
    SMACCM::Authenticator => true;
    
    
  annex agree {**
  	
  	eq message_passed_decryption : bool;
  	
  	guarantee "if no message is received, then nothing decrypted" : 
  	  not event(mavlink_out) -> event(mavlink_out) => pre(event(enc_mavlink)) and message_passed_decryption;
  	
  **};
    
end decrypt_t;

process receive_t
  features
    mavlink_in : in event data port software_types::MAVLink;
    nav_mav : out event data port software_types::MAVLink;
    user_input_mav : out event data port software_types::MAVLink;
    
  properties
    SMACCM::Trusted => true;
end receive_t;

process mavlink_t
  features
    mavlink_in : in event data port software_types::MAVLink;
    user_input : out event data port software_types::userinput_result.impl;
    control_law_out : out event data port software_types::control_law.impl;
    
  properties
    SMACCM::Trusted => true;
end mavlink_t;

process nav_t
  features
    mavlink_in : in event data port software_types::MAVLink;
    waypoints : out event data port software_types::waypoint;
    
  properties
    SMACCM::Trusted => true;
end nav_t;

process can_a15_t
  features
    waypoints : in event data port software_types::waypoint;
    user_input : in event data port software_types::userinput_result.impl;
    control_law  : in event data port software_types::control_law.impl;
    mission_out : out event data port software_types::can_data;
    mission_in : in event data port software_types::can_data;
    mavlink_out : out event data port software_types::MAVLink;
    sensor_data : out event data port software_types::position.impl;
    control_data : out event data port software_types::controloutput.impl;
    motmix_data : out event data port software_types::motors_data;
    
  properties
    SMACCM::Trusted => true;
end can_a15_t;

process transmit_t
  features
    sensor_data : in event data port software_types::position.impl;
    control_data : in event data port software_types::controloutput.impl;
    motmix_data : in event data port software_types::motors_data;
    mavlink_out : out event data port software_types::MAVLink;
    
  properties
    SMACCM::Trusted => true;
end transmit_t;

process encrypt_t
  features
    enc_mavlink : out event data port software_types::EncryptMAVLink;
    mavlink : in event data port software_types::MAVLink;
    
  properties
    SMACCM::Trusted => true;
end encrypt_t;

end Mission_Software;