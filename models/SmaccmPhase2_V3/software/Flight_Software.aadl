package Flight_Software
public
  with software_types;
  with hardware_types;
  with SMACCM;
  with Base_Types;
  
process main
  features
    mission_out : out event data port software_types::can_data;
    mission_in : in event data port software_types::can_data;
    ppm_in : in event data port software_types::Flight_Control_Commands.i;
    
    sensors_group : feature group hardware_types::Sensors;
    battery : in data port software_types::Battery_Data;

  annex agree {**
  	
  	--this is an arbitrary constant that we
  	--will eventually use to represent the latency
  	--of running all the tasks back to back
  	const latency : real = 50.0;
  	
  	--this is an arbitarry constant that we will
  	--use to represent the total time passed
  	--without receiving a can message until the 
  	--mode should be set to landing
  	const total_landing_timeout : real = 800.0;
  	
  	--bounds frequency for ppms to occur
  	const ppm_period : real = 10.0;
  	
  	--bounds frequency for can messages
  	const mission_period : real = 10.0;
  	
  	eq time : real;
  	eq control_mode : int;
  	
  	  	
  	eq time_of_last_can : real = 
  	  if event(mission_in) then time else prev(time_of_last_can, -1.0);
  	
  	eq time_of_last_ppm : real =
  	  if event(ppm_in) then time else prev(time_of_last_ppm, -1.0);    
  	
  	eq was_armed : bool =  
  	  control_mode = AGREE_CONSTS.ARMED_MODE -> pre(was_armed) or control_mode = AGREE_CONSTS.ARMED_MODE;
  	
  	assume "time is positive and increasing" :
  	  time >= 0.0 and (true -> time > pre(time));
  	
  	--assumptions about how often events can occur
  	assume "not frequent ppms" : true ->
  	  time - pre(time) < ppm_period => not (event(ppm_in) and pre(event(ppm_in)));
  	  
  	assume "not frequent can" : true ->
  	  time - pre(time) < mission_period => not (event(mission_in) and pre(event(mission_in)));
  	
  	guarantee "if time passes with no message then the mode is landing" :
  	  was_armed => 
  	    time - time_of_last_ppm > total_landing_timeout and
  	    time - time_of_last_can > total_landing_timeout => 
  	      control_mode = AGREE_CONSTS.LAND_MODE;
  	      
  	guarantee "if the controller is armed, then an armed signal in the past" : true;
  	
  	guarantee "if an arm signal is sent from the ppm controller the controller will be armed" : true;
  	
  	guarantee "if the controller is not armed then the motors should not spin" : true;
  	
  **};
end main;


process implementation main.i
  subcomponents
    can : thread can_px4_t;
    ppm : thread ppm_t;
    control : thread control_t;
    ui_mux : thread ui_mux_t;
    gps : thread ublox_gps_t;
    sensors : thread sensors_t;
    motmix : thread motmix_t;
    control_law : thread control_law_t;
    
    control_params : data software_types::control_data.impl { SMACCM::Trusted => true; };
    
  connections
    conn0 : port sensors.sensor_data -> can.sensor_data;
    conn1 : port control.control_out -> can.control_data;
    conn2 : port motmix.motors -> can.motmix_data;
    conn3 : port mission_in -> can.mission_in;
    conn4 : port can.mission_out -> mission_out;
    conn5 : port can.mav_user_input -> ui_mux.mavlink_input;
    conn7 : port can.mav_control_law -> control_law.mav_law;
    navlaw : port can.nav_control_law -> control_law.nav_law;
    
    ppm1 : port ppm_in -> ppm.flight_command;
    ppm2 : port ppm.user_input -> ui_mux.ppm_input;
    ppm3 : port ppm.control_law_out -> control_law.ppm_law;
    
    conn8 : port ui_mux.input_select -> control.user_input;
    conn9 : port control_params -> control.control_params;
    conn11 : port control.control_out -> motmix.control_in;
    law : port control_law.out_law -> control.control_law;
       
    conn13 : port gps.position -> sensors.gps; 
    
    conn14 : port sensors.sensor_data -> control.sensor_data;

    conn15 : port sensors_group.barometer -> sensors.barometer;
    conn16 : port sensors_group.motion -> sensors.motion;
    conn17 : port sensors_group.gps -> gps.input;
    conn18 : port battery -> sensors.battery;
    
    clawmux : port control_law.out_law -> ui_mux.control_law;
  
  properties
    SMACCM::OS => "eChronos";
  
  annex agree {**
  	
  	synchrony : asynchronous;
  	
  	const control_period : real = 5.0;  	
  	assert control_mode = control.mode;
  	
  	--precidence for whose clock ticks
  	assert if event(ppm_in) then ppm._CLK else
  	       if event(mission_in) then can._CLK else
  	       if event(control_law.ppm_law) then control_law._CLK else
  	       if event(control_law.nav_law) then control_law._CLK else
  	       if event(control_law.mav_law) then control_law._CLK else
  	       if event(ui_mux.ppm_input) then ui_mux._CLK else
  	       if event(ui_mux.mavlink_input) then ui_mux._CLK else
  	       if event(ui_mux.control_law) then ui_mux._CLK else true;
  	       
  	       


  	
  **};
  
  annex resolute {**
    	prove only_receive_legit(this.motmix)
  **};
end main.i;

thread can_px4_t
  features
    waypoints : out event data port software_types::waypoint;
    sensor_data : in event data port software_types::Sensor_Data;
    control_data : in event data port software_types::controloutput.impl;
    motmix_data : in event data port software_types::motors_data;
    mission_out : out event data port software_types::can_data;
    mission_in : in event data port software_types::can_data;
    mav_user_input : out event data port software_types::userinput_result.impl;
    mav_control_law : out event data port software_types::control_law_request.impl;
    nav_control_law : out event data port software_types::control_law_request.impl;
    
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
  
  annex agree {**

    initially:
      not event(nav_control_law) and
      not event(mav_control_law) and
      not event(mav_user_input) and
      not event(mission_out) and
      not event(waypoints);
      
    eq no_ouput_events : bool = 
      not event(nav_control_law) and
      not event(mav_control_law) and
      not event(mav_user_input) and
      not event(mission_out) and
      not event(waypoints);

  	--nothing is sent if can_data does not arrive.
  	guarantee "no can data" : no_ouput_events ->
  	  not pre(event(mission_in)) => no_ouput_events;
  	
  **};
  
end can_px4_t;

thread control_law_t
  features
    mav_law : in event data port software_types::control_law_request.impl;
    nav_law : in event data port software_types::control_law_request.impl;
    ppm_law : in event data port software_types::control_law_request.impl;
    out_law : out event data port software_types::control_law.impl;

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;


  annex agree {**
  	--TODO why do mavlink changes not get published?
  	--TODO who gets precidence for arming? We make the assumption that the
  	--MAV law will always take precidence
  	
  	const yaw_mode_rate : int = 0;
  	const yaw_mode_heading : int = 1;
  	const ui_mavlink : int = 1;
  	const ui_ppm : int = 0;
  	const auto_throttle : int = 1;
  	const direct_throttle : int = 0;
  	
  	const ARMED_SAFE : int = 0;
  	const ARMED_DISARMED : int = 1;
  	const ARMED_ARMED : int = 2;
  	
  	const init_law : software_types::control_law.impl = 
  	   software_types::control_law.impl { 
  	   	armed_mode = 0;
  	   	ui_source = 0;
        yaw_mode = 0;
        thr_mode = 0;
        autothr_source = 0;
        stab_source = 0;
        head_source = 0;
        time = 0;
        flight_mode = 0
		};
  
  	eq ui_source_mavlink : bool = false ->
  	  mav_law.set_ui_mavlink and ppm_law.set_ui_mavlink;
  	  
  	eq ui_source_ppm : bool = not ui_source_mavlink;
  	
  	--assume that we only handle one event at a time
  	assume "a single event occurs" : 
  	  (event(ppm_law) => not (event(mav_law) or event(nav_law))) and
  	  (event(mav_law) => not (event(ppm_law) or event(nav_law))) and
  	  (event(nav_law) => not (event(ppm_law) or event(mav_law)));
 
  	guarantee "law is always initialized to the initial state" :
  	  out_law = init_law and event(out_law) -> true;
  	
    --note that only ppm and nav events cause an event to be emitted
  	guarantee "output events only occur if and only if nav or ppm events happen" : true ->
  	  event(out_law) = (event(nav_law) or event(ppm_law));
  	  
  	guarantee "source selection":
  	  out_law.ui_source = if ui_source_mavlink then ui_mavlink else ui_ppm;
  	  
   --arming logic stuff
   
    guarantee "initially we are always in safe mode" : 
      out_law.armed_mode = ARMED_SAFE -> true;
      
    guarantee "ppm arming logic" : true -> event(ppm_law) =>
      if pre(out_law.armed_mode) = ARMED_SAFE and not ppm_law.set_safe then
        out_law.armed_mode = ARMED_DISARMED
      else if ppm_law.set_safe then
        out_law.armed_mode = ARMED_SAFE
      else if ppm_law.set_disarmed then
        out_law.armed_mode = ARMED_DISARMED
      else if ppm_law.set_armed  then
        out_law.armed_mode = ARMED_ARMED
      else
        out_law.armed_mode = pre(out_law.armed_mode);
  	    	  
  	    	  
  	guarantee "mav arming logic" : true -> event(mav_law) =>
  	  if pre(out_law.armed_mode) = ARMED_SAFE then
  	    true
  	  else if mav_law.set_disarmed then
  	    out_law.armed_mode = ARMED_DISARMED
  	  else if mav_law.set_armed then
  	    out_law.armed_mode = ARMED_ARMED
  	  else
  	    out_law.armed_mode = pre(out_law.armed_mode);
  	    
    guarantee "if neither ppm nor mav events occur then the arming state remains the same" : true ->
      not(event(ppm_law) or event(mav_law)) => out_law.armed_mode = pre(out_law.armed_mode);
  	    	  
  	    	  
-- WE PROBABLY DO NOT NEED TO MODEL THESE CONSTRAINTS  	    	  
--  	guarantee "yaw mode": out_law.yaw_mode = 
--      if ui_source_ppm and ppm_req.set_yaw_heading then
--        yaw_mode_heading
--      else if ui_source_mavlink and mav_req.set_yaw_heading then
--        yaw_mode_heading
--      else
--        yaw_mode_rate;
--        
--    guarantee "throttle mode" : out_law.thr_mode =
--      if ui_source_ppm and ppm_req.set_thr_auto then 
--        auto_throttle
--      else if ui_source_mavlink and mav_req.set_thr_auto then
--        auto_throttle
--      else
--        direct_throttle;
        
  	  
  	
  **};
    
end control_law_t;

thread ppm_t
  features
    flight_command : in event data port software_types::Flight_Control_Commands.i;
    user_input : out event data port software_types::userinput_result.impl;
    control_law_out : out event data port software_types::control_law_request.impl;
      
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
   
  annex agree {**
  	
  	initially:
  	  not (event(user_input) or event(control_law_out));

  	guarantee "events generated simultaneously" :
  	  event(user_input) = event(control_law_out) and
  	  event(user_input) = event(flight_command);
  	  
  	guarantee "no ambiguous user_input_selects" :
  	  not control_law_out.set_ui_ppm and control_law_out.set_ui_mavlink and
   	    (control_law_out.set_ui_ppm or control_law_out.set_ui_mavlink);
  	
  	
  **};
end ppm_t;

thread control_t
  features
    user_input : in event data port software_types::userinput_result.impl;
    control_params : in event data port software_types::control_data.impl;
    control_law : in event data port software_types::control_law.impl;
    sensor_data : in event data port software_types::Sensor_Data;
    control_out : out event data port software_types::controloutput.impl;

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
    
    annex agree {**
   
      const LANDING_TIMEOUT : real = 100.0;
   
      eq mode : int = control_law.flight_mode;
  	  
  	  initially :
  	    mode = AGREE_CONSTS.DISARMED_MODE;

  	  assume "valid modes for control input":
  	      control_law.armed_mode = AGREE_CONSTS.LAND_MODE or
  	      control_law.armed_mode = AGREE_CONSTS.ARMED_MODE or
  	      control_law.armed_mode = AGREE_CONSTS.DISARMED_MODE;

    **};
    
end control_t;

thread ui_mux_t
  features
    ppm_input : in event data port software_types::userinput_result.impl;
    mavlink_input : in event data port software_types::userinput_result.impl;
    
	control_law : in event data port software_types::control_law.impl;
    input_select : out event data port software_types::userinput_result.impl;
          
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
    
   annex agree {**
     eq blah : int = 0;
   **};
    
end ui_mux_t;

thread ublox_gps_t
  features
    input : in event data port hardware_types::GPS;
    position : out event data port software_types::position.impl;
    time : in data port Base_Types::Float;

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
end ublox_gps_t;

thread sensors_t
  features
    barometer : in data port software_types::Barometric_Data;
    motion : in data port software_types::Motion_Data.Impl;
    battery : in data port software_types::Battery_Data;
    gps : in data port software_types::Position.Impl;
    
    sensor_data : out event data port software_types::Sensor_Data;  

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
end sensors_t;

thread motmix_t
  features
    motors : out data port software_types::motors_data.impl;
    control_in : in data port software_types::controloutput.impl;
    control_law_in : in event data port software_types::control_law.impl;
    time : in data port Base_Types::Float;
  
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
    
  annex agree {**

  	const disabled : software_types::motors_data.impl = 
  	  software_types::motors_data.impl {
  	    frontleft = 0.0;  
  	    frontright = 0.0; 
  	    backleft = 0.0;
  	    backright = 0.0 
  	   };
  	   
  	initially:
  	  motors = disabled;
  	   
    guarantee "motors are initially disabled" : motors = disabled -> true;
  	   
  **};
    
end motmix_t;
	
end Flight_Software;