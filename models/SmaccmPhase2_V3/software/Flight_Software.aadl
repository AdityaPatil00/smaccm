package Flight_Software
public
  with software_types;
  with hardware_types;
  with SMACCM;
  with Base_Types;
  
process main
  features
    mission_out : out event data port software_types::can_data;
    mission_in : in event data port software_types::can_data;
    ppm_in : in event data port software_types::Flight_Control_Commands.i;
    
    sensors_group : feature group hardware_types::Sensors;
    battery : in data port software_types::Battery_Data;

  annex agree {**
  	
  	--this is an arbitrary constant that we
  	--will eventually use to represent the latency
  	--of running all the tasks back to back
  	const latency : real = 50.0;
  	
  	--this is an arbitarry constant that we will
  	--use to represent the total time passed
  	--without receiving a can message until the 
  	--mode should be set to landing
  	const total_landing_timeout : real = 800.0;
  	
  	eq time : real;
  	eq control_mode : int;
  	eq mavlink_has_control : bool;
  	  	
  	eq time_of_last_can : real = 
  	  if event(mission_in) then time else prev(time_of_last_can, -1.0);
  	  
    eq time_since_mavlink_in_control : real = 
      if not mavlink_has_control then 0.0 else prev(time_since_mavlink_in_control, 0.0);
  	
  	eq was_armed : bool = 
  	  control_mode = AGREE_CONSTS.ARMED_MODE -> pre(was_armed) or control_mode = AGREE_CONSTS.ARMED_MODE;
  	
  	guarantee "if time passes with no message then the mode is landing" :
  	  was_armed => 
  	    time - time_since_mavlink_in_control > total_landing_timeout and
  	    time - time_of_last_can > total_landing_timeout => 
  	      control_mode = AGREE_CONSTS.LAND_MODE;
  	      
  	guarantee "if the controller is armed, then an armed signal in the past" : true;
  	
  	guarantee "if an arm signal is sent from the ppm controller the controller will be armed" : true;
  	
  **};
end main;


process implementation main.i
  subcomponents
    can : thread can_px4_t;
    ppm : thread ppm_t;
    control : thread control_t;
    ui_mux : thread ui_mux_t;
    gps : thread ublox_gps_t;
    sensors : thread sensors_t;
    motmix : thread motmix_t;
    control_law : thread control_law_t;
    
    control_params : data software_types::control_data.impl { SMACCM::Trusted => true; };
    
  connections
    conn0 : port sensors.sensor_data -> can.sensor_data;
    conn1 : port control.control_out -> can.control_data;
    conn2 : port motmix.motors -> can.motmix_data;
    conn3 : port mission_in -> can.mission_in;
    conn4 : port can.mission_out -> mission_out;
    conn5 : port can.mav_user_input -> ui_mux.mavlink_input;
    conn7 : port can.mav_control_law -> control_law.mav_law;
    navlaw : port can.nav_control_law -> control_law.nav_law;
    
    ppm1 : port ppm_in -> ppm.flight_command;
    ppm2 : port ppm.user_input -> ui_mux.ppm_input;
    ppm3 : port ppm.control_law_out -> control_law.ppm_law;
    
    conn8 : port ui_mux.input_select -> control.user_input;
    conn9 : port control_params -> control.control_params;
    conn11 : port control.control_out -> motmix.control_in;
    law : port control_law.out_law -> control.control_law;
       
    conn13 : port gps.position -> sensors.gps; 
    
    conn14 : port sensors.sensor_data -> control.sensor_data;

    conn15 : port sensors_group.barometer -> sensors.barometer;
    conn16 : port sensors_group.motion -> sensors.motion;
    conn17 : port sensors_group.gps -> gps.input;
    conn18 : port battery -> sensors.battery;
    
    clawmux : port control_law.out_law -> ui_mux.control_law;
  
  properties
    SMACCM::OS => "eChronos";
  
  annex agree {**
  	assert time = can.time;
  	assert time = control.time;
  	assert time = ppm.time;
  	assert time = ui_mux.time;
  	assert control_mode = control.mode;
  	
  	assert time = latency -> time = (pre(time) + latency);
  	assert time >= 0.0;
  	
  **};
  
  annex resolute {**
    	prove only_receive_legit(this.motmix)
  **};
end main.i;

thread can_px4_t
  features
    waypoints : out event data port software_types::waypoint;
    sensor_data : in event data port software_types::Sensor_Data;
    control_data : in event data port software_types::controloutput.impl;
    motmix_data : in event data port software_types::motors_data;
    mission_out : out event data port software_types::can_data;
    mission_in : in event data port software_types::can_data;
    mav_user_input : out event data port software_types::userinput_result.impl;
    mav_control_law : out event data port software_types::control_law_request.impl;
    nav_control_law : out event data port software_types::control_law_request.impl;
    time : in data port Base_Types::Float;
    --TODO: the type for control_law_out is surely different then from the ppm controller
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
  
  annex agree {**

  	--nothing is sent if can_data does not arrive.
  	guarantee "no can data" : not event(mission_in) ->
  	  not pre(event(mission_in)) => not event(mav_user_input);
  	  
  	guarantee "we only send user input if we send contol input" :
  	  event(mav_user_input) = event(mav_control_law) and
  	  event(mav_control_law) = event(nav_control_law);
  	
  **};
  
end can_px4_t;

thread control_law_t
  features
    mav_law : in event data port software_types::control_law_request.impl;
    nav_law : in event data port software_types::control_law_request.impl;
    ppm_law : in event data port software_types::control_law_request.impl;
    out_law : out event data port software_types::control_law.impl;

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;


  annex agree {**
  	--TODO why do mavlink changes not get published?
  	
  	const yaw_mode_rate : int = 0;
  	const yaw_mode_heading : int = 1;
  	const ui_mavlink : int = 1;
  	const ui_ppm : int = 0;
  	const auto_throttle : int = 1;
  	const direct_throttle : int = 0;
  	
  	
  	eq init_law : software_types::control_law.impl = 
  	   software_types::control_law.impl { 
  	   	armed_mode = 0;
  	   	ui_source = 0;
        yaw_mode = 0;
        thr_mode = 0;
        autothr_source = 0;
        stab_source = 0;
        head_source = 0;
        time = 0;
        flight_mode = 0
		};
  	
  	eq cur_law : software_types::control_law.impl;
  	eq ppm_req : software_types::control_law_request.impl;
  	eq mav_req : software_types::control_law_request.impl;
  	eq nav_req : software_types::control_law_request.impl;
  	
  	eq ui_source_mavlink : bool = false ->
  	  mav_req.set_ui_mavlink and ppm_req.set_ui_mavlink;
  	  
  	eq ui_source_ppm : bool = not ui_source_mavlink;
  	
  	--update the request variables if an event occured
  	guarantee "the mav_req variables update if a mav_event has occurred" : true ->
  	  if pre(event(mav_law)) then mav_req = pre(mav_law) else mav_req = pre(mav_req);
  	
  	guarantee "the nav_req variables update if a nav_event has occurred" : true ->
  	  if pre(event(nav_law)) then nav_req = pre(nav_law) else nav_req = pre(nav_req);
  	
  	guarantee "the ppm_req variables update if a ppm_event has occurred" : true ->
  	  if pre(event(ppm_law)) then ppm_req = pre(ppm_law) else ppm_req = pre(ppm_req);
  	  
  	guarantee "law is always initialized to the initial state" :
  	  cur_law = init_law -> true;
  	
  	
    --note that only  ppm and nav events cause an event to be emitted
  	guarantee "no events in means no events out" : not event(out_law) ->
  	  event(out_law) => pre(event(nav_law) or event(ppm_law));
  	
  	guarantee "constrain the ppm_req initially" :
  	  (ppm_req.set_ui_ppm = true and
  	  ppm_req.set_thr_direct = true and
  	  ppm_req.set_autothr_src_ui = true and
  	  ppm_req.set_stab_src_ui = true and
  	  ppm_req.set_head_src_ui = true) -> true;
  	  
  	guarantee "source selection":
  	  out_law.ui_source = if ui_source_mavlink then ui_mavlink else ui_ppm;
  	    	  
  	guarantee "yaw mode": out_law.yaw_mode = 
      if ui_source_ppm and ppm_req.set_yaw_heading then
        yaw_mode_heading
      else if ui_source_mavlink and mav_req.set_yaw_heading then
        yaw_mode_heading
      else
        yaw_mode_rate;
        
    guarantee "throttle mode" : out_law.thr_mode =
      if ui_source_ppm and ppm_req.set_thr_auto then 
        auto_throttle
      else if ui_source_mavlink and mav_req.set_thr_auto then
        auto_throttle
      else
        direct_throttle;
        
  	  
  	
  **};
    
end control_law_t;

thread ppm_t
  features
    flight_command : in event data port software_types::Flight_Control_Commands.i;
    user_input : out event data port software_types::userinput_result.impl;
    control_law_out : out event data port software_types::control_law_request.impl;
    time : in data port Base_Types::Float;
      
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
   
  annex agree {**
  	
  	initially:
  	  not (event(user_input) or event(control_law_out));

  	guarantee "events generated simultaneously" :
  	  event(user_input) = event(control_law_out) and
  	  event(user_input) = event(flight_command);
  	  
  	guarantee "no ambiguous user_input_selects" :
  	  not control_law_out.set_ui_ppm and control_law_out.set_ui_mavlink and
   	    (control_law_out.set_ui_ppm or control_law_out.set_ui_mavlink);
  	
  	
  **};
end ppm_t;

thread control_t
  features
    user_input : in event data port software_types::userinput_result.impl;
    control_params : in data port software_types::control_data.impl;
    control_law : in event data port software_types::control_law.impl;
    sensor_data : in event data port software_types::Sensor_Data;
    time : in data port Base_Types::Float;
    control_out : out event data port software_types::controloutput.impl;

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
    
    annex agree {**
   
      const LANDING_TIMEOUT : real = 100.0;
   
      eq mode : int;
  	  eq time_of_last_event : real = if event(user_input) then time else -1.0 -> pre(time);
  	  
  	  initially :
  	    mode = AGREE_CONSTS.DISARMED_MODE and
  	    time_of_last_event = 0.0;
  	    
  	  assume "control and input events occur simultaneously":
  	    event(user_input) = event(control_law);
  	    
  	  assume "valid modes for control input":
  	    event(control_law) =>
  	      control_law.armed_mode = AGREE_CONSTS.LAND_MODE or
  	      control_law.armed_mode = AGREE_CONSTS.ARMED_MODE or
  	      control_law.armed_mode = AGREE_CONSTS.DISARMED_MODE;
  	    
  	  guarantee "mode behavior":
  	    if(prev(event(user_input), false)) then
  	      mode = control_law.armed_mode
  	    else if(time_of_last_event >= LANDING_TIMEOUT) then
  	      mode = AGREE_CONSTS.LAND_MODE
  	    else
  	      mode = prev(mode, AGREE_CONSTS.DISARMED_MODE);

    **};
    
end control_t;

thread ui_mux_t
  features
    ppm_input : in event data port software_types::userinput_result.impl;
    mavlink_input : in event data port software_types::userinput_result.impl;
    
	control_law : in event data port software_types::control_law.impl;
    input_select : out event data port software_types::userinput_result.impl;
    time : in data port Base_Types::Float;
      
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
    
   annex agree {**
   	
     eq blah : int = 0;
   **};
    
end ui_mux_t;

thread ublox_gps_t
  features
    input : in event data port hardware_types::GPS;
    position : out event data port software_types::position.impl;
    time : in data port Base_Types::Float;

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
end ublox_gps_t;

thread sensors_t
  features
    barometer : in data port software_types::Barometric_Data;
    motion : in data port software_types::Motion_Data.Impl;
    battery : in data port software_types::Battery_Data;
    gps : in data port software_types::Position.Impl;
    
    sensor_data : out event data port software_types::Sensor_Data;  

  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
end sensors_t;

thread motmix_t
  features
    motors : out data port software_types::motors_data.impl;
    control_in : in data port software_types::controloutput.impl;
    control_law_in : in event data port software_types::control_law.impl;
    time : in data port Base_Types::Float;
  
  properties
    SMACCM::Language => "Ivory";
    SMACCM::Trusted => true;
    
    
  annex agree {**
  	  	
  	const disabled : software_types::motors_data.impl = 
  	  software_types::motors_data.impl {
  	    frontleft = 0.0;
  	    frontright = 0.0;
  	    backleft = 0.0;
  	    backright = 0.0 
  	   };
  	   
  	initially:
  	  motors = disabled;
  	   
    guarantee "motors are initially disabled" : motors = disabled -> true;
  	   
  **};
    
end motmix_t;
	
end Flight_Software;