package UAV
public
  with UAS;
  with PixHawk;
  with ODROID_XU;
  with XU_DAUGHTER_BOARD;
  with Flight_Software;
  with Mission_Software;
  with software_types;
  with hardware_types;
  
  system UAV
    features
      radio_access_915Mhz: requires bus access UAS::RF_Spectrum.RF_915MHz; 
      radio_access_2_4Ghz: requires bus access UAS::RF_Spectrum.RF_2_4GHz;
      mavlink_in : in event data port software_types::EncryptMAVLink;
      mavlink_out : out event data port software_types::EncryptMAVLink;
      ppm_commands: in event data port software_types::Flight_Control_Commands.i;
      
    annex agree {**
    		
      const TOTAL_LANDING_TIMEOUT : real = 500.0;
      const MAVLINK_TO_CAN_LATENCY_BOUND : real = 300.0;
      
      eq time : real;
  	  eq control_mode : int;
  	  
  	  eq last_mavlink_received_time : real =
  	    if event(mavlink_in) then time else prev(last_mavlink_received_time, -1.0);
  	  
  	  eq time_of_last_ppm : real =
  	    0.0 -> if event(ppm_commands) then time else pre(time_of_last_ppm);
    	
      const PPM_PERIOD : real = 100.0;
      
  	  assume "not frequent ppms" : true ->
  	    time - pre(time_of_last_ppm) < PPM_PERIOD => not event(ppm_commands); 
    	
      guarantee "if no ppm or mavlink commands are received then then vehicle is in landing mode" : true;
    	
      guarantee "if no ppm message is received and mavlink fails to decrypt then landing mode" : true;
    	
      guarantee "if no mavlink is received for a certain timeout than the vehicle is in land mode" : 
        time - last_mavlink_received_time > MAVLINK_TO_CAN_LATENCY_BOUND and
        time - time_of_last_ppm > TOTAL_LANDING_TIMEOUT 
          => control_mode = AGREE_CONSTS.LAND_MODE;
    	
    **};
  end UAV;
  
  system implementation UAV.Impl 
    subcomponents
      FSW: process Flight_Software::main.i;
      MSW: system Mission_Software::Software.i;
      PIXHAWK: system PixHawk::PixHawk.i;
      ODROID_XU: system ODROID_XU::ODROID_XU.i;
      XU_DAUGHTER: system XU_DAUGHTER_BOARD::XU_DAUGHTER_BOARD.i;
      can_bus : bus hardware_types::can;
      BATTERY : device Battery;
    connections 
      --hardware connections
      conn_ide: feature group XU_DAUGHTER.ide <-> ODROID_XU.ide;
      conn_mpi: feature group XU_DAUGHTER.mpi <-> ODROID_XU.mpi;
      
      conn_can_odroid : bus access XU_DAUGHTER.can <-> can_bus;
      conn_can_pixhawk : bus access PIXHAWK.can0 <-> can_bus;
      
      conn_sensors: feature group PIXHAWK.sensors_group <-> FSW.sensors_group;
      
      battery_conn: port BATTERY.battery -> FSW.battery;
      
      --software connections
      conn_ppm: port ppm_commands -> FSW.ppm_in;
      conn_mission0 : port MSW.mission_out -> FSW.mission_in;
      conn_mission1 : port FSW.mission_out -> MSW.mission_in;
      conn_mav_in : port mavlink_in -> MSW.enc_mavlink_in;
      conn_mav_out : port MSW.enc_mavlink_out -> mavlink_out;
            
    properties
      Actual_Connection_Binding => (reference (can_bus)) applies to conn_mission0;
      Actual_Connection_Binding => (reference (can_bus)) applies to conn_mission1;
      Actual_Memory_Binding => (reference (ODROID_XU)) applies to MSW;
      Actual_Memory_Binding => (reference (PIXHAWK.MC.FLASH)) applies to FSW;
      
      
    annex agree {**    		
    		
    	assert control_mode = FSW.control_mode;
    	assert FSW.time = time;
    	assert MSW.time = time;
    	
    	assert time = 0.0 -> true;
    	assert time >= 0.0 and (true -> time >= pre(time));
    	
    	lemma "time of last ppm the same" : time_of_last_ppm = FSW.time_of_last_ppm;
    **};
      
  end UAV.Impl;

device Battery
  features
    battery : out data port software_types::Battery_Data;
end Battery;

end UAV;