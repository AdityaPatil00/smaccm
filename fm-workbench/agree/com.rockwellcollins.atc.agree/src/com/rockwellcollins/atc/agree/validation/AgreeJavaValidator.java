/*
* generated by Xtext
*/
package com.rockwellcollins.atc.agree.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.osate.aadl2.AadlBoolean;
import org.osate.aadl2.AadlInteger;
import org.osate.aadl2.AadlReal;
import org.osate.aadl2.AadlString;
import org.osate.aadl2.Classifier;
import org.osate.aadl2.ClassifierType;
import org.osate.aadl2.ComponentClassifier;
import org.osate.aadl2.ComponentImplementation;
import org.osate.aadl2.ComponentType;
import org.osate.aadl2.DataSubcomponent;
import org.osate.aadl2.DataType;
import org.osate.aadl2.EnumerationType;
import org.osate.aadl2.NamedElement;
import org.osate.aadl2.Element;
import org.osate.aadl2.Property;
import org.osate.aadl2.PropertyType;
import org.osate.aadl2.Subcomponent;

import com.rockwellcollins.atc.agree.agree.AgreePackage;
import com.rockwellcollins.atc.agree.agree.Arg;
import com.rockwellcollins.atc.agree.agree.AssertStatement;
import com.rockwellcollins.atc.agree.agree.AssumeStatement;
import com.rockwellcollins.atc.agree.agree.BinaryExpr;
import com.rockwellcollins.atc.agree.agree.BoolLitExpr;
import com.rockwellcollins.atc.agree.agree.CallDef;
import com.rockwellcollins.atc.agree.agree.ConstStatement;
import com.rockwellcollins.atc.agree.agree.EqStatement;
import com.rockwellcollins.atc.agree.agree.Expr;
import com.rockwellcollins.atc.agree.agree.FnCallExpr;
import com.rockwellcollins.atc.agree.agree.FnDefExpr;
import com.rockwellcollins.atc.agree.agree.GetPropertyExpr;
import com.rockwellcollins.atc.agree.agree.GuaranteeStatement;
import com.rockwellcollins.atc.agree.agree.IdExpr;
import com.rockwellcollins.atc.agree.agree.IfThenElseExpr;
import com.rockwellcollins.atc.agree.agree.IntLitExpr;
import com.rockwellcollins.atc.agree.agree.NestIdExpr;
import com.rockwellcollins.atc.agree.agree.NestedDotID;
import com.rockwellcollins.atc.agree.agree.NextExpr;
import com.rockwellcollins.atc.agree.agree.NodeDefExpr;
import com.rockwellcollins.atc.agree.agree.NodeEq;
import com.rockwellcollins.atc.agree.agree.PreExpr;
import com.rockwellcollins.atc.agree.agree.PrevExpr;
import com.rockwellcollins.atc.agree.agree.PropertyStatement;
import com.rockwellcollins.atc.agree.agree.RealLitExpr;
import com.rockwellcollins.atc.agree.agree.ThisExpr;
import com.rockwellcollins.atc.agree.agree.UnaryExpr;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AgreeJavaValidator extends com.rockwellcollins.atc.agree.validation.AbstractAgreeJavaValidator {

	private final AgreeType parseFailType = new AgreeType("");
	private final AgreeType boolType = new AgreeType("bool");
	private final AgreeType intType = new AgreeType("int");
	private final AgreeType realType = new AgreeType("real");
	
	
	@Override
	protected boolean isResponsible(Map<Object, Object> context, EObject eObject) {
		return (eObject.eClass().getEPackage() == AgreePackage.eINSTANCE);
		// || eObject instanceof Connection
		// || eObject instanceof Property
		// || eObject instanceof ComponentClassifier);
	}
	
	public AgreeType getAgreeType(Arg arg){
		
		if(arg.getType() == null)
			return parseFailType;
		
		return new AgreeType(arg.getType().getName());
	}
	
	
	@Check
	public void checkAssume(AssumeStatement assume){
		
		if(assume.getExpr() == null)
			return;
		
		AgreeType exprType = getAgreeType(assume.getExpr());
	
		if(!exprType.matches(boolType)){
			error(assume, "Expression for assume statement is of type '"
					+exprType.toString()
					+"' but must be of type 'bool'");
		}
		
	}
	
	@Check
	public void checkAssert(AssertStatement asser){
		
		if(asser.getExpr() == null)
			return;
		
		Classifier comp = asser.getContainingClassifier();
		
		if(!(comp instanceof ComponentImplementation)){
			error(asser, "Assert statements are only allowed in component implementations.");
		}
		
		AgreeType exprType = getAgreeType(asser.getExpr());
	
		if(!exprType.matches(boolType)){
			error(asser, "Expression for assert statement is of type '"
					+exprType.toString()
					+"' but must be of type 'bool'");
		}
		
	}
	
	@Check
	public void checkGuarantee(GuaranteeStatement guar){
		
		if(guar.getExpr() == null)
			return;
		
		Classifier comp = guar.getContainingClassifier();
		
		if(!(comp instanceof ComponentType)){
			error(guar, "Guarantee statements are only allowed in component types");
		}
		
		AgreeType exprType = getAgreeType(guar.getExpr());
	
		if(!exprType.matches(boolType)){
			error(guar, "Expression for guarantee statement is of type '"
					+exprType.toString()
					+"' but must be of type 'bool'");
		}
		
	}
	
	@Check
	public void checkUnaryExpr(UnaryExpr unaryExpr){
		
		AgreeType typeRight = getAgreeType(unaryExpr.getExpr());
		String op = unaryExpr.getOp();
		
		switch(op){
		case "-":
			if(!typeRight.matches(intType) && !typeRight.matches(realType)){
				error(unaryExpr, "right side of unary expression '"+op
					+"' is of type '"+typeRight.toString()+"' but must be of type"
					+" 'int' or 'real'");
			}
			break;
		case "not":
			if(!typeRight.matches(boolType)){
				error(unaryExpr, "right side of unary expression '"+op
					+"' is of type '"+typeRight.toString()+"' but must be of type"
					+" 'bool'");
			}
			break;
		default:
			assert(false);
		}
		
	}
	
	
	private AgreeType getAgreeType(UnaryExpr unaryExpr){
		
		AgreeType typeRight = getAgreeType(unaryExpr.getExpr());
		return typeRight;
	}
	
	private AgreeType getAgreeType(NextExpr nextExpr){
		
		return getAgreeType(nextExpr.getExpr());
	}

	
	private AgreeType getAgreeType(NestedDotID nestDotIdExpr){
		
		while(nestDotIdExpr.getSubName() != null)
			nestDotIdExpr = nestDotIdExpr.getSubName();
		
		return getAgreeType(nestDotIdExpr.getName());
	}
	
	
	private AgreeType getAgreeType(NamedElement namedEl){
			
		if(namedEl instanceof Property){
			Property propVal = (Property)namedEl;
			PropertyType propType = propVal.getPropertyType();

			if (propType instanceof AadlBoolean) {
				return new AgreeType("bool");
			}
			if (propType instanceof AadlString
					|| propType instanceof EnumerationType) {
				return new AgreeType("string");
			}
			if (propType instanceof AadlInteger) {
				return new AgreeType("int");
			}
			if (propType instanceof AadlReal) {
				return new AgreeType("real");
			}
			if (propType instanceof ClassifierType) {
				return new AgreeType("component");
			}

		}

		//this is for checking "Base_Types::Boolean" etc...
		if(namedEl instanceof DataSubcomponent){
			return getAgreeType((DataSubcomponent)namedEl);
		}
		
		if(namedEl instanceof Arg)
			return getAgreeType((Arg)namedEl);
		
		if(namedEl instanceof ClassifierType
			|| namedEl instanceof Subcomponent)
			return new AgreeType("component");
		
		if(namedEl instanceof PropertyStatement){
			return getAgreeType((PropertyStatement)namedEl);
		}
		
		if(namedEl instanceof ConstStatement){
			return getAgreeType((ConstStatement)namedEl);
		}
		
		if(namedEl instanceof EqStatement){
			return getAgreeType((EqStatement)namedEl);
		}
		
		return parseFailType;
	}
	
	
	private AgreeType getAgreeType(DataSubcomponent data){
		
		ComponentClassifier dataClass = data.getAllClassifier();
		assert(dataClass instanceof DataType);
		DataType dataType = (DataType)dataClass;

		do{	
			String fullName = dataClass.getQualifiedName();
			
			switch(fullName){
			case "Base_Types::Boolean":
				return new AgreeType("bool");
			case "Base_Types::Integer":
				return new AgreeType("int");
			case "Base_Types::Float":
				return new AgreeType("real");
			}
			dataClass = dataType.getExtended();
			
		}while(dataClass != null);
		
		return new AgreeType("uninterpreted data");
	}
	
	@Check
	public void checkPropertyStatement(PropertyStatement propStat){
		
		if(propStat.getName() == null)
			return;
		
		if(propStat.getExpr() == null)
			return;
		
		AgreeType exprType = getAgreeType(propStat.getExpr());
		
		if(!exprType.matches(boolType))
			error(propStat, "Property statement '"+propStat.getName()+"' is of type '"
				+exprType.toString()+"' but must be of type 'bool'");
		
	}
	
	
	private AgreeType getAgreeType(PropertyStatement propStat){
		if(propStat.getExpr() == null)
			return parseFailType;
		
		return getAgreeType(propStat.getExpr());
	}
	
	@Check
	public void checkConstStatement(ConstStatement constStat){
		
		if(constStat.getExpr() == null)
			return;
		
		AgreeType assumedType = new AgreeType(constStat.getType().getName());
		AgreeType actualType = getAgreeType(constStat.getExpr());
		
		if(!assumedType.matches(actualType)){
			error(constStat, "The assumed type of constant statement '"+constStat.getName()
				+"' is of type '"+assumedType.toString()+"' but the actual type is '"
				+actualType.toString()+"'");
		}
		
	}

	private AgreeType getAgreeType(ConstStatement constStat){
		if(constStat.getType() == null)
			return parseFailType;
		
		return new AgreeType(constStat.getType().getName());
	}
	
	private void checkMultiAssignEq(EObject src, List<Arg> lhsArgs, Expr rhsExpr) {
	  List<AgreeType> agreeLhsTypes = new ArrayList<AgreeType>();
	  List<AgreeType> agreeRhsTypes = new ArrayList<AgreeType>();
	  for (Arg lhsArg: lhsArgs) {
	    agreeLhsTypes.add(getAgreeType(lhsArg));
	  }
	  if (rhsExpr instanceof FnCallExpr && 
	      ((FnCallExpr)rhsExpr).getFn() instanceof NodeDefExpr) {
	    NodeDefExpr nodeDef = (NodeDefExpr)((FnCallExpr)rhsExpr).getFn(); 
	    for (Arg var: nodeDef.getRets()) {
	      agreeRhsTypes.add(new AgreeType(var.getType().getName()));
	    }
	  }
	  else {
	    agreeRhsTypes.add(getAgreeType(rhsExpr));
	  }

	  if (agreeLhsTypes.size() != agreeRhsTypes.size()) {
      error(src, "The number of assigned variables on the left side of eq " + 
          "does not match the number of values returned by the right side.");
      return;
	  }
    for(int i = 0; i < agreeLhsTypes.size(); i++) {
      AgreeType callType = agreeLhsTypes.get(i);
      AgreeType defType = agreeRhsTypes.get(i);

      if(!callType.matches(defType)){
        error(src, "The variable '"+lhsArgs.get(i).getName()+ "' on the left side of equation "
        +"is of type '"+callType.toString()+"' but must be of type '"
            +defType.toString()+"'");
      }
    }
}
	
	@Check
	public void checkEqStatement(EqStatement eqStat){
		if(eqStat.getExpr() == null)
			return;
		checkMultiAssignEq(eqStat, eqStat.getArgs(), eqStat.getExpr());
	}
	
	
	@Check
	public void checkNodeEq(NodeEq nodeEq) {
	  if (nodeEq.getExpr() == null) 
	    return;
	  List<Arg> lhsArgs = nodeEq.getNames(); 
	  if (lhsArgs == null)
	    return ;
	  checkMultiAssignEq(nodeEq, lhsArgs, nodeEq.getExpr()); 
	}
	
	@Check
	public void checkNodeDef(NodeDefExpr nodeDefExpr) {
	  Map<Arg, Integer> assignMap = new HashMap<Arg, Integer>();
	  for (Arg arg: nodeDefExpr.getRets()) {
	    assignMap.put(arg, 0);
	  }
	  for (Arg arg: nodeDefExpr.getNodeBody().getLocs()) {
	    assignMap.put(arg,  0);
	  }
	  
	  for (NodeEq eq: nodeDefExpr.getNodeBody().getEqs()) {
	    for (Arg arg: eq.getNames()) {
	      Integer value = assignMap.get(arg);
	      if (value == null) {
	        error("Equation attempting to assign: '" + arg.getName() + 
              "', which is not an l-value (assignable value) within the node.");
	        return;
	      }
	      else {
	        assignMap.put(arg, value + 1);
	      }
	    }
	  }
    for (Map.Entry<Arg, Integer> elem : assignMap.entrySet()) {
      if (elem.getValue() == 0) {
        error("Variable '" + elem.getKey().getName()
            + "' is never assigned by an equation in node '"
            + nodeDefExpr.getName() + "'.");
        return;
      } else if (elem.getValue() > 1) {
        error("Variable '" + elem.getKey().getName()
            + "' is assigned multiple times in node '" + nodeDefExpr.getName()
            + "'.");
      }
    }
	}
	
	@Check
	public void checkGetPropertyExpr(GetPropertyExpr getPropExpr){
		AgreeType compType = getAgreeType(getPropExpr.getComponent());
		//AgreeType propType = getAgreeType(propExpr.getName());
		Expr propExpr = getPropExpr.getName();
		
		if(!compType.equals("component"))
			error(getPropExpr, "the first argument of the 'Get_Property' function"
				+ " is of type '"+compType.toString()+"' but must be of some"
				+ " aadl component type.");
		
		if(!(propExpr instanceof IdExpr)){
			error(getPropExpr, "the second argument of the 'Get_Property' function"
				+ "must be some aadl property");
			return;
		}
		
		NamedElement idVal = ((IdExpr)propExpr).getId();
		
		if(!(idVal instanceof Property)){
			error(getPropExpr, "the second argument of the 'Get_Property' function"
					+ "must be some aadl property");
		}
	}
	
	
	private AgreeType getAgreeType(GetPropertyExpr getPropExpr){
	
		if(getPropExpr.getName() == null)
			return parseFailType;
		
		return getAgreeType(getPropExpr.getName());
	}
	
	@Check
	public void checkPrevExpr(PrevExpr prevExpr){
		
		AgreeType delayType = getAgreeType(prevExpr.getDelay());
		AgreeType initType = getAgreeType(prevExpr.getInit());
		
		if(!delayType.matches(initType)){
			error(prevExpr, "The first and second arguments of the 'prev' function are of type '"
				+delayType.toString()+"' and '"+initType.toString()+"'. These"
				+" Types do not match");
		}
	}
	
	private AgreeType getAgreeType(PrevExpr prevExpr){
		return getAgreeType(prevExpr.getDelay());
	}
	
	
	public List<AgreeType> typesFromArgs(EList<Arg> args) {
    ArrayList<AgreeType> list = new ArrayList<AgreeType>();
	  for(Arg arg : args)
      list.add(getAgreeType(arg));
	  return list;
	}

	public void checkInputsVsActuals(FnCallExpr fnCall) {
    CallDef callDef = fnCall.getFn();
    
    if(callDef == null)
      return;

    List<AgreeType> inDefTypes;
    String callName;
    
    // extract in/out arguments
    if (callDef instanceof FnDefExpr) {
      FnDefExpr fnDef = (FnDefExpr)callDef;
      inDefTypes = typesFromArgs(fnDef.getArgs());
      callName = fnDef.getName();
    } else if (callDef instanceof NodeDefExpr) {
      NodeDefExpr nodeDef = (NodeDefExpr)callDef;
      inDefTypes = typesFromArgs(nodeDef.getArgs());
      callName = nodeDef.getName();
    } else {
      error(fnCall, "Node or Function definition name expected.");
      return;
    }
    
    // extract args.
    List<AgreeType> argCallTypes = new ArrayList<AgreeType>();
    for(Expr argExpr : fnCall.getArgs()){
      argCallTypes.add(getAgreeType(argExpr));
    }

    if(inDefTypes.size() != argCallTypes.size()){
      error(fnCall, "Function definition '"+ callName
          +"' requires "+inDefTypes.size()+" arguments, but this"
          +" function call provides "+argCallTypes.size()+" arguments");
      return;
    }

    for(int i = 0; i < inDefTypes.size(); i++){

      AgreeType callType = argCallTypes.get(i);
      AgreeType defType = inDefTypes.get(i);

      if(!callType.matches(defType)){
        error(fnCall, "Argument "+i+ " of function call '"+ callName
            +"' is of type '"+callType.toString()+"' but must be of type '"
            +defType.toString()+"'");
      }
    }	  
	}
	
	@Check
	public void checkFnCallExpr(FnCallExpr fnCall){
	  checkInputsVsActuals(fnCall);
	}

	
	private AgreeType getAgreeType(FnCallExpr fnCall){
		
	  // TODO: Examine type system in more detail 
	  // TODO: Fix to make support type lists.
		CallDef callDef = fnCall.getFn();
    // extract in/out arguments
    if(callDef == null)
      return parseFailType;

		if (callDef instanceof FnDefExpr) {
      FnDefExpr fnDef = (FnDefExpr)callDef;
      return new AgreeType(fnDef.getType().getName());
    } else if (callDef instanceof NodeDefExpr) {
      NodeDefExpr nodeDef = (NodeDefExpr)callDef;
      List<AgreeType> outDefTypes = typesFromArgs(nodeDef.getRets());
      if (outDefTypes.size() == 1) {
        return outDefTypes.get(0);
      }
      else {
        error(fnCall, "Nodes embedded in expressions must have exactly one return value." 
              +"  Node " + nodeDef.getName() + " contains " + outDefTypes.size() + " return values");
        return parseFailType;
      }
    } else {
      error(fnCall, "Node or Function definition name expected.");
      return parseFailType;
    }
	}

	@Check
	public void checkIfThenElseExpr(IfThenElseExpr expr){
		
		AgreeType condType = getAgreeType(expr.getA());
		AgreeType thenType = getAgreeType(expr.getB());
		AgreeType elseType = getAgreeType(expr.getC());
		
		if(!condType.matches(boolType)){
			error(expr, "The condition of the if statement is of type '"
				+condType.toString()+"' but must be of type 'bool'");
		}
		
		if(!thenType.matches(elseType)){
			error(expr, "The 'then' and 'else' expressions are of type '"
				+thenType.toString()+"' and '"+elseType.toString()+"'. These"
				+" Types do not match");
		}
	}
	
	private AgreeType getAgreeType(IfThenElseExpr expr){
		
		AgreeType thenType = getAgreeType(expr.getB());
		return thenType;
	}
	
	@Check
	public void checkBinaryExpr(BinaryExpr binExpr){
		
		AgreeType typeLeft = getAgreeType(binExpr.getLeft());
		AgreeType typeRight = getAgreeType(binExpr.getRight());
		String op = binExpr.getOp();
		
		switch(op){
		case "->":
			if(!typeLeft.matches(typeRight)){
				error(binExpr, "left and right sides of binary expression '"+op
					+"' are of type '"+typeLeft.toString()+"' and '"+typeRight.toString()
					+"', but must be of the same type");
			}
			if(!typeLeft.isPrimType()){
				error(binExpr, "left side of binary expression '"+op
					+"' is of type '"+typeLeft.toString()+"' but must be of type"
					+"'int', 'real', or 'bool'");
			}
			if(!typeRight.isPrimType()){
				error(binExpr, "right side of binary expression '"+op
					+"' is of type '"+typeRight.toString()+"' but must be of type"
					+"'int', 'real', or 'bool'");
			}
			
			return;
		case "=>":
		case "<=>":
		case "and":
		case "or":
			if(!typeLeft.matches(boolType)){
				error(binExpr, "left side of binary expression '"+op
					+"' is of type '"+typeLeft.toString()+"' but must be of "
					+"type '"+boolType.toString()+"'");
			}
			if(!typeRight.matches(boolType)){
				error(binExpr, "right side of binary expression '"+op
					+"' is of type '"+typeRight.toString()+"' but must be of"
					+" type '"+boolType.toString()+"'");
			}
			return;
		case "<>":
		case "!=":
			if(!typeLeft.matches(typeRight)){
				error(binExpr, "left and right sides of binary expression '"+op
					+"' are of type '"+typeLeft.toString()+"' and '"+typeRight.toString()
					+"', but must be of the same type");
			}
			return;
		case "<":
		case "<=":
		case ">":
		case ">=":
		case "=":
		case "+":
		case "-":
		case "*":
		case "/":
		case "mod":
		case "div":
			if(!typeLeft.matches(typeRight)){
				error(binExpr, "left and right sides of binary expression '"+op
					+"' are of type '"+typeLeft.toString()+"' and '"+typeRight.toString()
					+"', but must be of the same type");
			}
			if(!typeLeft.matches(intType) && !typeLeft.matches(realType)){
				error(binExpr, "left side of binary expression '"+op
					+"' is of type '"+typeLeft.toString()+"' but must be of type"
					+"'int' or 'real'");
			}
			if(!typeRight.matches(intType) && !typeRight.matches(realType)){
				error(binExpr, "right side of binary expression '"+op
					+"' is of type '"+typeRight.toString()+"' but must be of type"
					+"'int' or 'real'");
			}
			return;
		default:
			assert(false);
		}
	}
	
	private AgreeType getAgreeType(BinaryExpr binExpr) {
		
		AgreeType typeLeft = getAgreeType(binExpr.getLeft());
		String op = binExpr.getOp();
		
		switch(op){
		case "->":
			return typeLeft;
		case "=>":
		case "<=>":
		case "and":
		case "or":
			return boolType;
		case "<>":
		case "!=":
			return boolType;
		case "<":
		case "<=":
		case ">":
		case ">=":
		case "=":
			return boolType;
		case "+":
		case "-":
		case "*":
		case "/":
		case "mod":
		case "div":
			return typeLeft;
		default:
			assert(false);
		}
		
		assert(false);
		return null;
	}
	
  private Boolean hasCallDefParent(Element e) {
    while (e != null) {
      if (e instanceof CallDef) {
        return true;
      }
      e = e.getOwner();
    }
    return false;
  }
  

	// TODO: Don't we need more validation here?  What if the Id of the IdExpr
	
	private void checkScope(Expr expr, NamedElement id) {
    if (hasCallDefParent(expr)) {
      if (!hasCallDefParent(id) && 
          !(id instanceof ConstStatement)) {
        error("Unknown identifier Id: '"+id 
            +"' (Note that nodes can only refer to inputs, outputs, and local variables and global constants).");
      }
    }
	}
	
	@Check
	public void checkIdExpr(IdExpr idExpr) {
	  if (idExpr == null)
	    return;
	  
    // Scope check for nodes / functions
    NamedElement id = idExpr.getId();
    checkScope(idExpr, id);
	}
	
	@Check
	public void checkNestIdExpr(NestIdExpr idExpr) {
	  if (idExpr == null) 
	    return;
	  
    NamedElement id = idExpr.getId().getName();
    checkScope(idExpr, id);
	}
	
	private AgreeType getAgreeType(IdExpr idExpr){
		
    NamedElement id = idExpr.getId();
    return getAgreeType(id);
	}
	
	
private AgreeType getAgreeType(Expr expr) {
		
		if(expr == null)
			return parseFailType;
		
		if(expr instanceof BinaryExpr)
			return getAgreeType((BinaryExpr)expr);
		
		if(expr instanceof FnCallExpr)
			return getAgreeType((FnCallExpr)expr);
		
		if(expr instanceof IfThenElseExpr)
			return getAgreeType((IfThenElseExpr)expr);
		
		if(expr instanceof PrevExpr)
			return getAgreeType((PrevExpr)expr);
		
		if(expr instanceof NextExpr)
			return getAgreeType((NextExpr)expr);
		
		if(expr instanceof GetPropertyExpr)
			return getAgreeType((GetPropertyExpr)expr);
		
		if(expr instanceof NestedDotID)
			return getAgreeType((NestedDotID)expr);
		
		if(expr instanceof UnaryExpr)
			return getAgreeType((UnaryExpr)expr);
		
		if(expr instanceof IdExpr)
			return getAgreeType((IdExpr)expr);
		
		if(expr instanceof IntLitExpr)
			return new AgreeType("int");
		
		if(expr instanceof RealLitExpr)
			return new AgreeType("real");
		
		if(expr instanceof BoolLitExpr)
			return new AgreeType("bool");
		
		if(expr instanceof NestIdExpr)
			return getAgreeType(((NestIdExpr)expr).getId());
		
		if(expr instanceof ThisExpr)
			return new AgreeType("component");
		
		if(expr instanceof PreExpr)
			return getAgreeType(((PreExpr)expr).getExpr());
		
		assert(false);
		return null;
	}
	
	
}
