grammar com.rockwellcollins.atc.agree.Agree with org.osate.xtext.aadl2.properties.Properties

generate agree "http://www.rockwellcollins.com/atc/agree/Agree"

import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2

NamedElement returns aadl2::NamedElement:
	Arg
|	Type
|	FnDefExpr
|   NodeDefExpr
|   PropertyStatement
|   ConstStatement
|   EqStatement

;


Element returns aadl2::Element:
	Expr
|   AgreeContract
|   SpecStatement
|   NodeEq
|   NodeBodyExpr
;

AnnexLibrary returns aadl2::AnnexLibrary:
	AgreeLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
	AgreeSubclause
;

AgreeLibrary:
{AgreeContractLibrary} contract=AgreeContract
;

AgreeSubclause:
{AgreeContractSubclause} contract=AgreeContract
;


AgreeContract returns Contract:
	{AgreeContract} (specs+=SpecStatement)+
;

SpecStatement:
	{AssumeStatement}     'assume' str=STRING ':' expr=Expr ';'
|   {GuaranteeStatement}  'guarantee' str=STRING ':' expr=Expr ';'
|   {AssertStatement}     'assert' expr=Expr ';'
|   {ParamStatement}      'parameter' expr=Expr ':' type=Type ';'
|   {LemmaStatement}      'lemma' str=STRING ':' expr=Expr ';'
|   PropertyStatement
|   ConstStatement
|   EqStatement
|   FnDefExpr
|   NodeDefExpr
	;

CallDef returns CallDef:
	FnDefExpr
|   NodeDefExpr
    ;

PropertyStatement:
	'property' name=ID '=' expr=Expr ';'
;

ConstStatement:
	'const' name=ID ':' type=Type '=' expr=Expr ';'
;

EqStatement:
	'eq' (args+=Arg (',' args+=Arg)*) '=' expr=Expr ';'
;

FnDefExpr:
	 'fun' name=ID '(' args+=Arg (',' args+=Arg)* ')' ':' type=Type '=' expr=Expr ';'
;

NodeDefExpr:
	'node' name=ID '(' args+=Arg (',' args+=Arg)* ')' 'returns'
				   '(' rets+=Arg (',' rets+=Arg)* ')' ';'
	nodeBody=NodeBodyExpr
;

NodeBodyExpr: 
	('var' (locs+=Arg ';')+ )? 
	'let' 
		(eqs+=NodeEq)+
	'tel' ';'  	
;

NodeEq: 
	{NodeEq}	(names+=[Arg] (',' names+=[Arg])* '=' expr=Expr ';')
|   {NodeLemma} 'lemma' str=STRING ':' expr=Expr ';'
;

Arg returns Arg:
	name=ID ':' type=Type
;

Type:
	name=('real' | 'bool' | 'int')
;

Expr returns Expr:
	ArrowExpr
;

ArrowExpr returns Expr:
	ImpliesExpr (=>({BinaryExpr.left=current} op='->') right=ImpliesExpr)?
;


ImpliesExpr returns Expr:
	EquivExpr (=>({BinaryExpr.left=current} op='=>') right=EquivExpr)?
;


EquivExpr returns Expr:
	AndExpr (=>({BinaryExpr.left=current} op='<=>') right=AndExpr)?
;

AndExpr returns Expr:
	OrExpr (=>({BinaryExpr.left=current} op='and') right=OrExpr)*
;

OrExpr returns Expr:
	RelateExpr (=>({BinaryExpr.left=current} op='or') right=RelateExpr)*
;

RelateOp:
	'<' | '<=' | '>' | '>=' | '=' | '<>' | '!='
;

RelateExpr returns Expr:
	AddSubExpr (=>({BinaryExpr.left=current} op=RelateOp) right=AddSubExpr)?
;

AddSubExpr returns Expr:
	MultDivExpr (=>({BinaryExpr.left=current} op=('+'|'-')) right=MultDivExpr)*
;

MultDivExpr returns Expr:
	UnaryExpr (=>({BinaryExpr.left=current} op=('*'|'/'|'mod'|'div')) right=UnaryExpr)*
;

UnaryExpr returns Expr:
	{UnaryExpr} op=('-'|'not') expr=UnaryExpr
|	IfThenElseExpr
;

IfThenElseExpr returns Expr:
    {IfThenElseExpr}'if' a=Expr 'then' b=Expr 'else' c=Expr
|   PreDefFnExpr
;

PreDefFnExpr returns Expr:
	{PrevExpr} 'prev' '(' delay=Expr ',' init=Expr ')'
|	{NextExpr} 'next' '(' expr=Expr ')'
|   {GetPropertyExpr} 'Get_Property' '(' component=Expr ',' name=Expr ')'
| TermExpr
;

PreDefFnNames:
	'prev'
|	'next'
|	'Get_Property'
;


TermExpr returns Expr:
	{IdExpr} id=[aadl2::NamedElement | QID ]
|   NestedDotID ({FnCallExpr.fn=current} '(' args+=Expr (',' args+=Expr)* ')')?
|	{IntLitExpr} val=INTEGER_LIT
|	{PreExpr} 'pre' '(' expr=Expr ')'
|   {RealLitExpr} val=REAL_LIT
|   {BoolLitExpr} val=BooleanLiteral
|   {ThisExpr} 'this'
| '(' Expr ')'
;


NestedDotID:
	name =[aadl2::NamedElement | ID] ('.' subName=NestedDotID)?
;

QID:
	ID '::' ID
;
