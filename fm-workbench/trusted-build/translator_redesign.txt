I have three axes of specialization:
	Communication protocol
	OS
	Hardware
	
Hardware is small potatoes; it makes a handful of changes to the config files / build scripts.

OS is huge - it affects the generated code at the macro and micro level.  Worse, some things, such as comm protocols, span OSes.

Communication protocol is also big - it would be nice to split based on comm type.

Finally, if we want to support comms across bindings, esp. across buses, this may span OSes.

Open question: how do we extract binding information from instance model?

Owner of a thread is a package section, not a process.  Owner of a package section is a package.


AADL bindings 
processor Real_Time
  features
    BA1: requires bus access Marine.Standard;
end Real_Time;

processor implementation Real_Time.one_GHz
end Real_Time.one_GHz;

...
properties
  Allowed_Processor_Binding => (reference(RT_1GHz))
    applies to speed_control.speed_control_laws;
  Allowed_Processor_Binding => (reference(RT_1GHz))
    applies to speed_control.scale_speed_data;
  Actual_Memory_Binding => (reference(Stand_Memory))
    applies to speed_control;
	
	

Currently, for the C code generation, the template files are split by OS.

For C code generation for (say) CAmkES, the following files are involved:

CommonComponentC.stg 
CAmkESComponentC.stg

All of the <ComponentType>Name.java files for threads, ports, connections, etc.

...and of course these are created from the AST classes that represent the "abstract" thing.

Issue: dealing with signals (not that we do this now anyway)

So suppose that we had Factories for constructing the ASTs.  What would they look like?

Top-level classes by AADL element?
	ThreadFactory
		CAmkESThreadFactory
		eChronosThreadFactory
		VxWorksThreadFactory
	PortFactory
	ConnectionFactory

Or, for now, just 

TrustedBuildAstFactory		<-- Each one has a static "register properties" method.
CAmkESAstFactory			
eChronosAstFactory
VxWorksAstFactory

Then we have the AST classes

Connections (always instances):
	EventDataPC
		EventDataLPC
			EventDataLPCeChronos
			EventDataLPCVxWorks
		EventDataRPCCAmkES			
	EventSignal
		EventSignalCAmkES
	EventDataSharedMemSignal	
	DataPC
		DataRPCCAmkES
		DataLPC
			DataLPCVxWorks
			DataLPCeChronos		
	DataMailbox
		DataShMem

Ports vs. Port Instances:


Some strange things: 
	I'm not sure how alarm and light factor into the model.
	In addition, alarm and light are both defined exactly the same.
	Finally, hysteresis doesn't mean hysteresis in the traditional sense.
	Why not use the altitude switch?	
	Pairwise 
	
	Not CNF - NNF.
		
0000817226	
484-841-0200




	

/*********************************************************************
 * OS-specific naming functions required by this file:
 *   incomingPortWriterName
 *   outgoingPortWriterName
 *   incomingActiveThreadDispatchName
 *   outgoingActiveThreadDispatchName
 *   incomingUserEntrypoingCallerName
 *   outgoingUserEntrypointCallerName
 *      portLockStmt
 *   portUnlockStmt
 *   portDispatcherLock
 *   portDispatcherUnlock
 *   dispatcherMainInitializeLockStmt
 *   dispatcherMainLockWaitStmt
 *   dispatcherMainLockReleaseStmt
 *   osSpecificIncludeFiles
 *   osSpecificIrqDispatcher
 *   osSpecificThreadInitializer
 *   osSpecificThreadEntrypoint
 *   osSpecificComponentLocalCallerFunction
 *   osSpecificAssert
 *   aadlInputToExternalInput  <== currently aadlInputToCamkesInput
 *
 * Dummy declarations are provided by CommonOSSpecificNames.
 * These must be overridden by redefinition (see CamkesComponentC.stg
 * for an example).  For more information on template overriding,
 * please see: www.stringtemplate.org.
 *********************************************************************/
