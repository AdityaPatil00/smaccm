package edu.umn.cs.crisys.smaccm.aadl2rtos.printing;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.osate.aadl2.DirectionType;
import org.osate.aadl2.PortCategory;
import org.osate.aadl2.impl.PortImpl;
import org.osate.aadl2.impl.ThreadTypeImpl;
import org.osate.aadl2.instance.ConnectionInstance;
import edu.umn.cs.crisys.smaccm.aadl2rtos.Logger;
import edu.umn.cs.crisys.smaccm.aadl2rtos.Aadl2RtosException;
import edu.umn.cs.crisys.smaccm.aadl2rtos.Pair;
import edu.umn.cs.crisys.smaccm.aadl2rtos.Util;
import edu.umn.cs.crisys.smaccm.aadl2rtos.ast.IdType;
import edu.umn.cs.crisys.smaccm.aadl2rtos.ast.Model;
import edu.umn.cs.crisys.smaccm.aadl2rtos.ast.PortImplWrapper;
import edu.umn.cs.crisys.smaccm.aadl2rtos.ast.ThreadWrapper;
import edu.umn.cs.crisys.smaccm.aadl2rtos.ast.Type;
import edu.umn.cs.crisys.smaccm.topsort.CyclicException;
import edu.umn.cs.crisys.smaccm.topsort.TopologicalSort;

// TODO: need to discuss where to place .c / .h files for User-provided thread functions

public class BrtosEntrypointSkeletonGenerator {
    private Model model;
    private Logger log;
    private Map<ThreadTypeImpl, Set<Pair<PortImpl, PortImpl>>> threadSourcePorts;

    File CFile;
    File HFile;

    List<PortImplWrapper> events;

    // so write threadName_write_portName for each port.

    public BrtosEntrypointSkeletonGenerator(Logger log, Model model, File dir) {
        super();
        this.log = log;
        this.model = model;

        File genDir = new File(dir, "gen");
        String name = Util.normalizeAadlName(model.sysinst.getName());
        genDir.mkdirs();
        CFile = new File(genDir, name + ".c");
        HFile = new File(genDir, name + ".h");

        threadSourcePorts = new HashMap<ThreadTypeImpl, Set<Pair<PortImpl, PortImpl>>>();

        // Define signal set from event ports
        // write implementations for event ports set the signals
        // main tasking threads wait for signal set
        // and dispatch to appropriate entrypoint

        defineSignalSet();

        defineThreadSourcePorts();

    };

    public File getHFile() {
        return HFile;
    }

    public File getCFile() {
        return CFile;
    }

    public void writeFileInfo(BufferedWriter out, File f) throws IOException {
        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        Calendar cal = Calendar.getInstance();

        writeComment(out, "   File: " + f.getCanonicalPath() + "\n" + "   Created on: "
                + dateFormat.format(cal.getTime()) + "\n"
                + "   using Dulcimer AADL system build tool suite \n\n"
                + "   ***AUTOGENERATED CODE: DO NOT MODIFY***\n");

    }

    public void writeComment(BufferedWriter out, String comment) throws IOException {
        out.append("/**************************************************************************\n"
                + comment
                + " **************************************************************************/\n");
    }

    public void writeType(BufferedWriter out, IdType ty) throws IOException {
        // get the underlying type for the id. If it is a structured type,
        // (which I expect) then emit a 'typedef struct'. Else emit a typedef.

        StringBuffer typeName = new StringBuffer();
        typeName.append("typedef ");
        typeName.append(ty.getTypeRef().toString());
        typeName.append(" ");
        typeName.append(ty.getTypeId());
        typeName.append("; \n");
        // log.status("Printing type: " + typeName.toString());
        out.append(typeName.toString());
    }

    public void writeTypes(BufferedWriter out) throws IOException {
        try {
            // First we need to get all of the "top-level" types described as
            // ID-types, then
            // we can sort them topologically, then emit them.
            Set<Entry<String, Type>> entrySet = model.astTypes.entrySet();
            List<Type> idTypes = new ArrayList<Type>();
            for (Entry<String, Type> e : entrySet) {
                idTypes.add(new IdType(e.getKey(), e.getValue()));
            }
            List<Type> sortedTypes = TopologicalSort.performTopologicalSort(idTypes);

            for (Type t : sortedTypes) {
                if (t instanceof IdType) {
                    writeType(out, (IdType) t);
                }
            }
        } catch (CyclicException e) {
            throw new Aadl2RtosException(
                    "Error writing datatypes to C header: cyclic reference between types.");
        }
    }

    private void writeEntrypoints(BufferedWriter out) throws IOException {

        List<ThreadWrapper> taskThreads = model.getTaskThreads();
        for (ThreadWrapper tw : taskThreads) {
            out.append("	void " + tw.getGeneratedEntrypoint() + "(); \n\n");
        }
    }

    // TODO: mention that we do not currently support IN/OUT ports
    private void writeWriterDecls(BufferedWriter out) throws IOException {
        List<ThreadWrapper> allThreads = model.getTaskThreads();
        allThreads.addAll(model.getISRThreads());

        for (ThreadWrapper tw : allThreads) {
            for (PortImplWrapper dpiw : tw.getPorts()) {
                if (dpiw.getDirection() == DirectionType.IN_OUT) {
                    throw new Aadl2RtosException("Currently, IN_OUT ports are not supported!\n");
                } else if (dpiw.getDirection() == DirectionType.OUT) {
                    // TODO: use the user-def property for the function
                    // declaration.
                    String fnName = tw.getName() + "_write_" + dpiw.getName();
                    out.append("   void " + fnName);
                    if (dpiw.getCategory() == PortCategory.EVENT) {
                        out.append("();\n\n");
                    } else {
                        out.append("(arg: " + dpiw.getType() + ");\n\n");
                    }
                }
            }
        }
    }

    private String dataportArgs(List<PortImplWrapper> dpl) {
        StringBuilder out = new StringBuilder();
        Iterator<PortImplWrapper> iterator = dpl.iterator();
        while (iterator.hasNext()) {
            PortImplWrapper arg = iterator.next();
            out.append(arg.getType().toString());
            out.append(" ");
            out.append(arg.getName());
            if (iterator.hasNext()) {
                out.append(", ");
            }
        }
        return out.toString();
    }

    private String udeEntrypointDecl(String fnName, List<PortImplWrapper> args) {
        return "   void " + fnName
                + "( /* TODO: correctly handle by-ref/by-val distinction for C types... "
                + dataportArgs(args) + "*/ ); \n\n";
    }

    // TODO: well-formedness check on model for INOUT ports.
    private void writeThreadUdeDecls(BufferedWriter out, ThreadWrapper tw) throws IOException {
        List<PortImplWrapper> dataList = tw.getInDataPorts();

        // user-level initializer for thread.
        String initFn = tw.getInitializeEntrypointOpt();
        if (initFn != null) {
            out.append("   void " + initFn + "();\n\n");
        }

        // main user-level entrypoint for thread.
        String computeFn = tw.getComputeEntrypointOpt();
        if (computeFn != null) {
            out.append(udeEntrypointDecl(computeFn, dataList));
        }

        // event entrypoints for thread.
        for (PortImplWrapper dpiw : tw.getInEventPorts()) {
            computeFn = dpiw.getComputeEntrypointOpt();
            if (computeFn != null) {
                List<PortImplWrapper> args;
                if (dpiw.getCategory() == PortCategory.EVENT_DATA) {
                    args = new ArrayList<PortImplWrapper>();
                    args.add(dpiw);
                    args.addAll(dataList);
                } else {
                    args = dataList;
                }
                out.append(udeEntrypointDecl(computeFn, args));
            }
        }

        // Now we're done!
    }

    // For each thread;
    // record the list of data ports
    // TODO: For each event port, how do we want the interface?
    // Perhaps it does not really exist.
    private void writeUdeDecls(BufferedWriter out) throws IOException {
        for (ThreadWrapper tw : model.getAllThreads()) {
            writeThreadUdeDecls(out, tw);
        }
    }

    private void writeHeader(BufferedWriter out) throws IOException {
        writeComment(out, Util.DARPA_License);
        out.append("\n\n");
        writeFileInfo(out, HFile);
        out.append("\n\n");
        writeComment(
                out,
                "   This header file contains the datatypes used for communications between \n"
                        + "   AADL components as defined in the system implementation "
                        + model.sysinst.getName()
                        + ".\n"
                        + "   It also contains the function declarations for: \n"
                        + "      1.) The task-level entrypoint functions for each task, \n"
                        + "      2.) The user-callable writer functions for each task, and \n"
                        + "      3.) The expected interface for each of the user-defined sub-entrypoints\n\n");
        out.append("\n\n");

        writeComment(out, "   AADL TYPE DECLARATIONS USED BY AT LEAST ONE PORT \n");

        writeTypes(out);

        out.append("\n\n");

        writeComment(out, "   TASK-LEVEL ENTRYPOINT FUNCTIONS \n");

        writeEntrypoints(out);

        writeComment(out, "   WRITER FUNCTIONS FOR USER-LEVEL ENTRYPOINTS \n");

        writeWriterDecls(out);

        writeComment(out, "   INTERFACE FOR USER-DEFINED ENTRYPOINTS \n");

        writeUdeDecls(out);

        writeComment(out, "   End of autogenerated file: " + HFile.toString() + "\n");
    }

    private void defineThreadSourcePorts() {
        try {
            for (ConnectionInstance ci : model.connectionInstances) {
                PortImpl destPort = Util.getPortImplFromConnectionInstanceEnd(ci.getDestination());
                ThreadTypeImpl destThread = Util.getThreadFromPortImpl(destPort);
                if (!threadSourcePorts.containsKey(destThread)) {
                    threadSourcePorts.put(destThread, new HashSet<Pair<PortImpl, PortImpl>>());
                }
                PortImpl sourcePort = Util.getPortImplFromConnectionInstanceEnd(ci.getSource());
                threadSourcePorts.get(destThread).add(
                        new Pair<PortImpl, PortImpl>(sourcePort, destPort));
            }
        } catch (Exception e) {
            log.error("Error casting connection instance to thread and portImpl.\n");
            throw new Aadl2RtosException(e.toString());
        }

        /*
         * for (ThreadTypeImpl tti : threadSourcePorts.keySet()) {
         * log.status("key: " + tti.toString()) ; for (Pair<PortImpl,PortImpl>
         * ports : threadSourcePorts.get(tti)) { log.status("   value: " +
         * ports.first.toString() + ", " + ports.second.toString()); } }
         * log.status("All done");
         */
    }

    private void defineSignalSet() {
        events = new ArrayList<PortImplWrapper>();
        for (ThreadWrapper tw : model.getAllThreads()) {
            events.addAll(tw.getOutEventPorts());
        }
    }

    public int getSignalSetSize() {
        return events.size();
    }

    public int getSignalForPort(PortImpl p) {
        PortImplWrapper wrap = new PortImplWrapper(model, p);
        return events.indexOf(wrap);
    }

    private String getRtosPrefix() {
        return "rtos_";
    }

    private String rtosFnName(String postfix) {
        return getRtosPrefix() + postfix;
    }

    public List<Pair<PortImplWrapper, PortImplWrapper>> getSourceEventPortsForThread(
            ThreadWrapper tw) {
        List<Pair<PortImplWrapper, PortImplWrapper>> sourceEventPorts = new ArrayList<Pair<PortImplWrapper, PortImplWrapper>>();
        Set<Pair<PortImpl, PortImpl>> ports = threadSourcePorts.get(tw.thread);

        for (Pair<PortImpl, PortImpl> i : ports) {
            PortImplWrapper srcPwi = new PortImplWrapper(model, i.first);
            PortImplWrapper dstPwi = new PortImplWrapper(model, i.second);
            if (dstPwi.getCategory() == PortCategory.EVENT
                    || dstPwi.getCategory() == PortCategory.EVENT_DATA) {
                Pair<PortImplWrapper, PortImplWrapper> p = new Pair<PortImplWrapper, PortImplWrapper>(
                        srcPwi, dstPwi);
                sourceEventPorts.add(p);
            }
        }
        return sourceEventPorts;
    }

    public void writeTopLevelTaskingFunctions(BufferedWriter out) throws IOException {
        String ind = "   ";

        for (ThreadWrapper tw : model.getTaskThreads()) {
            List<Pair<PortImplWrapper, PortImplWrapper>> eventPorts = getSourceEventPortsForThread(tw);

            out.append("void " + tw.getGeneratedEntrypoint() + "() \n");
            out.append("{\n");
            String initFn = tw.getInitializeEntrypointOpt();
            if (initFn != null) {
                out.append(ind + initFn + "();\n");
            }
            out.append(ind + "for (;;) {\n").append(ind + ind + "int current_sig;\n")
                    .append(ind + ind + "current_sig = " + rtosFnName("signal_wait_set("));

            // TODO: make sure no off-by-one errors in positioning.
            Iterator<Pair<PortImplWrapper, PortImplWrapper>> it = eventPorts.iterator();
            while (it.hasNext()) {
                // first is source port.
                PortImplWrapper current = it.next().first;
                int index = getSignalForPort(current.impl);
                out.write(Integer.toHexString(1 << index));
                out.append("/*" + current.getName() + "*/");
                if (it.hasNext()) {
                    out.write(" | ");
                }
                // out.append("(0 /*...signal set goes here...*/); \n");
            }
            out.append("); \n");

            // now figure out which entrypoint to call...
            it = eventPorts.iterator();
            boolean initial = true;

            while (it.hasNext()) {
                // second is destination port.
                Pair<PortImplWrapper, PortImplWrapper> current = it.next();
                PortImplWrapper src = current.first;
                PortImplWrapper dst = current.second;
                out.append(ind + ind + (initial ? "" : "else "));
                out.append("if (current_sig == " + Integer.toString(getSignalForPort(src.impl))
                        + "/*" + src.impl.getName() + "*/" + ") {\n");
                String entry = dst.getComputeEntrypointOpt();
                if (entry != null) {
                    out.append(ind + ind + ind + "/* TODO: set up data and event-data inputs */\n");
                    // TODO: figure out correct arguments
                    out.append(ind + ind + ind + entry + "();\n");
                } else {
                    throw new Aadl2RtosException("No entrypoint found for input port: "
                            + dst.getName());
                }
                out.append(ind + ind + "}\n");
                initial = false;
            }
            out.append(ind + "}\n");
            out.append("}\n");
        }
    }

    // need to work in the other direction: we need to find, from any
    // emitter, the threads with which that that communicates?

    public List<ThreadTypeImpl> getDestinationThreadsForPort(PortImpl pi) {
        List<ThreadTypeImpl> destThreads = new ArrayList<ThreadTypeImpl>();
        for (ConnectionInstance ci : model.connectionInstances) {
            PortImpl sourcePi = Util.getPortImplFromConnectionInstanceEnd(ci.getSource());
            ThreadTypeImpl destThread = Util.getThreadFromPortImpl(Util
                    .getPortImplFromConnectionInstanceEnd(ci.getDestination()));
            if (pi.equals(sourcePi)) {
                destThreads.add(destThread);
            }
        }
        return destThreads;
    }

    public void writeWriters(BufferedWriter out) throws IOException {
        String ind = "   ";

        for (ThreadWrapper tw : model.getAllThreads()) {
            for (PortImplWrapper pi : tw.getOutEventPorts()) {
                List<ThreadTypeImpl> tti = getDestinationThreadsForPort(pi.impl);
                out.append("void " + tw.getName() + "_write_" + pi.getName() + "() {\n");
                for (ThreadTypeImpl destTw : tti) {
                    int signalNumber = getSignalForPort(pi.impl);
                    int threadNumber = model.getThreadTaskIndex(new ThreadWrapper(destTw, model));
                    out.append(ind + rtosFnName("signal_send_set(")
                            + Integer.toString(threadNumber) + "/* " + destTw.getName() + " */ , "
                            + Integer.toString(1 << signalNumber) + "/* " + pi.getName()
                            + " */); \n");
                }
                out.append("}\n\n");
            }
        }
    }

    public void writeSource(BufferedWriter out) throws IOException {

        writeComment(out, Util.DARPA_License);
        out.append("\n\n");
        writeFileInfo(out, CFile);
        out.append("\n\n");
        writeComment(
                out,
                "   This .c file contains the implementations of the communication functions for threads \n"
                        + "   and the top level entrypoint functions for the AADL components as defined in the \n"
                        + "   system implementation " + model.sysinst.getName() + ".\n");
        out.append("\n\n");

        // includes
        out.append("#include <stdbool.h>\n");
        out.append("#include <stddef.h>\n");
        out.append("#include <stdint.h>\n");

        out.append("#include \"rtos-rigel.h\"\n");
        out.append("#include \"" + HFile.getName() + "\"\n");

        // write top-level tasking functions

        writeTopLevelTaskingFunctions(out);
        // There is some thinking to do here...

        writeWriters(out);
    }

    public void write() {
        try {
            log.status("Writing AADL middleware header files...");
            BufferedWriter hwriter = new BufferedWriter(new FileWriter(getHFile()));
            log.status("Writing AADL middleware source files...");
            BufferedWriter cwriter = new BufferedWriter(new FileWriter(getCFile()));
            writeHeader(hwriter);
            writeSource(cwriter);
            hwriter.close();
            cwriter.close();

        } catch (IOException e) {
            log.error("Unable to create output streams.\n");
        }

    }
}
