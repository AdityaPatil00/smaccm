package edu.umn.cs.crisys.smaccm.aadl2rtos.codegen.eChronos;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.util.List;

import edu.umn.cs.crisys.smaccm.aadl2rtos.codegen.common.C_Type_Writer;
import edu.umn.cs.crisys.smaccm.aadl2rtos.codegen.common.HeaderDeclarations;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.SharedDataAccessor;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.ThreadImplementation;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.ThreadInstance;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.SharedDataAccessor.AccessType;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.dispatcher.Dispatcher;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.dispatcher.ExternalHandler;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.dispatcher.InputEventDispatcher;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.dispatcher.PeriodicDispatcher;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.port.*;
import edu.umn.cs.crisys.smaccm.aadl2rtos.model.type.UnitType;
import edu.umn.cs.crisys.smaccm.aadl2rtos.parse.Model;
import edu.umn.cs.crisys.smaccm.aadl2rtos.util.Util;

import org.stringtemplate.v4.*;

public class HeaderWriter extends AbstractCodeWriter {
	public HeaderWriter(BufferedWriter out, File CFile, File HFile,
			Model model) {
		super(out, CFile, HFile, model);
	}

	public String getHeaderDefStr() {
	  return "__" + Util.normalizeAadlName(this.HFile.getName()) + "__";
	}
	
	public void writeHeader() throws IOException {
	  writeBeginningWrapper(); 
	  
	  // Write license data
		writeLicense();
		out.append("\n\n");

		// Write file metadata (date, filename, etc.)
		writeFileMetadata(HFile);
		out.append("\n\n");

		// Write file description
		STGroup group; 
		group = new STGroupFile("templates/CommentBlocks.stg");
    ST st = group.getInstanceOf("HeaderCommentBlock");
    st.add("sysInstanceName", sysInstanceName);
    out.append(st.render());

    
		if (model.getThreadCalendar().hasDispatchers()) {
	    st = group.getInstanceOf("DispatcherBlock");
	    out.append(st.render());
		}
		
		// Write AADL type declarations
		writeComment("   AADL TYPE DECLARATIONS \n");
		C_Type_Writer.writeTypes(out, model, 3);
		out.append("\n\n");

		// Write task-level entrypoint functions
		writeComment("   TASK-LEVEL ENTRYPOINT FUNCTIONS \n");
		writeEntrypoints();
		out.append("\n\n");

    // Write reader functions for user-level entrypoints
    writeComment("   READER/WRITER FUNCTIONS FOR USER-LEVEL ENTRYPOINTS \n");
    writeReaderWriterDecls();
    out.append("\n\n");


    // Write interface for user-defined entrypoints
		writeComment("   INTERFACE FOR USER-DEFINED ENTRYPOINTS \n");
		writeUdeDecls(allThreads);
		out.append("\n\n");

		writeEndingWrapper() ; 
		// End of file
		writeComment("   End of autogenerated file: " + HFile.toString() + "\n");
	}

	private void writeBeginningWrapper() throws IOException {
	  String name = this.getHeaderDefStr();
	  out.append("#ifndef " + name + "\n");
	  out.append("#define " + name + "\n");
	  out.append("#ifdef __cplusplus \n");
	  out.append("  extern \"C\" { \n");
	  out.append("#endif\n"); 
	}
	
	private void writeEndingWrapper() throws IOException {
    out.append("#ifdef __cplusplus \n");
    out.append("  } \n");
    out.append("#endif\n");
    out.append("#endif /*" + this.getHeaderDefStr() + "*/\n");
	}
	
	private void writeEntrypoints() throws IOException {
		for (ThreadImplementation tw : taskThreads) {
			out.append("	void " + tw.getGeneratedEntrypoint() + "(int threadID); \n\n");
			
			List<ThreadInstance> instanceList = tw.getThreadInstanceList();
			for (ThreadInstance instance: instanceList) {
				out.append("	void " + tw.getGeneratedEntrypoint() + "_Instance_" + instance.getThreadId() + "();\n\n");
			} 
		}
	}
	

	// TODO: mention that we do not currently support IN/OUT ports
	private void writeReaderWriterDecls() throws IOException {

		for (ThreadImplementation tw : allThreads) {
		  HeaderDeclarations.writeReaderWriterDecl(tw, out);
		}
	}

	
	


	// For each thread;
	// record the list of data ports
	// TODO: For each event port, how do we want the interface?
	// Perhaps it does not really exist.
	private void writeUdeDecls(List<ThreadImplementation> allThreads) throws IOException {
		for (ThreadImplementation tw : allThreads) {
			HeaderDeclarations.writeThreadUdeDecls(out, tw);
		}
	}

	
/*
	private String dataportArgs(List<MyPort> dpl) {
		StringBuilder out = new StringBuilder();
		Iterator<MyPort> iterator = dpl.iterator();
		while (iterator.hasNext()) {
			MyPort arg = iterator.next();
			out.append(arg.getDataType().toString());
			out.append(" ");
			out.append(arg.getName());
			if (iterator.hasNext()) {
				out.append(", ");
			}
		}
		return out.toString();
	}
*/  
	
}
