import "Common.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>


/////////////////////////////////////////////////////////////////////
// OS-specific naming functions.
//
/////////////////////////////////////////////////////////////////////
/*********************************************************************
 * OS-specific naming functions required by this file: 
 *   incomingPortWriterName
 *   incomingRPCDispatchName
 *   dispatcherWriterName
 * 	 portDispatcherLock
 *   portDispatcherUnlock
 *   dispatcherMainInitializeLockStmt
 *   dispatcherMainLockWaitStmt
 *   dispatcherMainLockReleaseStmt
>>
 
 */

genericFailure(template) ::= 
<< INTERNAL ERROR: template: <template> not overridden for host OS. >>  

incomingPortWriterName(port) ::= << 
<genericFailure("incomingPortWriterName")>
<port.dummyFieldForError>
>>

incomingRPCDispatchName(dispatcher) ::= <<
<genericFailure("incomingRPCDispatchName")>
<dispatcher.dummyFieldForError>
>>

dispatcherWriterName(dispatcher) ::= << 
<genericFailure("dispatcherWriterName")>
<port.dummyFieldForError>
>>

portDispatcherLock(dispatcher) ::= <<
<genericFailure("portDispatcherLock")>
<dispatcher.dummyFieldForError>
>>

portDispatcherUnlock(dispatcher) ::= <<
<genericFailure("portDispatcherUnlock")>
<dispatcher.dummyFieldForError>
>>

portLockStmt(port) ::= <<
<genericFailure("portLockStmt")>
<port.dummyFieldForError>
>>

portUnlockStmt(port) ::= <<
<genericFailure("portLockStmt")>
<port.dummyFieldForError>
>>

dispatcherMainInitializeLockStmt(threadImpl) ::= <<
<genericFailure("dispatcherMainInitializeLockStmt")>
<threadImpl.dummyFieldForError>
>>

dispatcherMainLockWaitStmt(threadImpl) ::= <<
<genericFailure("dispatcherMainLockWaitStmt")>
<threadImpl.dummyFieldForError>
>>

dispatcherMainLockReleaseStmt(threadImpl) ::= <<
<genericFailure("dispatcherMainLockReleaseStmt")>
<threadImpl.dummyFieldForError>
>>

dispatcherIsrMainLockReleaseStmt(threadImpl) ::= <<
<genericFailure("dispatcherIsrMainLockReleaseStmt")>
<threadImpl.dummyFieldForError>
>>


/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues for event data ports, 
// used for active thread to active thread communications.
//
/////////////////////////////////////////////////////////////////////


copyToQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.queueDataName>[<port.queueFrontName>] = *<port.name> ;
<else><aadlInputToValMemcpy(port.type, {<port.queueDataName>[<port.queueFrontName>]}, port.name )>
<endif>
>>

copyFromQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.queueDataName>[<port.queueBackName>] ;
<else><valToAadlOutputMemcpy(port.type, port.name, {<port.queueDataName>[<port.queueBackName>]})>
<endif>
>>

InputEventDataPortDecls(port) ::= <<

/************************************************************************
 * 
 * Static variables and queue management functions for port:
 * 	<port.name>
 * 
 ************************************************************************/
 
<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.type.aadlOutputType.name> <port.name>) {
	if (<port.queueIsEmptyName>()) {
		return false;
	} else {
		<copyFromQueueDataStmt(port)>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		<port.queueFullName> = false ; 
		return true;
	}
}

bool <port.queueWriteName>(const <port.type.aadlInputType.name> <port.name>) {
	if (<port.queueIsFullName>()) {
		return false;
	} else {
		<copyToQueueDataStmt(port)>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		if (<port.queueBackName> == <port.queueFrontName>) { 
			<port.queueFullName> = true ; 
		}
		return true;
	}
}

/************************************************************************
 *  <incomingPortWriterName(port)>: 
 * Invoked by: remote interface.
 * 
 * This is the function invoked by CAmkES to write to an active-thread
 * input event data port.  It queues the input message into a circular buffer.
 * 
 ************************************************************************/
 
bool <incomingPortWriterName(port)>(<port.type.camkesInputType.name> arg) {
	bool result;
	<port.camkesMutexLockFnCall>; 
	result = <port.queueWriteName>(<port.type.camkesInputToAadlInput> arg);
	<portUnlockStmt(port)>
	<if(port.hasDispatcher)><dispatcherMainLockReleaseStmt(port.threadImplementation)><endif>
	return result;
}


/************************************************************************
 *  <port.aadlReaderFnName>: 
 * Invoked from local active thread.
 * 
 * This is the function invoked by the active thread to read from the 
 * input event data queue circular buffer.
 * 
 ************************************************************************/

bool <port.aadlReaderFnName>(<port.type.aadlOutputType.name> arg) {
	bool result; 
	<portLockStmt(port)> 
	result = <port.queueReadName>(arg);
	<portUnlockStmt(port)>
	return result;
}

>>

/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues for event ports, 
// used for active thread to active thread communications.
//
// TODO: writer and reader functions have different format...why?
//
/////////////////////////////////////////////////////////////////////

InputEventPortDecls(port) ::= <<
<port.indexType.name> <port.index> = 0;

bool <port.queueIsFullName>() {
	return false;
}

bool <port.queueIsEmptyName>() {
	return <port.index> == 0; 
}

/************************************************************************
 *  <incomingPortWriterName(port)>: 
 * Invoked by: CAmkES
 * 
 * This is the function invoked by CAmkES to write to an active-thread
 * input event port.  It increments a count of received messages.
 * 
 ************************************************************************/

bool <incomingPortWriterName(port)>() {
	<portLockStmt(port)> 
	// Note: possibility for overflow here - should I worry about MAXINT messages?
	<port.index>++;
	<portUnlockStmt(port)>
	<if(port.hasDispatcher)><dispatcherMainLockReleaseStmt(port.threadImplementation)><endif>
	return true;
}

/************************************************************************
 *  <port.aadlReaderFnName>: 
 * Invoked from local active thread.
 * 
 * This is the function invoked by the active thread to decrement the 
 * input event index.
 * 
 ************************************************************************/

bool <port.aadlReaderFnName>() {
	bool result; 
	<portLockStmt(port)> 
	if (<port.index> > 0) {
		<port.index>--;
		result = true;
	} else {
		result = false;
	}
	<portUnlockStmt(port)>
	return result;
}

>>

optInputEventDataPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || 
    !port.hasDispatcher)>

<InputEventDataPortDecls(port)>
<endif>
>>


optInputEventPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || !port.hasDispatcher)>

<InputEventPortDecls(port)>
<endif>
>>


///////////////////////////////////////////////////////////////////////////
//
// Functions for managing Read/Write interfaces between active threads.
//
///////////////////////////////////////////////////////////////////////////

optConstCamkesInputArg(port) ::= "<if(port.hasData)><port.type.camkesInputType.name> <port.name><endif>"

componentRemoteWriteFunction(port) ::= <<

/************************************************************************
 *  <incomingPortWriterName(port)>: 
 * Invoked by CAmkES.
 * 
 * This is the function that is invoked by CAmkES to write to a data port.
 * 
 ************************************************************************/
 
bool <incomingPortWriterName(port)>(<optConstCamkesInputArg(port)>) {
	<portLockStmt(port)> 
	<if(port.type.isBaseType)><port.readerWriterImplVar> = *<port.name>;
	<else><camkesInputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
	<endif>
	<portUnlockStmt(port)>
	return true;
}

>>

componentLocalReadFunction(port) ::= <<
/************************************************************************
 *  <port.aadlReaderFnName>: 
 * Invoked from local active thread.
 * 
 * This is the function invoked by the active thread to read from a data port.
 * 
 ************************************************************************/

bool <port.aadlReaderFnName>(<userSendOptAadlOutputArg(port)>) {
	<portLockStmt(port)> 
	<if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.readerWriterImplVar>;
	<else><valToAadlOutputMemcpy(port.type, port.name, port.readerWriterImplVar)>
	<endif>
	<portUnlockStmt(port)>
	return true;
}

>>


componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentRemoteWriteFunction(port)>
>>

componentRemoteWriterDecl(port) ::= <<
/************************************************************************
 *  <port.aadlWriterFnName>: 
 * Invoked from user code in the local thread.
 * 
 * This is the function invoked by the local active thread to make a 
 * call to write to a remote data port.
 * 
 ************************************************************************/

bool <port.aadlWriterFnName>(const <port.type.aadlInputType.name> <port.name>) {
	// cast is necessary because CAmkES does not support passing constant arguments
	<incomingPortWriterName(port)>((<port.type.aadlInputType.name>)<port.type.aadlInputToCamkesInput> <port.name>);
	return true;
}

>>



/////////////////////////////////////////////////////////////////////
//
// UserEntrypointCaller functions
// 
// These functions provide the "scaffolding" functions necessary to 
// set up the output event ports prior to making a call to the user
// code.
// 
// These are the implementations of the RPC functions for passive 
// components that are called using CAmkES.  They are also used 
// in active components to set up local procedure calls to user code.
//
/////////////////////////////////////////////////////////////////////


userEntrypointCallerCall(externalHandler, dispatcher) ::= <<
<if(dispatcher.hasData)>
<externalHandler.handlerName>(<dispatcher.type.camkesInputToAadlInput><dispatcher.name>); 
<else><externalHandler.handlerName>();
<endif>
>>


userEntrypointCallerInputArg(dispatcher) ::=  << <dispatcher.type.camkesInputType.name> <dispatcher.name> >>


userEntrypointCallerDataOutputArg(dispatchContract) ::= 
<< <if(dispatchContract.canDispatch)> <if(dispatchContract.port.hasData)><dispatchContract.dispatchStructTypeName> *<dispatchContract.port.data>, <endif><\\> 
  <dispatchContract.port.indexType.aadlOutputType.name> <dispatchContract.port.index> <endif>
>>

userEntrypointCallerFnArgs(dispatcher) ::= <<
<if(dispatcher.hasData)>
<[userEntrypointCallerInputArg(dispatcher), dispatcher.dispatchableContracts:userEntrypointCallerDataOutputArg()]; separator=",\n">
<else>
<dispatcher.dispatchableContracts:userEntrypointCallerDataOutputArg();separator=",\n">
<endif>
>>

userEntrypointCallerAssignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<if(dispatchContract.canDispatch)><\\>
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = <dispatchContract.port.data>->f;<endif> 
*<dispatchContract.port.globalIndex> = 0; 
<endif>
>> 

userEntrypointCallerFnName(dispatcher) ::=
	"<dispatcher.threadImplementation.componentDispatcherInterfaceVarIdName>_<dispatcher.idlDispatcherName>"

userEntrypointCallerFn(dispatcher) ::= << 
/************************************************************************
 *  <userEntrypointCallerFnName(dispatcher)>: 
 * Invoked from local active thread.
 * 
 * This is the function invoked by a local active thread dispatcher to 
 * call to a user-defined entrypoint function after setting up the dispatch
 * context for the user-defined entrypoint.
 * 
 ************************************************************************/
void <userEntrypointCallerFnName(dispatcher)>(<userEntrypointCallerFnArgs(dispatcher)>) {
	<dispatcher.maxDispatchContracts.contracts:userEntrypointCallerAssignGlobals()>
	<dispatcher.externalHandlers:userEntrypointCallerCall(dispatcher)>
}	


>>	 



/////////////////////////////////////////////////////////////////////
//
// userSendDefinition: 
// 
// These declarations construct the callback functions for user code
// in order to 'send' a message to other components.  In truth, they
// queue the message to be sent in local data; the actual 'send' is
// performed on the queued messages after the user code completes. 
//
/////////////////////////////////////////////////////////////////////

userSendCopyAadlInputToGlobalStmt(port) ::= <<
<if(port.type.isBaseType)><\\>
<port.globalDataSlot> = *<port.name>;
<else><aadlInputToValMemcpy(port.type, port.globalDataSlot, port.name)>
<endif>
>>

userSendOptConstAadlInputArg(port) ::= "<if(port.hasData)>const <port.type.aadlInputType.name> <port.name><endif>"
userSendOptAadlOutputArg(port) ::= "<if(port.hasData)><port.type.aadlOutputType.name> <port.name><endif>"

userSendDefinition(port) ::= << 
/************************************************************************
 * <port.aadlWriterFnName> 
 * Invoked from local active or passive thread.
 * 
 * This is the comm function invoked by a user-level thread to send a message 
 * to another thread.  It enqueues the request to be sent when the user thread
 * completes execution.
 * 
 ************************************************************************/

bool <port.aadlWriterFnName>(<port:userSendOptConstAadlInputArg()>) {
	if (<port.globalMaxDispatchSize> > 0 && 
		 *<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><userSendCopyAadlInputToGlobalStmt(port)><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>
  
/////////////////////////////////////////////////////////////////////
//
// aadlDispatcher declarations
//
// These declarations are used to construct the AADL event loop 
// dispatcher for an AADL 'send' primitive.  They take as input the 
// input to be 'sent'.  They define the queues to be used 
// for any resulting messages to be transmitted based on the 
// user code's response to the message.  To interface with the user 
// code, they call the userEntrypointCaller function matching the 
// 'send' interface.  Then they drain the queues of generated 
// messages, calling an aadlDispatcher function for each message, 
// which will repeat the process for the next 'send'...
//
/////////////////////////////////////////////////////////////////////


aadlDispatcherDeclareData(dispatcherContract) ::= <<
<if(dispatcherContract.port.hasData)><dispatcherContract.dataDecl>;<endif>
<dispatcherContract.port.indexType.name> <dispatcherContract.port.index>;

>>

aadlDispatcherPassiveCallOutPortArg(port) ::= <<
<if(port.hasData)>		<port.type.valToAadlOutput><port.data>,<endif>
		<port.type.valToAadlOutput><port.index> >>

aadlDispatcherPassiveCallOutArg(dispatchContract) ::= "<aadlDispatcherPassiveCallOutPortArg(dispatchContract.port)>"

aadlDispatcherWritePassiveArg(port) ::= <<
<if(port.hasData)><port.type.valToAadlInput>(<port.data>.f[smaccm_it])<endif>
>>

aadlDispatcherWriteActiveArg(port) ::= <<
<if(port.hasData)>
/* cast is necessary because CAmkES does not yet make inputs const */ (<port.type.camkesInputType.name>)(<port.type.valToCamkesInput>(<port.data>.f[smaccm_it]))
<endif>
>>

aadlDispatcherCallPassiveTarget(portDest,portSrc) ::= <<
<dispatcherWriterName(portDest.dispatcher)>(<aadlDispatcherWritePassiveArg(portSrc)>);	
>>

aadlDispatcherCallActiveTarget(portDest,portSrc) ::= <<
<incomingPortWriterName(portSrc)>(<aadlDispatcherWriteActiveArg(portSrc)>);	

>>

aadlDispatcherSendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index> && smaccm_it \< <dispatchContract.maxDispatchSize>; smaccm_it++) {
   <dispatchContract.passiveDispatchTargetList:aadlDispatcherCallPassiveTarget(dispatchContract.port)>
   <dispatchContract.activeDispatchTargetList:aadlDispatcherCallActiveTarget(dispatchContract.port)>
}

>>

/////////////////////////////////////////////////////////////
// if the thread is *not* passive and it is a dispatcher, 
// then it is the currently running active thread.  It
// might be better to pass in the threadImpl and do this
// comparison directly.
/////////////////////////////////////////////////////////////

aadlDispatcherFunctionName(dispatcher) ::= <<
<if(dispatcher.threadImplementation.isPassive)><\\>
<dispatcher.passiveComponentDispatcherPathName><\\>
<else><userEntrypointCallerFnName(dispatcher)><endif>
>>

 
aadlDispatcherFunctionArgs(dispatcher) ::= 
<< <if(dispatcher.hasData)><\\>
	 <[{ <dispatcher.type.aadlInputToCamkesInput> <dispatcher.name>}, dispatcher.dispatchableContracts:aadlDispatcherPassiveCallOutArg() ];separator=", \n"> 
	 <else><\\>
	<dispatcher.dispatchableContracts:aadlDispatcherPassiveCallOutArg();separator=", \n"> <endif>
>>

aadlDispatcherFunction(dispatcher) ::= <<
/************************************************************************
 * <dispatcherWriterName(dispatcher)>
 * Invoked from local active thread.
 * 
 * This is the dispatcher function invoked to respond to an incoming thread 
 * stimulus: an ISR, a periodic dispatch, or a queued event.
 * 
 ******************************************************************************/
void <dispatcherWriterName(dispatcher)>(<if(dispatcher.hasData)><dispatcher.type.aadlInputType.name> <dispatcher.name><endif>) {
	<dispatcher.dispatchableContracts:aadlDispatcherDeclareData()>
	
	<portDispatcherLock(dispatcher)>
	// make the call: 
	<aadlDispatcherFunctionName(dispatcher)>(<aadlDispatcherFunctionArgs(dispatcher)>	
		); 
	<portDispatcherUnlock(dispatcher)>
	
<if(dispatcher.dispatchableContracts)>
	// call the aadl dispatchers for any generated output events.
	// to prevent misuse by malicious clients, we ensure that the number 
	// of dispatches is less than the maximum allowed dispatch count.
	uint32_t smaccm_it; 
	<dispatcher.dispatchableContracts:aadlDispatcherSendLoop(dispatcher)>
<endif>
}

>>

aadlDispatcherFunctionPrototype(dispatcher) ::=  <<
void <dispatcherWriterName(dispatcher)>(<if(dispatcher.hasData)><dispatcher.type.aadlInputType.name> <dispatcher.name><endif>); 

>>

///////////////////////////////////////////////////////////////////////////
//
// Periodic and IRQ dispatcher functions
//
///////////////////////////////////////////////////////////////////////////


dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

/************************************************************************
 * <dispatcher.name> Declarations
 * 
 ************************************************************************/

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

/************************************************************************
 * <incomingRPCDispatchName(dispatcher)>
 * Invoked from CAmkES thread.
 * 
 * This function records the current time and triggers the active thread 
 * dispatch from a periodic event.
 * 
 ************************************************************************/

bool <incomingRPCDispatchName(dispatcher)><\\>
(<dispatcher.type.camkesInputType.name> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = <dispatcher.type.camkesInputToVal>arg;
	<dispatcherMainLockReleaseStmt(dispatcher.threadImplementation)>
	return true;
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

/************************************************************************
 * <incomingRPCDispatchName(dispatcher)>
 * Invoked from CAmkES thread.
 * 
 * This function records an IRQ event, calls the first-level interrupt handler,
 * and triggers the thread to dispatch (which will invoke the second-level
 * interrupt handler).
 * 
 ************************************************************************/
void <incomingRPCDispatchName(dispatcher)>() {
	<dispatcher.firstLevelInterruptHandler>();
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcherMainLockReleaseStmt(dispatcher.threadImplementation)>
	<dispatcher.name>_reg_callback(<incomingRPCDispatchName(dispatcher)>, NULL); 
}

>> 

///////////////////////////////////////////////////////////////////////////
//
// declarations related to main function
//
///////////////////////////////////////////////////////////////////////////


periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcherWriterName(dispatcher)>(&<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcherWriterName(dispatcher)>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (<dispatcher.inputEventDispatcherPort.aadlReaderFnName>()) {
	<dispatcherWriterName(dispatcher)>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.inputEventDispatcherPort.isEmptyFnCall>) {
	<dispatcher.inputEventDispatcherPort.varDecl>;
	<dispatcher.inputEventDispatcherPort.queueReadName>(<dispatcher.type.valToAadlOutput><dispatcher.inputEventDispatcherPort.name>);
	<dispatcherWriterName(dispatcher)>(<dispatcher.type.valToAadlInput><dispatcher.inputEventDispatcherPort.name>); 
}

>>

drainDispatcher(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>


dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isInput)><else> ERROR: dispatcher is not IRQ, Event Data, or Periodic
<endif>
>>

portInitializer(port) ::= <<
<if(port.hasInitializeEntrypoint)><port.initializeEntrypointOpt.handlerName>();
<endif>
>>

registerIRQs(dispatcher) ::= << <if(dispatcher.isIRQ)><dispatcher.name>_reg_callback(<incomingRPCDispatchName(dispatcher)>, NULL);
<endif> >>

dispatcherComponentMainFunction(threadImpl) ::= <<
/************************************************************************
 * run()
 * Main active thread function.
 * 
 ************************************************************************/

int run() {
	// port initialization routines (if any)... 
	<threadImpl.portList:portInitializer()>
	
	// thread initialization routines (if any)...
	<if(threadImpl.hasInitializeEntrypoint)><threadImpl.initializeEntrypointOpt.handlerName>();<endif>

	// register interrupt handlers (if any)...
	<threadImpl.dispatchers:registerIRQs()>
	
	// initial lock to await dispatch input.
	<dispatcherMainInitializeLockStmt(threadImpl)>
	for(;;) {
		<dispatcherMainLockWaitStmt(threadImpl)>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatcher()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


///////////////////////////////////////////////////////////////////////////
//
// Variable declarations for dispatch ports.
//
///////////////////////////////////////////////////////////////////////////


portDispatchVarDeclarations(port) ::= <<
<if(port.hasData)><port.type.aadlOutputType.name> <port.globalData>; <endif>
<port.indexType.aadlOutputType.name> <port.globalIndex>;
<port.indexType.name> <port.globalMaxDispatchSize>; 	

>>


///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>
#include <\u003C><threadImpl.componentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<if(threadImpl.isActive)><\\>
///////////////////////////////////////////////////////////////////////////
//
// Local prototypes for AADL dispatchers
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.passiveDispatcherRegion:aadlDispatcherFunctionPrototype()> 
<endif>


<threadImpl.inputEventDataPortList:optInputEventDataPortDecls()>
<threadImpl.inputEventPortList:optInputEventPortDecls()>

<threadImpl.allOutputEventPorts:portDispatchVarDeclarations()>

<threadImpl.dispatchers:dispatcherComponentEventDecls()>
<threadImpl.dispatchers:userEntrypointCallerFn()>
<threadImpl.allOutputEventPorts:userSendDefinition()>
<threadImpl.inputDataPortList:componentLocalReaderDecl()>
<threadImpl.outputDataPortList:componentRemoteWriterDecl()>

<if(threadImpl.isActive)><\\>
<threadImpl.passiveDispatcherRegion:aadlDispatcherFunction()> 
<if(threadImpl.isExternal)><\\>
////////////////////////////////////////////////////////////////////////////
//
// NOTE: External thread, so we assume the run function is externally declared.
//
////////////////////////////////////////////////////////////////////////////
<else>
<dispatcherComponentMainFunction(threadImpl)>
<endif>
<endif>

>>

// <threadImpl.localActiveThreadConnectionFrontier:localSendDecl()>

/////////////////////////////////////////////////////////////////////
//
// localSendDecl: 
// 
// This creates a local call to the queuing function 
/////////////////////////////////////////////////////////////////////
/************************************************************************
 *  <connection.sourcePort.qualifiedName>_<connection.destPort.type.writerFn>: 
 * Invoked from local active thread.
 * 
 * This function wraps an event queue call to an active thread that was a result 
 * of one of the passive thread "children" of this thread.
 * 
 ************************************************************************/
/*
localSendDecl(connection) ::= <<

<if(connection.sourcePort.hasData)>
void <RemotePortWriterName(connection.sourcePort)>(const <connection.sourcePort.type.camkesInputType.name> arg) {
	<incomingPortWriterName(connection.destPort)>((<connection.sourcePort.type.camkesInputType.name>) arg);
}
<else>
void <RemotePortWriterName(connection.sourcePort)>() {
	<incomingPortWriterName(connection.destPort)>();
}

<endif>

>>
*/
