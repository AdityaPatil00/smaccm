import "Common.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
// Some design notes: 
//   TBD 
//      
//   
// 
//
//
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>


/////////////////////////////////////////////////////////////////////
//
// Functions for managing RPCs
//
/////////////////////////////////////////////////////////////////////

writeAadlArgument(parameter) ::= 
<< <if(parameter.isInput)><parameter.type.camkesInputToAadlInput><endif><parameter.name> >>

writeProvidesEndpointRpc(rpc, endpoint) ::= << 
<writeCamkesCRpcPrototype(rpc, endpoint)>
{
	<endpoint.aadlName>_<rpc.name>(<rpc.parameters:writeAadlArgument();separator=", ">);
}
>>


writeProvidesEndpoint(endpoint) ::= <<
<if(!endpoint.isExternal)><\\>
<endpoint.remoteProcedureGroup.remoteProcedures:writeProvidesEndpointRpc(endpoint); separator="\n">
<endif>
>>


writeCamkesArgument(parameter) ::= 
<< <if(parameter.isInput)><parameter.type.aadlInputToCamkesInput><endif><parameter.name> >>

writeRequiresEndpointRpc(rpc, endpoint) ::= << 
<writeAadlCRpcPrototype(rpc, endpoint)>
{
	<endpoint.name>_<rpc.name>(<rpc.parameters:writeCamkesArgument();separator=", ">);
}
>>

writeRequiresEndpoint(endpoint) ::= << 
<if(!endpoint.isExternal)><\\>
<endpoint.remoteProcedureGroup.remoteProcedures:writeRequiresEndpointRpc(endpoint); separator="\n">
<endif>
>>

/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues for event data ports, 
// used for active thread to active thread communications.
//
// TODO: writer and reader functions have different format...why?
//
/////////////////////////////////////////////////////////////////////

ReceiverQueueDecls(port) ::= <<
// Static variables for input receiver <port.name>
<port.queueDataDecl>;
<port.queueFrontDecl>;
<port.queueBackDecl>;
<port.queueFullDecl>;
>>

copyToQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.queueDataName>[<port.queueFrontName>] = <port.name> ;
<else><aadlInputToValMemcpy(port.type, {<port.queueDataName>[<port.queueFrontName>]}, port.name )>
<endif>
>>

copyFromQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.queueDataName>[<port.queueBackName>] ;
<else><valToAadlOutputMemcpy(port.type, port.name, {<port.queueDataName>[<port.queueBackName>]})>
<endif>
>>

InputEventDataPortDecls(port) ::= <<

<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.type.aadlOutputType.name> <port.name>) {
	if (<port.queueIsEmptyName>()) {
		return false;
	} else {
		<copyFromQueueDataStmt(port)>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		<port.queueFullName> = false ; 
		return true;
	}
}

bool <port.queueWriteName>(const <port.type.aadlInputType.name> <port.name>) {
	if (<port.queueIsFullName>()) {
		return false;
	} else {
		<copyToQueueDataStmt(port)>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		if (<port.queueBackName> == <port.queueFrontName>) { 
			<port.queueFullName> = true ; 
		}
		return true;
	}
}

bool <port.name>_<port.type.writerFn>(<port.type.camkesInputType.name> arg) {
	bool result;
	<port.camkesMutexLockFnCall>; 
	result = <port.queueWriteName>(<port.type.camkesInputToAadlInput> arg);
	<port.camkesMutexUnlockFnCall>;
	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
	return result;
}


bool <port.aadlReaderFnName>(<port.type.aadlOutputType.name> arg) {
	bool result; 
	<port.camkesMutexLockFnCall>; 
	result = <port.queueReadName>(arg);
	<port.camkesMutexUnlockFnCall>;
	return result;
}

>>

/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues for event ports, 
// used for active thread to active thread communications.
//
// TODO: writer and reader functions have different format...why?
//
/////////////////////////////////////////////////////////////////////

InputEventPortDecls(port) ::= <<
<port.indexType.name> <port.index> = 0;

bool <port.queueIsFullName>() {
	return false;
}

bool <port.queueIsEmptyName>() {
	return <port.index> == 0; 
}

bool <port.name>_<port.type.writerFn>() {
	<port.camkesMutexLockFnCall>; 
	// Note: possibility for overflow here - should I worry about MAXINT messages?
	<port.index>++;
	<port.camkesMutexUnlockFnCall>;
	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
	return true;
}

bool <port.aadlReaderFnName>() {
	bool result; 
	<port.camkesMutexLockFnCall>; 
	if (<port.index> > 0) {
		<port.index>--;
		result = true;
	} else {
		result = false;
	}
	<port.camkesMutexUnlockFnCall>;
	return result;
}

>>

optInputEventDataPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || 
    !port.hasDispatcher)>

//////////////////////////////////////////////////////
//
// Global data for event data port <port.name>
//
//////////////////////////////////////////////////////

<InputEventDataPortDecls(port)>
<endif>
>>


optInputEventPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || !port.hasDispatcher)>

//////////////////////////////////////////////////////
//
// Global data for event port <port.name>
//
//////////////////////////////////////////////////////

<InputEventPortDecls(port)>
<endif>
>>


///////////////////////////////////////////////////////////////////////////
//
// Functions for managing Read/Write interfaces between active threads.
//
///////////////////////////////////////////////////////////////////////////

optConstCamkesInputArg(port) ::= "<if(port.hasData)><port.type.camkesInputType.name> <port.name><endif>"

componentRemoteWriteFunction(port) ::= <<

// The writer function is called remotely through RPC, so follows the 
// RPC naming and return convention.  
bool <port.name>_<port.type.writerFn>(<optConstCamkesInputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<if(port.type.isBaseType)><port.readerWriterImplVar> = <port.name>;
	<else><camkesInputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
	<endif>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>

componentLocalReadFunction(port) ::= <<
bool <port.aadlReaderFnName>(<optAadlOutputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.readerWriterImplVar>;
	<else><valToAadlOutputMemcpy(port.type, port.name, port.readerWriterImplVar)>
	<endif>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>


componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentRemoteWriteFunction(port)>
>>

componentRemoteWriterDecl(port) ::= <<
bool <port.aadlWriterFnName>(<port.type.aadlInputType.name> <port.name>) {
	<port.name>_<port.type.writerFn>(<port.type.aadlInputToCamkesInput> <port.name>);
	return true;
}

>>


/////////////////////////////////////////////////////////////////////
//
// Code for dispatching active threads based on external 
// stimulus to its dispatcher fn.
//
/////////////////////////////////////////////////////////////////////

periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (<dispatcher.inputEventDispatcherPort.aadlReaderFnName>()) {
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.inputEventDispatcherPort.isEmptyFnCall>) {
	<dispatcher.inputEventDispatcherPort.varDecl>;
	<dispatcher.inputEventDispatcherPort.queueReadName>(<dispatcher.type.valToAadlOutput><dispatcher.inputEventDispatcherPort.name>);
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.type.valToAadlOutput><dispatcher.inputEventDispatcherPort.name>); 
}

>>

/////////////////////////////////////////////////////////////////////
//
// Constructing the dispatcher functions for each port
//
/////////////////////////////////////////////////////////////////////


externalHandlerDispatcher(externalHandler, dispatcher) ::= <<
<if(dispatcher.hasData)>
<externalHandler.handlerName>(<dispatcher.type.camkesInputToAadlInput><dispatcher.name>); 
<else><externalHandler.handlerName>();
<endif>
>>


dispatcherInputArg(dispatcher) ::=  << <dispatcher.type.camkesInputType.name> <dispatcher.name> >>


dispatcherDataOutputArg(dispatchContract) ::= 
<< <if(dispatchContract.port.hasData)><dispatchContract.dispatchArrayTypeName> *<dispatchContract.port.data>, <endif><\\> 
  <dispatchContract.port.indexType.aadlOutputType.name> <dispatchContract.port.index> 
>>

componentCamkesDispatcherFnName(dispatcher) ::=
	"<dispatcher.threadImplementation.componentDispatcherInterfaceVarIdName>_<dispatcher.idlDispatcherName>"

componentCamkesDispatcherFnArgs(dispatcher) ::= <<
<if(dispatcher.hasData)>
<[dispatcherInputArg(dispatcher), dispatcher.contracts:dispatcherDataOutputArg()]; separator=",\n">
<else>
<dispatcher.contracts:dispatcherDataOutputArg();separator=",\n">
<endif>
>>

assignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<if(dispatchContract.canDispatch)><\\>
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = *<dispatchContract.port.data>;<endif> 
*<dispatchContract.port.globalIndex> = 0; <endif>
>> 

// TODO: fix: if dispatcher port has no contract, then we get seg fault writing to null 
componentCamkesDispatcherFn(dispatcher) ::= << 
void <componentCamkesDispatcherFnName(dispatcher)>(<componentCamkesDispatcherFnArgs(dispatcher)>) {
	<dispatcher.contracts:assignGlobals()>
	// globals assigned!
	<dispatcher.externalHandlers:externalHandlerDispatcher(dispatcher)>
}	


>>	 


/////////////////////////////////////////////////////////////////////
//
// declarations for creating the component `send' callback function
//
/////////////////////////////////////////////////////////////////////

copyAadlInputToGlobalStmt(port) ::= <<
<if(port.type.isBaseType)><\\>
<port.globalDataSlot> = <port.name>;
<else><aadlInputToValMemcpy(port.type, port.globalDataSlot, port.name)>
<endif>
>>

optConstAadlInputArg(port) ::= "<if(port.hasData)><port.type.aadlInputType.name> <port.name><endif>"
optAadlOutputArg(port) ::= "<if(port.hasData)><port.type.aadlOutputType.name> <port.name><endif>"

componentSendFunction(port) ::= << 
bool <port.aadlWriterFnName>(<port:optConstAadlInputArg()>) {
	if (<port.globalMaxDispatchSize> > 0 && 
		 *<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><copyAadlInputToGlobalStmt(port)><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>
  
/////////////////////////////////////////////////////////////////////
//
// Declarations for C function implementing AADL dispatcher
//
/////////////////////////////////////////////////////////////////////


dispatcherDeclareData(dispatcherContract) ::= <<
<if(dispatcherContract.port.hasData)><dispatcherContract.dataDecl>;<endif>
<dispatcherContract.port.indexType.name> <dispatcherContract.port.index>;

>>

passiveDispatcherCallOutPortArg(port) ::= <<
<if(port.hasData)><port.type.valToAadlOutput><port.data>,<endif>
<port.type.valToAadlOutput><port.index>
>>

writePassiveDispatcherArg(port) ::= <<
<if(port.hasData)><port.type.valToCamkesInput>(<port.data>[smaccm_it])<endif>
>>

passiveDispatcherCallOutArg(dispatchContract) ::= "<passiveDispatcherCallOutPortArg(dispatchContract.port)>"

callPassiveTargetDispatcher(portDest,portSrc) ::= <<
<portDest.threadImplementation.interfaceInstanceName>_<portDest.idlDispatcherName>(<writePassiveDispatcherArg(portSrc)>);	
>>

callActiveTargetDispatcher(portDest,portSrc) ::= <<
<portSrc.name>_<portDest.type.writerFn>(<writePassiveDispatcherArg(portSrc)>);	

>>

sendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index>; smaccm_it++) {
   <dispatchContract.passiveDispatchTargetList:callPassiveTargetDispatcher(dispatchContract.port)>
   <dispatchContract.activeDispatchTargetList:callActiveTargetDispatcher(dispatchContract.port)>
}

>>

aadlDispatcherFunctionName(dispatcher) ::= <<
<if(dispatcher.threadImplementation.isPassive)><\\>
<dispatcher.passiveComponentDispatcherPathName>
<else><componentCamkesDispatcherFnName(dispatcher)><endif>
>>

aadlDispatcherFunctionArgs(dispatcher) ::= <<
		<if(dispatcher.hasData)><[{<dispatcher.type.aadlInputToCamkesInput> <dispatcher.name>}, dispatcher.contracts:passiveDispatcherCallOutArg() ];separator=", \n"> <else><\\>
		<dispatcher.contracts:passiveDispatcherCallOutArg();separator=", \n"> <endif>
>>

aadlDispatcherFunction(dispatcher) ::= <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<if(dispatcher.hasData)><dispatcher.type.aadlInputType.name> <dispatcher.name><endif>) {
	<dispatcher.contracts:dispatcherDeclareData()>
	
	// make the call: 
	<aadlDispatcherFunctionName(dispatcher)>(<aadlDispatcherFunctionArgs(dispatcher)>); 

<if(dispatcher.contracts)>
	// invoke any resulting `send' operations
	uint32_t smaccm_it; 
	<dispatcher.contracts:sendLoop(dispatcher)>
<endif>
}

>>


///////////////////////////////////////////////////////////////////////////
//
// Periodic and IRQ dispatcher functions
//
///////////////////////////////////////////////////////////////////////////

camkesRPCDispatchName(dispatcher) ::= <<
  <dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>
>>

dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

bool <camkesRPCDispatchName(dispatcher)><\\>
(<dispatcher.type.camkesInputType.name> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = arg;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
	return true;
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

void <camkesRPCDispatchName(dispatcher)>() {
	<dispatcher.firstLevelInterruptHandler>();
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
	<dispatcher.name>_reg_callback(<camkesRPCDispatchName(dispatcher)>, NULL); 
}

>> 

///////////////////////////////////////////////////////////////////////////
//
// declarations related to main function
//
///////////////////////////////////////////////////////////////////////////


drainDispatcher(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>


dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isInput)><else> ERROR: dispatcher is not IRQ, Event Data, or Periodic
<endif>
>>

portInitializer(port) ::= <<
<if(port.hasInitializeEntrypoint)><port.initializeEntrypointOpt.handlerName>();
<endif>
>>

registerIRQs(dispatcher) ::= << <if(dispatcher.isIRQ)><dispatcher.name>_reg_callback(<camkesRPCDispatchName(dispatcher)>, NULL);
<endif> >>

dispatcherComponentMainFunction(threadImpl) ::= <<
int run() {
	// port initialization routines (if any)... 
	<threadImpl.portList:portInitializer()>
	
	// thread initialization routines (if any)...
	<if(threadImpl.hasInitializeEntrypoint)><threadImpl.initializeEntrypointOpt.handlerName>();<endif>

	// register interrupt handlers (if any)...
	<threadImpl.dispatchers:registerIRQs()>
	
	// initial lock to await dispatch input.
	<threadImpl.dispatcherLockStmt>
	for(;;) {
		<threadImpl.dispatcherLockStmt>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatcher()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


///////////////////////////////////////////////////////////////////////////
//
// Variable declarations for dispatch ports.
//
///////////////////////////////////////////////////////////////////////////


portDispatchVarDeclarations(port) ::= <<
<if(port.hasData)><port.type.aadlOutputType.name> <port.globalData>; <endif>
<port.indexType.aadlOutputType.name> <port.globalIndex>;
<port.indexType.name> <port.globalMaxDispatchSize>; 	

>>


///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>
#include <\u003C><threadImpl.componentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

///////////////////////////////////////////////////////////////////////////
//
// Functions for managed RPCs
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.requiredEndpoints:writeRequiresEndpoint()>

<threadImpl.providedEndpoints:writeProvidesEndpoint()>

///////////////////////////////////////////////////////////////////////////
//
// Functions and declarations for queued inputs
//
///////////////////////////////////////////////////////////////////////////

<threadImpl.inputEventDataPortList:optInputEventDataPortDecls()>
<threadImpl.inputEventPortList:optInputEventPortDecls()>

<threadImpl.allOutputEventPorts:portDispatchVarDeclarations()>

///////////////////////////////////////////////////////////////////////////
//
// Functions for dispatching IRQs and Periodic Events
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.dispatchers:dispatcherComponentEventDecls()>
<threadImpl.dispatchers:componentCamkesDispatcherFn()>
<threadImpl.allOutputEventPorts:componentSendFunction()>
<threadImpl.inputDataPortList:componentLocalReaderDecl()>
<threadImpl.outputDataPortList:componentRemoteWriterDecl()>

<if(threadImpl.isActive)><\\>
// Writing dispatchers...
<threadImpl.dispatchers:aadlDispatcherFunction()> 
<if(threadImpl.isExternal)><\\>
////////////////////////////////////////////////////////////////////////////
//
// NOTE: External thread, so we assume the run function is externally declared.
//
////////////////////////////////////////////////////////////////////////////
<else>
// thread main function
<dispatcherComponentMainFunction(threadImpl)>
<endif>
<endif>

>>

