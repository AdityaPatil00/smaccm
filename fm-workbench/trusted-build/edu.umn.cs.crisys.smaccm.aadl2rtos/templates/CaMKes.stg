////////////////////////////////////////////////////////////////////////////
//
// Generic Declarations
// 
////////////////////////////////////////////////////////////////////////////


blockComment(arg) ::= <<

/**************************************************************************
  <arg>
 **************************************************************************/

>>

DARPALicense() ::= <<
Copyright (c) 2013, 2014 Rockwell Collins and the University of Minnesota.
Developed with the sponsorship of the Defense Advanced Research Projects Agency (DARPA).

Permission is hereby granted, free of charge, to any person obtaining a copy of this data,
including any software or models in source or binary form, as well as any drawings, specifications, 
and documentation (collectively "the Data"), to deal in the Data without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Data, and to permit persons to whom the Data is furnished to do so, 
subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Data.

THE DATA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS, SPONSORS, DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE 
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE DATA. 

>>

DARPALicenseComment() ::= "<blockComment(DARPALicense())>"

filenameBlockComment(date, path, purpose) ::= <<
/**************************************************************************

   File: <path>
   Created on: <date>
   using Dulcimer AADL system build tool suite 

   ***AUTOGENERATED CODE: DO NOT MODIFY***

  <purpose>

 **************************************************************************/
>>

stdFilePrefix(date, path, purpose) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, purpose)>

>>

stdFilePostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to AADL datatype file for CAmkES
// 
////////////////////////////////////////////////////////////////////////////


datatypesblockPurpose(sysInstanceName) ::= <<
This file contains the datatypes used for communications between 
AADL components as defined in the system implementation <sysInstanceName>.
>>


datatypesHeaderIfdef(sysInstanceName) ::= "__SMACCM_<sysInstanceName>_types__H"

datatypesPrefix(name, date, path) ::= <<
#ifndef <datatypesHeaderIfdef(name)>
#define <datatypesHeaderIfdef(name)>

<DARPALicenseComment()>

<filenameBlockComment(date, path, datatypesblockPurpose(name))>
	
#include \<stdbool.h>
#include \<stddef.h>
#include \<stdint.h>

>>

datatypesPostfix(name, path) ::= <<

/* endif for: #ifndef <datatypesHeaderIfdef(name)> */
#endif

<blockComment(arg={End of autogenerated file: <path>})>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component header files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentDatatypesBlockPurpose(componentName) ::= <<
This file contains the datatypes used for constructing the dispatch 
interfaces for AADL thread implementation <componentName>.
>>

componentDatatypesHeaderIfdef(componentName) ::= "__SMACCM_<componentName>_dispatch_types__H"

componentDatatypesPrefix(name, date, path) ::= <<
#ifndef <datatypesHeaderIfdef(name)>
#define <datatypesHeaderIfdef(name)>

<DARPALicenseComment()>

<filenameBlockComment(date, path, componentDatatypesBlockPurpose(name))>
	
>>

componentDatatypesPostfix(name, path) ::= <<

/* endif for: #ifndef <componentDatatypesHeaderIfdef(name)> */
#endif

<blockComment(arg={End of autogenerated file: <path>})>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to .idl4 files for reader/writer interfaces
// 
////////////////////////////////////////////////////////////////////////////

rwInterfaceIdlPurpose(typeName) ::= <<
This .idl4 file contains the writer interface used for read/write ports
for type name <typeName>.
>>

rwInterfaceIdlPrefix(name, date, path) ::= "<stdFilePrefix(date, path, rwInterfaceIdlPurpose(name))>"

rwInterfaceIdlPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>
>>

rwPrototype(type) ::= <<
void <type.writerFn>(in <type.name> arg);  
>>

rwProc(type, model) ::= <<

procedure <type.readerWriterInterfaceName> {
    include <\u003C><model.systemTypeHeaderName><\u003E>;
	<rwPrototype(type)>
}
>>

rwUnitProc(type) ::= <<

procedure <type.readerWriterInterfaceName> {
   void <type.writerFn>();
}
>>

idlProc(type, model) ::= <<
<if(type.hasData)><rwProc(type,model)><else><rwUnitProc(type)><endif>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to .idl4 files for AADL shared variable interfaces
// 
////////////////////////////////////////////////////////////////////////////

svInterfaceIdlPurpose(typeName) ::= <<
This .idl4 file contains the writer interface used for AADL shared variables
for type name <typeName>.
>>

svInterfaceIdlPrefix(name, date, path) ::= <<
	
<DARPALicenseComment()>

<filenameBlockComment(date, path, svInterfaceIdlPurpose(name))>

>>

svInterfaceIdlPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>
>>

svProc(type, model) ::= <<

procedure <type.sharedDataInterfaceName> {
    include <\u003C><model.systemTypeHeaderName><\u003E>;
	void <type.sharedDataInterfaceReadFnName>(out <type.name> arg);
	void <type.sharedDataInterfaceWriteFnName>(in <type.name> arg);  
}

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to .idl4 files for dispatch interfaces
// 
////////////////////////////////////////////////////////////////////////////


dispatchInterfaceIdlPurpose(componentName) ::= <<
This .idl4 file contains the dispatcher interface used for dispatching 
the thread implementation <componentName>.
>>

dispatchInterfaceIdlPrefix(name, date, path) ::= "<stdFilePrefix(date, path, dispatchInterfaceIdlPurpose(name))>"

dispatchInterfaceIdlPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>
>>

dispatcherInputArg(arg) ::= "in <arg.type> <arg.name>"


dispatcherDeclaration(dispatcher, arg) ::= << void <dispatcher.idlDispatcherName>(<arg; separator=",\n   ">) >>

dispatcherPrototype(dispatcher, arg) ::= <<
<dispatcherDeclaration(dispatcher, arg)>; 
>>

port_params(dispatchContract, port) ::= << 
<if(port.hasData)><\\>
out <dispatchContract.dispatchArrayTypeName> <port.data>, 
<endif>out <port.indexType.outputTypeName> <port.index>

>>

contract_params(dispatchContract) ::= << ,
			<port_params(dispatchContract, dispatchContract.port)>
>>

dispatcher(dispatcher) ::= <<
void <dispatcher.idlDispatcherName>(in <dispatcher.type.name> smaccm_in <dispatcher.contracts:contract_params()>); 

>>

dispatcherProc(threadImpl, datatypesHeader) ::= <<

procedure <threadImpl.idlName> {
    include <\u003C><datatypesHeader><\u003E>;
    <threadImpl.dispatchers:dispatcher(); separator="\n">
}

>> 

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode header files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeHeaderPurpose() ::= <<
This header section contains the AADL gluecode interfaces used by the client
for the thread implementations.
>>

componentGlueCodeHeaderIfdef(sysInstanceName) ::= "__SMACCM_<sysInstanceName>_types__H"


componentGlueCodeHeaderPrefix(name, date, path, datatypesHeader) ::= <<
#ifndef <componentGlueCodeHeaderIfdef(name)>
#define <componentGlueCodeHeaderIfdef(name)>

#include <\u003C><datatypesHeader><\u003E>
	
<DARPALicenseComment()>

<filenameBlockComment(date, path, dispatchInterfaceIdlPurpose(name))>

>>


<!
  static public String udeEntrypointDecl(Dispatcher d, String fnName) {
    if (d instanceof InputEventDispatcher && 
        ((InputEventDispatcher)d).getEventPort().isInputEventDataPort()) {
      InputEventDispatcher ied = (InputEventDispatcher)d;
      return "   void " + fnName
          + "(const " + Names.createRefParameter(ied.getEventPort().getType(), "elem") + " ); \n\n";
    }
    else if (d instanceof PeriodicDispatcher) {
      return "   void " + fnName
          + "(uint32_t *millis_from_sys_start); \n\n";
    }
    else {
      return "   void " + fnName
        + "(); \n\n";
    }
  }

  static public void writeThreadUdeDecls(BufferedWriter out, ThreadImplementation tw) throws IOException {
    ExternalHandler initHandler = tw.getInitializeEntrypointOpt();
    if ((initHandler != null)) {
      out.append("   void " + initHandler.getHandlerName() + "();\n\n");
    }

    // compute entrypoints for thread.
    List<Dispatcher> dl = tw.getDispatcherList();
    for (Dispatcher d: dl) {
      List<ExternalHandler> handlers = d.getExternalHandlerList();
      for (ExternalHandler eh: handlers) {
        out.append(udeEntrypointDecl(d, eh.getHandlerName()));
      }
    }
  }

  
  static public void writeReaderWriterDecl(ThreadImplementation tw, BufferedWriter out) throws IOException {
    for (DataPort dpiw : tw.getPortList()) {
      String fnName = CommonNames.getReaderWriterFnName(dpiw);
      String argString = ""; 
      if (!dpiw.getType().equals(new UnitType())) {
        argString = CommonNames.createRefParameter(dpiw.getType(), "arg");
        if (dpiw instanceof OutputPort) {
          argString = "const " + argString;
        }
      }
      out.append("   bool " + fnName + "(" + argString + "); \n\n");
    }
    
    for (SharedDataAccessor sda: tw.getSharedDataAccessors()) {
      if (sda.getAccessType() == AccessType.READ || 
          sda.getAccessType() == AccessType.READ_WRITE) {
        String fnName = CommonNames.getThreadImplReaderFnName(sda);
        String argString = CommonNames.createRefParameter(sda.getSharedData().getType(), "arg");
        out.append("   bool " + fnName + "(" + argString + "); \n\n");
      }
      if (sda.getAccessType() == AccessType.WRITE || 
          sda.getAccessType() == AccessType.READ_WRITE) {
        String fnName = CommonNames.getThreadImplWriterFnName(sda);
        String argString = CommonNames.createRefParameter(sda.getSharedData().getType(), "arg");
        out.append("   bool " + fnName + "(const " + argString + "); \n\n");
      }
    }
  }
!>

writeExternalHandlerUdePrototype(externalHandler, dispatcher) ::= <<
<if(dispatcher.isEventData || dispatcher.isPeriodic)><\\>
void <externalHandler.handlerName>(<dispatcher.nameAsInputParam>); 
<else><\\>
void <externalHandler.handlerName>();
<endif>
>>

writeUdePrototype(dispatcher) ::= <<
	<dispatcher.externalHandlers:writeExternalHandlerUdePrototype(dispatcher)>
>>

writePortPrototype(port) ::= <<

>>
componentGlueCodeHeaderBody(threadImplementation) ::= <<
	<threadImplementation.dispatchers:writeUdePrototype()>
	<threadImplementation.portList:writePortPrototype()>
	<threadImplementation.sharedDataAccessorList:writeSharedDataPrototype()>
>>

componentGlueCodeHeaderPostfix(name, path) ::= <<

/* endif for: #ifndef <componentGlueCodeHeaderIfdef(name)> */
#endif

<blockComment(arg={End of autogenerated file: <path>})>

>>

cStmt(stmt) ::= "<stmt>;"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>


cPortTempVarDeclarations(port) ::= <<
<if(port.hasData)><port.globalDataParam>; <endif>
<port.globalIndexParam>;
<port.globalMaxDispatchSizeParam>; 	

>>

optDispatcherInputArg(dispatcher) ::= << <if(dispatcher.hasData)><dispatcher.nameAsInputParam> <endif> >>

cUserDispatcher(externalHandler, dispatcherNameStr) ::= <<
<externalHandler.handlerName>(<dispatcherNameStr>); 
>>


cPortOutputArg(port) ::= "<if(port.hasData)><port.dataParam>, <endif>"

cDispatchContractOutputArg(dispatchContract) ::= <<  
		<cPortOutputArg(dispatchContract.port)>
		<dispatchContract.port.indexParam>
>>

optDispatcherComma(dispatcher) ::= "<if (dispatcher.hasData && dispatcher.contracts)>,<endif>"

componentDispatcherFn(dispatcher) ::= << 
void <dispatcher.threadImplementation.componentName>_<dispatcher.idlDispatcherName><\\>
(<dispatcher:optDispatcherInputArg()><optDispatcherComma(dispatcher)><dispatcher.contracts:cDispatchContractOutputArg();separator=",\n">) {
	<dispatcher.contracts:assignGlobals()>
	<dispatcher.externalHandlers:cUserDispatcher(dispatcher.name)>
}	


>>	 


assignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = <dispatchContract.port.data>;<endif> 
*<dispatchContract.port.globalIndex> = 0;

>> 

optConstInputArg(port) ::= "<if(port.hasData)>const <port.nameAsInputParam><endif>"
optInputArg(port) ::= "<if(port.hasData)><port.nameAsInputParam><endif>"

componentSendFunction(port) ::= << 
bool <port.writerFnName>(<port:optConstInputArg()>) {
	if (*<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><port.copyToGlobalDataStmt><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>

componentLocalWriteFunction(port) ::= <<
bool <port.writerFnName>(<optConstInputArg(port)>) {
	<port.camkesMutexLockFunction>; 
	<port.copyToImplVarStmt>
	<port.camkesMutexUnlockFunction>;
	return true;
}

>>

componentLocalReadFunction(port) ::= <<
bool <port.readerFnName>(<optInputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<port.copyFromImplVarStmt>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>

componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentLocalWriteFunction(port)>
>>


componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>

<threadImpl.allOutputEventPorts:cPortTempVarDeclarations()>

<threadImpl.dispatchers:componentDispatcherFn()>

<threadImpl.allOutputEventPorts:componentSendFunction()>

<threadImpl.inputDataPortList:componentLocalReaderDecl()>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component dispatcher gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

dispatcherComponentGlueCodeCFilePurpose(name) ::= <<
This C file contains the dispatcher functions for the 'active' thread 
<name>.  There is no direct interaction between the functionality in 
this file and user-level code.  Instead, this file interacts with the 
aadl-generated C file for passive components and the CAmkES generated
component skeleton.

This file contains: 
	1.) The main loop for the control thread to dispatch to 
		components
	2.) The dispatcher functions for all passive components.
	3.) The shared data for any of the active thread send/receive ports.
	4.) The receiver functions to store messages and wake up the 
		control thread.
	5.) The sender functions for other "active" components.

>>

dispatcherComponentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, dispatcherComponentGlueCodeCFilePurpose(name))>"

dispatcherComponentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>

periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (!<dispatcher.isEmpty>) {
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.isEmpty>) {
	<dispatcher.eventPort.varDecl>
	<dispatcher.eventPort.queueReadName>(<dispatcher.eventPort.varRef>);
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.eventPort.name>); 
}

>>

drainDispatchers(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>
	

dispatcherDeclareData(dispatcherContract) ::= <<
<dispatcherContract.dataDecl>;
<dispatcherContract.indexDecl>;

>>

passiveDispatcherCallOutPortArg(port) ::= <<
<if(port.hasData)><port.type.valAsOutput><port.data>,<endif>
<port.type.valAsOutput><port.index>
>>

writePassiveDispatcherArg(port) ::= <<
<if(port.hasData)><port.type.valAsInput>(<port.data>[smaccm_it])<endif>
>>

passiveDispatcherCallOutArg(dispatchContract) ::= <<, 
				<passiveDispatcherCallOutPortArg(dispatchContract.port)> >>

callTargetDispatcher(portDest,portSrc) ::= <<
<portDest.threadImplementation.interfaceInstanceName>_<portDest.idlDispatcherName>(<writePassiveDispatcherArg(portSrc)>);	

>>

sendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index>; smaccm_it++) {
   <dispatchContract.dispatchTargetList:callTargetDispatcher(dispatchContract.port)>
}

>>

dispatcherComponentDataDispatchFunction(dispatcher) ::= <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.nameAsInputParam>) {
	<dispatcher.contracts:dispatcherDeclareData()>
	
	// make the call: 
	<dispatcher.passiveComponentDispatcherPathName>(<dispatcher.name> <dispatcher.contracts:passiveDispatcherCallOutArg()>);
	
	<if(dispatcher.contracts)>
	// invoke any resulting `send' operations
	uint32_t smaccm_it; 
	<dispatcher.contracts:sendLoop(dispatcher)>
	<endif>
}


>>

dispatcherComponentReceiverQueueDecls(port) ::= <<
// Static variables for input receiver <port.name>
<port.queueDataDecl>;
<port.queueFrontDecl>;
<port.queueBackDecl>;
<port.queueFullDecl>;
>>

dispatcherComponentReceiverDecls(port) ::= <<
<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.nameAsOutputParam>) {
	if (<port.queueIsFullFnCall>) {
		return false;
	} else {
		<copyToQueueDataStmt>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		if (<port.queueBackName> == <port.queueFrontName>) { <port.queueFullName> = true ; }
		return true;
	}
}

bool <port.queueWriteName>(const <port.nameAsInputParam>) {
	if (<port.queueIsEmptyFnCall>) {
		return false;
	} else {
		<copyFromQueueDataStmt>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		<port.queueFullName> = false ; 
		return true;
	}
}

>>


dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

void <dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn><\\>
(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = arg;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

void <dispatcher.camkesRPCDispatchName>(<dispatcher.type.inputName> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>> 


// TODO: Dispatcher component for input events.
dispatcherComponentInputEventDecls(dispatcher) ::= <<

void <dispatcher.camkesRPCDispatchName>(<dispatcher.type.inputName> arg) {
	// TODO: This is unfinished!
}

>>

dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isEvent)><dispatcherComponentInputEventDecls(dispatcher)>
<else> ERROR: dispatcher is not IRQ, Event, or Periodic
<endif>
>>

writePassiveDispatchers(threadImpl) ::= <<
<threadImpl.dispatchers:dispatcherComponentDataDispatchFunction()>	

>>


dispatcherComponentMainFunction(threadImpl) ::= <<
int run() {
	// initialization routines ... skipped for now.
	
	// initial lock to await dispatch input.
	<threadImpl.dispatcherLockStmt>
	for(;;) {
		<threadImpl.dispatcherLockStmt>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatchers()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


dispatcherComponentCDecls(model, threadImpl) ::= <<

<if(threadImpl.inputEventPortList)><\\>
// Functions for managing event queues 
<endif>
<threadImpl.inputEventPortList:dispatcherComponentReceiverDecls()>

<! <model.threadImplementations:writePassiveDispatchers()	> !>

// Functions for managing input dispatchers 
<threadImpl.dispatchers:dispatcherComponentEventDecls()>

<threadImpl.dispatchers:dispatcherComponentDataDispatchFunction()>

<dispatcherComponentMainFunction(threadImpl)>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component CAmkES file
// 
////////////////////////////////////////////////////////////////////////////

componentCamkesPurpose(componentName) ::= <<
This header file contains the CAmkES component definition for the 
AADL thread implementation <componentName>.
>>

componentCamkesPrefix(name, date, path, datatypesHeader) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, componentCamkesPurpose(name))>

>>

componentCamkesPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>


addPortIdl(port) ::= <<
import "../../interfaces/<port.type.readerWriterIdlFileName>";

>>

addSharedDataAccessorIdl(sharedDataAccesor) ::= <<
import "../../interfaces/<sharedDataAccessor.type.sharedDataIdlFileName>";

>>

inputDataPortDecl(port) ::= <<
provides <port.type.readerWriterInterfaceName> <port.name>; 
has mutex <port.mutex>; 

>>

outputDataPortDecl(port) ::= <<
uses <port.type.readerWriterInterfaceName> <port.name>;

>>

sharedDataAccessorDecl(sharedDataAcessor) ::= <<
uses <sharedDataAccessor.type.readerWriterInterfaceName> <sharedDataAccessor.name>;

>>

componentCamkesBody(threadImpl) ::= <<

import "../../interfaces/<threadImpl.idlFileName>";

<threadImpl.inputDataPortList:addPortIdl()>
<threadImpl.outputDataPortList:addPortIdl()>
<threadImpl.sharedDataAccessorList:addSharedDataAccessorIdl()>

component <threadImpl.componentName> {
	provides <threadImpl.idlName> <threadImpl.componentDispatcherInterfaceVarIdName>;
	<threadImpl.inputDataPortList:inputDataPortDecl()>
	<threadImpl.outputDataPortList:outputDataPortDecl()>
	<threadImpl.sharedDataAccessorList:sharedDataAccessorDecl()>
}
>> 


////////////////////////////////////////////////////////////////////////////
//
// Declarations for camkes dispatcher component
// 
////////////////////////////////////////////////////////////////////////////

dispatcherComponentCamkesPurpose(componentName) ::= <<
This header file contains the CAmkES dispatcher component definition for the 
AADL active thread implementation <componentName>.
>>

dispatcherComponentCamkesPrefix(name, date, path, datatypesHeader) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, dispatcherComponentCamkesPurpose(name))>

>>

importThreadIdl(threadImpl) ::= <<
import "../../interfaces/<threadImpl.idlFileName>";
>>

importReaderWriterIdl(type) ::= <<
import "../../interfaces/<type.readerWriterIdlFileName>";
>>

writeProvidedInterface(dispatcher) ::= <<
provides <dispatcher.type.readerWriterInterfaceName> <dispatcher.dispatcherComponentDispatchName>;
<if(dispatcher.isEvent)><\\>
has mutex <dispatcher.mutex>; 
<endif>
>>

writeSender(dispatcher) ::= <<
<if(dispatcher.isEvent)><\\>
uses <dispatcher.type.readerWriterInterfaceName> <dispatcher.dispatcherComponentDispatchName>;
<endif>
>>

writeSenders(threadImpl) ::= <<
<threadImpl.dispatchers:writeSender();separator="\n">
>>

writeToPassiveReceiver(threadImpl) ::= <<
uses <threadImpl.idlName> <threadImpl.interfaceInstanceName>;

>>

dispatchComponentCDecls(threadImpl, model) ::= <<

// Passive component dispatch interfaces 
<model.threadImplementations:importThreadIdl()>

// Send/receive interfaces for active components
<model.activeThreadSendReceiveTypeList:importReaderWriterIdl()>

component <threadImpl.dispatcherComponentName> {
	control;
    
    has mutex <threadImpl.dispatcherComponentMutexName>;

	// dispatchable receive interfaces for thread <threadImpl.dispatcherComponentName> 
	<threadImpl.dispatchers:writeProvidedInterface()>
	
	// references to other active thread send interfaces
	<threadImpl.otherActiveThreadImplementations:writeSenders()>
	
	<model.threadImplementations:writeToPassiveReceiver()>
}
>>

dispatcherComponentCamkesPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>


////////////////////////////////////////////////////////////////////////////
//
// Declarations for periodic dispatcher
// 
////////////////////////////////////////////////////////////////////////////

writePeriodicSender(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
uses <dispatcher.type.readerWriterInterfaceName> <dispatcher.dispatcherComponentDispatchName>; 
<endif>
>>

writePeriodicSenders(threadImpl) ::= <<
	<threadImpl.dispatchers:writePeriodicSender()>
>>
 
periodicDispatcherCamkesBody(model, type) ::= <<

import "../../interfaces/<type.readerWriterIdlFileName>";

component <model.threadCalendar.periodicDispatcherComponentName> {
	control;
	<model.activeThreadImplementations:writePeriodicSenders()>
}

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations for camkes assembly
// 
////////////////////////////////////////////////////////////////////////////

camkesAssemblyPurpose(sysInstanceName) ::= <<
This header file contains the main CAmkES assembly for the  
AADL system instance rooted at <sysInstanceName>.
>>

camkesAssemblyPrefix(name, date, path) ::= "<stdFilePrefix(date, path, camkesAssemblyPurpose(name))>"

assemblyThreadImplementationImports(threadImpl) ::= <<
import "<threadImpl.rootToCamkesComponentFilePath>";
<if(threadImpl.isActive)><\\>
import "<threadImpl.rootToCamkesDispatcherComponentFilePath>";
<endif>
>>

assemblyThreadComponents(threadImpl) ::= <<
component <threadImpl.componentName> <threadImpl.componentInstanceName>;

>>

assemblyActiveThreadComponents(threadImpl) ::= <<
component <threadImpl.dispatcherComponentName> <threadImpl.dispatcherComponentInstanceName>;

>>

constructPeriodicComponent(calendar) ::= <<
<if(calendar.hasDispatchers)><\\>
component <calendar.periodicDispatcherComponentName> <calendar.periodicDispatcherInstanceName>;
<endif>
>>	

rpcConnection(cid, from1, from2, to1, to2) ::= 
   "connection seL4RPCCall <cid> (from <from1>.<from2>, to <to1>.<to2>);"

connectPassiveToActive(passiveThreadImpl, activeThreadImpl, model) ::= <<
<rpcConnection(model.generateConnectionName,
	activeThreadImpl.dispatcherComponentInstanceName,
	passiveThreadImpl.interfaceInstanceName,
	passiveThreadImpl.componentInstanceName,
	passiveThreadImpl.componentDispatcherInterfaceVarIdName)>

>>

assemblyConnectActiveToPassiveThreads(threadImpl, model) ::= <<
<model.threadImplementations:connectPassiveToActive(threadImpl, model)>
>>


connectActiveSendToActiveSend(dispatcher, destThreadImpl, srcThreadImpl, model) ::= <<
<if(dispatcher.isEvent)><\\>
<rpcConnection(model.generateConnectionName, 
	srcThreadImpl.dispatcherComponentInstanceName,
    dispatcher.dispatcherComponentDispatchName, 
	destThreadImpl.dispatcherComponentInstanceName,
	dispatcher.dispatcherComponentDispatchName)> 
<endif>
>>

connectActiveToActive(destThreadImpl, srcThreadImpl, model) ::= <<
<destThreadImpl.dispatchers:connectActiveSendToActiveSend(destThreadImpl, srcThreadImpl, model)>
>>

assemblyConnectActiveToActiveThreads(threadImpl, model) ::= <<
<threadImpl.otherActiveThreadImplementations:connectActiveToActive(threadImpl, model)>
>>

connectActivePeriodic(dispatcher, threadImpl, model) ::= <<
<if(dispatcher.isPeriodic)><\\>
<rpcConnection(model.generateConnectionName, 
	model.threadCalendar.periodicDispatcherInstanceName,
	dispatcher.dispatcherComponentDispatchName, 
	threadImpl.dispatcherComponentInstanceName,
	dispatcher.dispatcherComponentDispatchName)>
<endif>
>>

assemblyConnectPeriodic(threadImpl, model) ::= <<
<threadImpl.dispatchers:connectActivePeriodic(threadImpl, model)>
>>

connectReaderWriter(connection, srcThreadImpl, model) ::= <<
<if(connection.sourcePort.isOutputDataPort)><\\>
<rpcConnection(model.generateConnectionName, 
	srcThreadImpl.componentInstanceName,
	connection.sourcePort.name,
	connection.destPortThreadImplementation.componentInstanceName,
	connection.destPort.name)>
<endif>
>>

assemblyConnectReadersWriters(threadImpl, model) ::= <<
<threadImpl.isSrcOfConnectionList:connectReaderWriter(threadImpl, model)>
>>

camkesAssemblyBody(model) ::= <<

import <\u003C>std_connector.camkes<\u003E>;
<if(model.threadCalendar.hasDispatchers)>import "<model.threadCalendar.periodicDispatcherPathName>";<endif>
<model.threadImplementations:assemblyThreadImplementationImports()>

assembly {
	composition {
		<constructPeriodicComponent(model.threadCalendar)>
		
		// component instances for all AADL-defined threads
		<model.threadImplementations:assemblyThreadComponents()>
		
		// active thread components
		<model.activeThreadImplementations:assemblyActiveThreadComponents()>
	
		// connections from active dispatchers to passive threads
		<model.activeThreadImplementations:assemblyConnectActiveToPassiveThreads(model)>	
		
		// connections from active dispatcher send/receive to other active dispatcher send/receive
		<model.activeThreadImplementations:assemblyConnectActiveToActiveThreads(model)>
		
		// Periodic dispatcher connections
		<model.activeThreadImplementations:assemblyConnectPeriodic(model)>
		
		// Passive component read/write connections
		<model.threadImplementations:assemblyConnectReadersWriters(model)>
		
		// Shared data connections (currently unsupported: under development)
	}
}

>>
