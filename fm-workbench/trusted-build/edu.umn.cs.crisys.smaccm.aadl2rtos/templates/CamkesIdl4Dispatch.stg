import "Common.stg"


////////////////////////////////////////////////////////////////////////////
//
// Declarations related to .idl4 files for dispatch interfaces
// 
////////////////////////////////////////////////////////////////////////////


dispatchInterfaceIdlPurpose(componentName) ::= <<
This .idl4 file contains the dispatcher interface used for dispatching 
the thread implementation <componentName>.
>>

dispatchInterfaceIdlPrefix(name, date, path) ::= "<stdFilePrefix(date, path, dispatchInterfaceIdlPurpose(name))>"

dispatchInterfaceIdlPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>
>>

dispatcherInputArg(arg) ::= "in <arg.type> <arg.name>"


dispatcherDeclaration(dispatcher, arg) ::= << void <dispatcher.idlDispatcherName>(<arg; separator=",\n   ">) >>

dispatcherPrototype(dispatcher, arg) ::= <<
<dispatcherDeclaration(dispatcher, arg)>; 
>>

port_params(dispatchContract, port) ::= << 
<if(port.hasData)><\\>
out <dispatchContract.dispatchArrayTypeName> <port.data>, 
<endif>out <port.indexType.name> <port.index>

>>

contract_params(dispatchContract) ::= << ,
			<port_params(dispatchContract, dispatchContract.port)>
>>

dispatcher(dispatcher) ::= <<
void <dispatcher.idlDispatcherName>(in <dispatcher.type.name> smaccm_in <dispatcher.contracts:contract_params()>); 

>>

dispatcherProc(threadImpl, datatypesHeader) ::= <<

procedure <threadImpl.idlName> {
    include <\u003C><datatypesHeader><\u003E>;
    <threadImpl.dispatchers:dispatcher(); separator="\n">
}

>> 

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode header files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeHeaderPurpose() ::= <<
This header section contains the AADL gluecode interfaces used by the client
for the thread implementations.
>>

componentGlueCodeHeaderIfdef(sysInstanceName) ::= "__SMACCM_<sysInstanceName>_types__H"


componentGlueCodeHeaderPrefix(name, date, path, datatypesHeader) ::= <<
#ifndef <componentGlueCodeHeaderIfdef(name)>
#define <componentGlueCodeHeaderIfdef(name)>

#include <\u003C><datatypesHeader><\u003E>
	
<DARPALicenseComment()>

<filenameBlockComment(date, path, dispatchInterfaceIdlPurpose(name))>

>>



writeExternalHandlerUdePrototype(externalHandler, dispatcher) ::= <<
<if(dispatcher.isEventData || dispatcher.isPeriodic)><\\>
void <externalHandler.handlerName>(<dispatcher.nameAsInputParam>); 
<else><\\>
void <externalHandler.handlerName>();
<endif>
>>

writeUdePrototype(dispatcher) ::= <<
<dispatcher.externalHandlers:writeExternalHandlerUdePrototype(dispatcher)>
>>

writePortWriterPrototype(port) ::= <<
bool <port.aadlWriterFnName>(<port.nameAsInputParam>); 
>>

writePortReaderPrototype(port) ::= <<
bool <port.aadlReaderFnName>(<port.nameAsOutputParam>); 
>>

writeSharedDataPrototype(sda) ::= <<
<if(sda.accessContainsInput)><\\>
bool <sda.readerFnName>(<sda.nameAsInputParam>);
<endif><if(sda.accessContainsOutput)><\\>
bool <sda.writerFnName>(<sda.nameAsOutputParam>);
<endif>

>>

componentGlueCodeHeaderBody(threadImpl) ::= <<
	<threadImpl.dispatchers:writeUdePrototype()>
	<threadImpl.outputPortList:writePortWriterPrototype()>
	<threadImpl.inputPortList:writePortReaderPrototype()>
	<threadImpl.sharedDataAccessorList:writeSharedDataPrototype()>
	
>>

componentGlueCodeHeaderPostfix(name, path) ::= <<

/* endif for: #ifndef <componentGlueCodeHeaderIfdef(name)> */
#endif

<blockComment(arg={End of autogenerated file: <path>})>

>>

cStmt(stmt) ::= "<stmt>;"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>


cPortTempVarDeclarations(port) ::= <<
<if(port.hasData)><port.globalDataParam>; <endif>
<port.globalIndexParam>;
<port.globalMaxDispatchSizeParam>; 	

>>

optDispatcherInputArg(dispatcher) ::= << <if(dispatcher.hasData)><dispatcher.nameAsInputParam> <endif> >>

cUserDispatcher(externalHandler, dispatcherNameStr) ::= <<
<externalHandler.handlerName>(<dispatcherNameStr>); 
>>


cPortOutputArg(dispatchContract) ::= 
"<if(dispatchContract.port.hasData)><dispatchContract.dispatchArrayTypeName> *<dispatchContract.port.data>, <endif>"

cDispatchContractOutputArg(dispatchContract) ::= <<  
		<cPortOutputArg(dispatchContract)>
		<dispatchContract.port.indexParam>
>>

optDispatcherComma(dispatcher) ::= "<if (dispatcher.hasData && dispatcher.contracts)>,<endif>"

componentDispatcherFn(dispatcher) ::= << 
void <dispatcher.threadImplementation.componentDispatcherInterfaceVarIdName>_<dispatcher.idlDispatcherName><\\>
(<dispatcher:optDispatcherInputArg()><optDispatcherComma(dispatcher)><dispatcher.contracts:cDispatchContractOutputArg();separator=",\n">) {
	<dispatcher.contracts:assignGlobals()>
	<dispatcher.externalHandlers:cUserDispatcher(dispatcher.name)>
}	


>>	 


assignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = *<dispatchContract.port.data>;<endif> 
*<dispatchContract.port.globalIndex> = 0;

>> 

copyToGlobalStmt(port) ::= <<
<if(port.type.isBaseType)><\\>
<port.globalDataSlot> = <port.name>;
<else><inputToValMemcpy(port.type, port.globalDataSlot, port.name)>
<endif>
>>

optConstInputArg(port) ::= "<if(port.hasData)>/* const */<port.nameAsInputParam><endif>"
optOutputArg(port) ::= "<if(port.hasData)><port.nameAsOutputParam><endif>"

componentSendFunction(port) ::= << 
bool <port.aadlWriterFnName>(<port:optConstInputArg()>) {
	if (*<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><copyToGlobalStmt(port)><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>
  
copyToImplVarStmt(port) ::= <<
<if(port.type.isBaseType)><port.readerWriterImplVar> = <port.name>;
<else><inputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
<endif>
>>

copyFromImplVarStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.outputToVal><port.name> = <port.readerWriterImplVar>;
<else><valToOutputMemcpy(port.type, port.name, port.readerWriterImplVar)>
<endif>
>>

componentLocalWriteFunction(port) ::= <<

// The writer function is called remotely through RPC, so follows the 
// RPC naming and return convention.  
void <port.name>_<port.type.writerFn>(<optConstInputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<copyToImplVarStmt(port)>
	<port.camkesMutexUnlockFnCall>;
}

>>

componentLocalReadFunction(port) ::= <<
bool <port.aadlReaderFnName>(<optOutputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<copyFromImplVarStmt(port)>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>


componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentLocalWriteFunction(port)>
>>

componentRemoteWriterDecl(port) ::= <<
bool <port.aadlWriterFnName>(<port.nameAsInputParam>) {
	<port.name>_<port.type.writerFn>(<port.name>);
	return true;
}

>>

componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>
#include <\u003C><threadImpl.componentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<threadImpl.allOutputEventPorts:cPortTempVarDeclarations()>

<threadImpl.dispatchers:componentDispatcherFn()>

<threadImpl.allOutputEventPorts:componentSendFunction()>

<threadImpl.inputDataPortList:componentLocalReaderDecl()>

<threadImpl.outputDataPortList:componentRemoteWriterDecl()>
>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component dispatcher gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

dispatcherComponentGlueCodeCFilePurpose(name) ::= <<
This C file contains the dispatcher functions for the 'active' thread 
<name>.  There is no direct interaction between the functionality in 
this file and user-level code.  Instead, this file interacts with the 
aadl-generated C file for passive components and the CAmkES generated
component skeleton.

This file contains: 
	1.) The main loop for the control thread to dispatch to 
		components
	2.) The dispatcher functions for all passive components.
	3.) The shared data for any of the active thread send/receive ports.
	4.) The receiver functions to store messages and wake up the 
		control thread.
	5.) The sender functions for other "active" components.

>>

dispatcherComponentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, dispatcherComponentGlueCodeCFilePurpose(name))>"

dispatcherComponentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>

periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (!<dispatcher.isEmpty>) {
	// TODO: write decrement operation here!
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.inputEventDispatcherPort.isEmptyFnCall>) {
	<dispatcher.inputEventDispatcherPort.varDecl>;
	<dispatcher.inputEventDispatcherPort.queueReadName>(<dispatcher.type.inputToOutput><dispatcher.inputEventDispatcherPort.name>);
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.inputEventDispatcherPort.name>); 
}

>>

drainDispatchers(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>
	

dispatcherDeclareData(dispatcherContract) ::= <<
<dispatcherContract.dataDecl>;
<dispatcherContract.indexDecl>;

>>

passiveDispatcherCallOutPortArg(port) ::= <<
<if(port.hasData)><port.type.valToOutput><port.data>,<endif>
<port.type.valToOutput><port.index>
>>

writePassiveDispatcherArg(port) ::= <<
<if(port.hasData)><port.type.valToInput>(<port.data>[smaccm_it])<endif>
>>

passiveDispatcherCallOutArg(dispatchContract) ::= <<, 
				<passiveDispatcherCallOutPortArg(dispatchContract.port)> >>

callPassiveTargetDispatcher(portDest,portSrc) ::= <<
<portDest.threadImplementation.interfaceInstanceName>_<portDest.idlDispatcherName>(<writePassiveDispatcherArg(portSrc)>);	
>>

callActiveTargetDispatcher(portDest,portSrc) ::= <<
<portSrc.name>_<portDest.type.writerFn>(<writePassiveDispatcherArg(portSrc)>);	

>>

sendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index>; smaccm_it++) {
   <dispatchContract.passiveDispatchTargetList:callPassiveTargetDispatcher(dispatchContract.port)>
   <dispatchContract.activeDispatchTargetList:callActiveTargetDispatcher(dispatchContract.port)>
}

>>

dispatcherComponentDataDispatchFunction(dispatcher) ::= <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.nameAsInputParam>) {
	<dispatcher.contracts:dispatcherDeclareData()>
	
	// make the call: 
	<dispatcher.passiveComponentDispatcherPathName>(<dispatcher.name> <dispatcher.contracts:passiveDispatcherCallOutArg()>);
	
	<if(dispatcher.contracts)>
	// invoke any resulting `send' operations
	uint32_t smaccm_it; 
	<dispatcher.contracts:sendLoop(dispatcher)>
	<endif>
}


>>

dispatcherComponentReceiverQueueDecls(port) ::= <<
// Static variables for input receiver <port.name>
<port.queueDataDecl>;
<port.queueFrontDecl>;
<port.queueBackDecl>;
<port.queueFullDecl>;
>>

copyToQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.queueDataName>[<port.queueBackName>] = <port.name> ;
<else><inputToValMemcpy(port.type, {<port.queueDataName>[<port.queueBackName>]}, port.name )>
<endif>
>>

copyFromQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.outputToVal><port.name> = <port.queueDataName>[<port.queueBackName>] ;
<else><valToOutputMemcpy(port.type, port.name, {<port.queueDataName>[<port.queueBackName>]})>
<endif>
>>

dispatcherComponentInputEventDataPortDecls(port) ::= <<
<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.nameAsOutputParam>) {
	if (<port.queueIsEmptyName>()) {
		return false;
	} else {
		<copyFromQueueDataStmt(port)>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		<port.queueFullName> = false ; 
		return true;
	}
}

bool <port.queueWriteName>(const <port.nameAsInputParam>) {
	if (<port.queueIsFullName>()) {
		return false;
	} else {
		<copyToQueueDataStmt(port)>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		if (<port.queueBackName> == <port.queueFrontName>) { 
			<port.queueFullName> = true ; 
		}
		return true;
	}
}

void <port.name>_<port.type.writerFn>(<port.type.inputTypeName> arg) {
	// TODO: add mutex lock for queue here.
	<port.queueWriteName>(arg);
	// TODO: add mutex unlock for queue here.

	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
}

>>

dispatcherComponentInputEventPortDecls(port) ::= <<
<port.index> = 0;

bool <port.queueIsFullName>() {
	return false;
}

bool <port.queueIsEmptyName>() {
	return <port.index> == 0; 
}

void <port.name>_<port.type.writerFn>(<port.type.inputTypeName> arg) {
	// TODO: add mutex lock for queue here.
	<port.index>++;
	// TODO: add mutex unlock for queue here.

	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
}

>>

camkesRPCDispatchName(dispatcher) ::= <<
  <dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>
>>

dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

void <camkesRPCDispatchName(dispatcher)><\\>
(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = arg;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

void <camkesRPCDispatchName(dispatcher)>(<dispatcher.type.inputName> arg) {
	// TODO: add mutex lock for queue here.
	<dispatcher.dispatchOccurredVar> = true;
	// TODO: add mutex unlock for queue here.
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>> 


// TODO: Dispatcher component for input events.
dispatcherComponentInputEventDecls(dispatcher) ::= <<

void <camkesRPCDispatchName(dispatcher)>(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.inputEventDispatcherPort.queueWriteName>(arg);
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>>

dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isInput)><else> ERROR: dispatcher is not IRQ, Event Data, or Periodic
<endif>
>>


dispatcherComponentMainFunction(threadImpl) ::= <<
int run() {
	// initialization routines ... skipped for now.
	
	// initial lock to await dispatch input.
	<threadImpl.dispatcherLockStmt>
	for(;;) {
		<threadImpl.dispatcherLockStmt>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatchers()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


dispatcherComponentCDecls(model, threadImpl) ::= <<

#include <\u003C><threadImpl.model.systemTypeHeaderName><\u003E>
#include <\u003C><threadImpl.dispatcherComponentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<if(threadImpl.inputEventPortList)><\\>
// Functions for managing input event port queues and dispatchers
<endif>
<threadImpl.inputEventDataPortList:dispatcherComponentInputEventDataPortDecls()>
<threadImpl.inputEventPortList:dispatcherComponentInputEventPortDecls()>

// Functions for managing other input dispatchers 
<threadImpl.dispatchers:dispatcherComponentEventDecls()>

<threadImpl.dispatchers:dispatcherComponentDataDispatchFunction()>

<dispatcherComponentMainFunction(threadImpl)>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component CAmkES file
// 
////////////////////////////////////////////////////////////////////////////

componentCamkesPurpose(componentName) ::= <<
This header file contains the CAmkES component definition for the 
AADL thread implementation <componentName>.
>>

componentCamkesPrefix(name, date, path, datatypesHeader) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, componentCamkesPurpose(name))>

>>

componentCamkesPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>


addPortIdl(port) ::= <<
import "../../interfaces/<port.type.readerWriterIdlFileName>";

>>

addSharedDataAccessorIdl(sharedDataAccesor) ::= <<
import "../../interfaces/<sharedDataAccessor.type.sharedDataIdlFileName>";

>>

inputDataPortDecl(port) ::= <<
provides <port.type.readerWriterInterfaceName> <port.name>; 
has mutex <port.mutex>; 

>>

outputDataPortDecl(port) ::= <<
uses <port.type.readerWriterInterfaceName> <port.name>;

>>

sharedDataAccessorDecl(sharedDataAcessor) ::= <<
uses <sharedDataAccessor.type.readerWriterInterfaceName> <sharedDataAccessor.name>;

>>

componentCamkesBody(threadImpl) ::= <<

import "../../interfaces/<threadImpl.idlFileName>";

<threadImpl.inputDataPortList:addPortIdl()>
<threadImpl.outputDataPortList:addPortIdl()>
<threadImpl.sharedDataAccessorList:addSharedDataAccessorIdl()>

component <threadImpl.componentName> {
	provides <threadImpl.idlName> <threadImpl.componentDispatcherInterfaceVarIdName>;
	<threadImpl.inputDataPortList:inputDataPortDecl()>
	<threadImpl.outputDataPortList:outputDataPortDecl()>
	<threadImpl.sharedDataAccessorList:sharedDataAccessorDecl()>
}


>> 


////////////////////////////////////////////////////////////////////////////
//
// Declarations for camkes dispatcher component
// 
////////////////////////////////////////////////////////////////////////////

dispatcherComponentCamkesPurpose(componentName) ::= <<
This header file contains the CAmkES dispatcher component definition for the 
AADL active thread implementation <componentName>.
>>

dispatcherComponentCamkesPrefix(name, date, path, datatypesHeader) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, dispatcherComponentCamkesPurpose(name))>

>>

importThreadIdl(threadImpl) ::= <<
import "../../interfaces/<threadImpl.idlFileName>";
>>

importReaderWriterIdl(type) ::= <<
import "../../interfaces/<type.readerWriterIdlFileName>";
>>

writeProvidedInterface(dispatcher) ::= <<
provides <dispatcher.type.readerWriterInterfaceName> <dispatcher.dispatcherComponentDispatchName>;
<if(dispatcher.isEvent)><\\>
has mutex <dispatcher.mutex>; 
<endif>
>>


writeToPassiveReceiver(threadImpl) ::= <<
<if(threadImpl.isPassive)>
uses <threadImpl.idlName> <threadImpl.interfaceInstanceName>;
<endif>
>>


constructSenderInterface(connection) ::= <<
<if(connection.destPort.threadImplementation.isActive)><\\>
uses <connection.destPort.type.readerWriterInterfaceName> <connection.sourcePort.name>;
<endif>
>>


writeSenders(threadImpl) ::= <<
<threadImpl.isSrcOfConnectionList:constructSenderInterface()>
>>

writeReceiveInterface(port) ::= <<
provides <port.type.readerWriterInterfaceName> <port.name>;
>>

dispatchComponentCDecls(threadImpl, model) ::= <<

// Passive component dispatch interfaces 
<model.threadImplementations:importThreadIdl()>

// Send/receive interfaces for active components
<model.activeThreadSendReceiveTypeList:importReaderWriterIdl()>

component <threadImpl.dispatcherComponentName> {
	control;
    
    has mutex <threadImpl.dispatcherComponentMutexName>;

	// dispatchable receive interfaces for thread <threadImpl.dispatcherComponentName> 
	<threadImpl.dispatchers:writeProvidedInterface()>

	<if(threadImpl.inputEventPortList || threadImpl.inputEventDataPortList)>
	// provided interfaces for receive interfaces.
	<endif>
	<threadImpl.inputEventPortList:writeReceiveInterface()>
	<threadImpl.inputEventDataPortList:writeReceiveInterface()>
	
	// references to other active thread send interfaces
	<writeSenders(threadImpl)>

	// references to passive receivers	
	<model.passiveThreadImplementations:writeToPassiveReceiver()>
	uses <threadImpl.idlName> <threadImpl.interfaceInstanceName>;
}
>>

dispatcherComponentCamkesPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations for periodic dispatcher gluecode c file
// 
////////////////////////////////////////////////////////////////////////////

periodicDispatcherCPurpose(componentName) ::= <<
This .c file contains the CAmkES periodic dispatcher component definition.
>>

periodicDispatcherCPrefix(name, date, path, datatypesHeader) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, dispatcherComponentCamkesPurpose(name))>

>>

writePeriodicDispatcher(dispatcher, threadCalendar) ::= <<
if ((smaccm_calendar_counter % (<dispatcher.periodicDispatcherPeriod> / smaccm_tick_interval)) == 0) {
	<dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>(smaccm_get_time_in_ms()); 
}
>>

periodicComponentCBody(threadCalendar) ::= <<

// Declarations for managing periodic thread dispatch
const uint32_t smaccm_tick_interval = <threadCalendar.greatestCommonDivisorInMilliseconds>;
const uint32_t smaccm_hyperperiod_subdivisions = <threadCalendar.hyperperiodSubdivisions>;
uint32_t smaccm_calendar_counter = 0;
uint32_t smaccm_calendar_ticks = 0;

// TODO: FIX This: we need to use some system function to return the current system time.
uint32_t smaccm_get_time_in_ms() {
  return (uint32_t)(smaccm_calendar_ticks * smaccm_tick_interval); 
}

void smaccm_thread_calendar() {
	<threadCalendar.periodicDispatchers:writePeriodicDispatcher(threadCalendar)>

	smaccm_calendar_counter = (smaccm_calendar_counter + 1) % smaccm_hyperperiod_subdivisions; 
	smaccm_calendar_ticks++; 
}

void smaccm_periodic_irq_callback() {
	epit_irq_callback();
	smaccm_thread_calendar(); 
	irq_reg_callback(smaccm_periodic_irq_callback, NULL);
}

int run(void)
{
	irq_reg_callback(smaccm_periodic_irq_callback, NULL);
	epit_init();
	epit_set_interval(<threadCalendar.greatestCommonDivisorInMilliseconds>);

	epit_start_timer();

	return 0;
}
 
>>

periodicDispatcherCPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations for periodic dispatcher camkes component
// 
////////////////////////////////////////////////////////////////////////////

writePeriodicSender(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
uses <dispatcher.type.readerWriterInterfaceName> <dispatcher.dispatcherComponentDispatchName>; 
<endif>
>>

writePeriodicSenders(threadImpl) ::= <<
<threadImpl.dispatchers:writePeriodicSender()>
>>
 
periodicDispatcherCamkesBody(model, type) ::= <<

import "../../interfaces/<type.readerWriterIdlFileName>";

component <model.threadCalendar.periodicDispatcherComponentName> {
	control;
	consumes DataAvailable irq;
	dataport Buf mem;
	<model.activeThreadImplementations:writePeriodicSenders()>
}

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations for camkes assembly
// 
////////////////////////////////////////////////////////////////////////////

camkesAssemblyPurpose(sysInstanceName) ::= <<
This header file contains the main CAmkES assembly for the  
AADL system instance rooted at <sysInstanceName>.
>>

camkesAssemblyPrefix(name, date, path) ::= "<stdFilePrefix(date, path, camkesAssemblyPurpose(name))>"

assemblyThreadImplementationImports(threadImpl) ::= <<
import "<threadImpl.rootToCamkesComponentFilePath>";
<if(threadImpl.isActive)><\\>
import "<threadImpl.rootToCamkesDispatcherComponentFilePath>";
<endif>
>>

assemblyThreadComponents(threadImpl) ::= <<
component <threadImpl.componentName> <threadImpl.componentInstanceName>;

>>

assemblyActiveThreadComponents(threadImpl) ::= <<
component <threadImpl.dispatcherComponentName> <threadImpl.dispatcherComponentInstanceName>;

>>

constructPeriodicComponent(calendar) ::= <<
<if(calendar.hasDispatchers)><\\>
component <calendar.periodicDispatcherComponentName> <calendar.periodicDispatcherInstanceName>;
<endif>
>>	

rpcConnection(cid, from1, from2, to1, to2) ::= 
   "connection seL4RPCCall <cid> (from <from1>.<from2>, to <to1>.<to2>);"

connectPassiveToActive(passiveThreadImpl, activeThreadImpl, model) ::= <<
<rpcConnection(model.generateConnectionName,
	activeThreadImpl.dispatcherComponentInstanceName,
	passiveThreadImpl.interfaceInstanceName,
	passiveThreadImpl.componentInstanceName,
	passiveThreadImpl.componentDispatcherInterfaceVarIdName)>

>>

assemblyConnectActiveToPassiveThreads(threadImpl, model) ::= <<
<model.passiveThreadImplementations:connectPassiveToActive(threadImpl, model)>
<rpcConnection(model.generateConnectionName, 
	threadImpl.dispatcherComponentInstanceName,
	threadImpl.interfaceInstanceName,
	threadImpl.componentInstanceName,
	threadImpl.componentDispatcherInterfaceVarIdName)>
	
>>


connectActiveSendToActiveSend(sourcePort, destPort, model) ::= <<
<if(destPort.threadImplementation.isActive)><\\>
<rpcConnection(model.generateConnectionName, 
	sourcePort.threadImplementation.dispatcherComponentInstanceName,
    sourcePort.name, 
	destPort.threadImplementation.dispatcherComponentInstanceName,
	destPort.name)> 
<endif>
>>

connectActiveToActive(connection, model) ::= <<
<connectActiveSendToActiveSend(connection.sourcePort, connection.destPort, model)>
>>

assemblyConnectActiveToActiveThreads(threadImpl, model) ::= <<
<threadImpl.isSrcOfConnectionList:connectActiveToActive(model)>
>>

connectActivePeriodic(dispatcher, threadImpl, model) ::= <<
<if(dispatcher.isPeriodic)><\\>
<rpcConnection(model.generateConnectionName, 
	model.threadCalendar.periodicDispatcherInstanceName,
	dispatcher.dispatcherComponentDispatchName, 
	threadImpl.dispatcherComponentInstanceName,
	dispatcher.dispatcherComponentDispatchName)>
<endif>
>>

assemblyConnectPeriodic(threadImpl, model) ::= <<
<threadImpl.dispatchers:connectActivePeriodic(threadImpl, model)>
>>

connectReaderWriter(connection, srcThreadImpl, model) ::= <<
<if(connection.sourcePort.isOutputDataPort)><\\>
<rpcConnection(model.generateConnectionName, 
	srcThreadImpl.componentInstanceName,
	connection.sourcePort.name,
	connection.destPortThreadImplementation.componentInstanceName,
	connection.destPort.name)>
<endif>
>>

assemblyConnectReadersWriters(threadImpl, model) ::= <<
<threadImpl.isSrcOfConnectionList:connectReaderWriter(threadImpl, model)>
>>

camkesAssemblyBody(model) ::= <<

import <\u003C>std_connector.camkes<\u003E>;
<if(model.threadCalendar.hasDispatchers)>import "<model.threadCalendar.periodicDispatcherPathName>";<endif>
<model.threadImplementations:assemblyThreadImplementationImports()>

component EPIT {
    hardware;
    dataport Buf mem;
    emits DataAvailable irq;
}

assembly {
	composition {
        component EPIT epit;
		<constructPeriodicComponent(model.threadCalendar)>
		
		// component instances for all AADL-defined threads
		<model.threadImplementations:assemblyThreadComponents()>
		
		// active thread components
		<model.activeThreadImplementations:assemblyActiveThreadComponents()>
	
		// connections from active dispatchers to passive threads
		<model.activeThreadImplementations:assemblyConnectActiveToPassiveThreads(model)>	
		
		// connections from active dispatcher send/receive to other active dispatcher send/receive
		<model.activeThreadImplementations:assemblyConnectActiveToActiveThreads(model)>
		
		// Periodic dispatcher connections
		<model.activeThreadImplementations:assemblyConnectPeriodic(model)>
        connection seL4HardwareMMIO epit_mem(from <model.threadCalendar.periodicDispatcherInstanceName>.mem, to epit.mem);
		connection seL4HardwareInterrupt irq(from epit.irq, to <model.threadCalendar.periodicDispatcherInstanceName>.irq);
		
		// Passive component read/write connections
		<model.threadImplementations:assemblyConnectReadersWriters(model)>
		
		// Shared data connections (currently unsupported: under development)
	}
    configuration {
		/* Freescale i.MX31 (KZM) */
        epit.mem_attributes = "0x53F98000:0x1000";
		epit.irq_attributes = 27;

		/* Freescale i.MX6 (Sabralite) */
        // epit.mem_attributes = "0x020D0000:0x1000";
		//epit.irq_attributes = 88;
    }
}

>>
