import "Common.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>


cPortTempVarDeclarations(port) ::= <<
<if(port.hasData)><port.globalDataParam>; <endif>
<port.globalIndexParam>;
<port.globalMaxDispatchSizeParam>; 	

>>

optDispatcherInputArg(dispatcher) ::= << <if(dispatcher.hasData)><dispatcher.nameAsInputParam> <endif> >>

cUserDispatcher(externalHandler, dispatcherNameStr) ::= <<
<externalHandler.handlerName>(<dispatcherNameStr>); 
>>


cPortOutputArg(dispatchContract) ::= 
"<if(dispatchContract.port.hasData)><dispatchContract.dispatchArrayTypeName> *<dispatchContract.port.data>, <endif>"

cDispatchContractOutputArg(dispatchContract) ::= <<  
		<cPortOutputArg(dispatchContract)>
		<dispatchContract.port.indexParam>
>>

optDispatcherComma(dispatcher) ::= "<if (dispatcher.hasData && dispatcher.contracts)>,<endif>"

componentDispatcherFn(dispatcher) ::= << 
void <dispatcher.threadImplementation.componentDispatcherInterfaceVarIdName>_<dispatcher.idlDispatcherName><\\>
(<dispatcher:optDispatcherInputArg()><optDispatcherComma(dispatcher)><dispatcher.contracts:cDispatchContractOutputArg();separator=",\n">) {
	<dispatcher.contracts:assignGlobals()>
	<dispatcher.externalHandlers:cUserDispatcher(dispatcher.name)>
}	


>>	 


assignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = *<dispatchContract.port.data>;<endif> 
*<dispatchContract.port.globalIndex> = 0;

>> 

copyToGlobalStmt(port) ::= <<
<if(port.type.isBaseType)><\\>
<port.globalDataSlot> = <port.name>;
<else><inputToValMemcpy(port.type, port.globalDataSlot, port.name)>
<endif>
>>

optConstInputArg(port) ::= "<if(port.hasData)>/* const */<port.nameAsInputParam><endif>"
optOutputArg(port) ::= "<if(port.hasData)><port.nameAsOutputParam><endif>"

componentSendFunction(port) ::= << 
bool <port.aadlWriterFnName>(<port:optConstInputArg()>) {
	if (*<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><copyToGlobalStmt(port)><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>
  
copyToImplVarStmt(port) ::= <<
<if(port.type.isBaseType)><port.readerWriterImplVar> = <port.name>;
<else><inputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
<endif>
>>

copyFromImplVarStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.outputToVal><port.name> = <port.readerWriterImplVar>;
<else><valToOutputMemcpy(port.type, port.name, port.readerWriterImplVar)>
<endif>
>>

componentLocalWriteFunction(port) ::= <<

// The writer function is called remotely through RPC, so follows the 
// RPC naming and return convention.  
void <port.name>_<port.type.writerFn>(<optConstInputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<copyToImplVarStmt(port)>
	<port.camkesMutexUnlockFnCall>;
}

>>

componentLocalReadFunction(port) ::= <<
bool <port.aadlReaderFnName>(<optOutputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<copyFromImplVarStmt(port)>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>


componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentLocalWriteFunction(port)>
>>

componentRemoteWriterDecl(port) ::= <<
bool <port.aadlWriterFnName>(<port.nameAsInputParam>) {
	<port.name>_<port.type.writerFn>(<port.name>);
	return true;
}

>>

componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>
#include <\u003C><threadImpl.componentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<threadImpl.allOutputEventPorts:cPortTempVarDeclarations()>

<threadImpl.dispatchers:componentDispatcherFn()>

<threadImpl.allOutputEventPorts:componentSendFunction()>

<threadImpl.inputDataPortList:componentLocalReaderDecl()>

<threadImpl.outputDataPortList:componentRemoteWriterDecl()>
>>

