import "Common.stg"

///////////////////////////////////////////////////////////////////////////
//
// Templates for managing data port interfaces between active threads.
//
// Shared memory / mutex implementation
// 
// 10/26/2016 MWW
// 
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
//
// Header templates
//
///////////////////////////////////////////////////////////////////////////


writePortWriterPrototype(port) ::= <<
bool <port.localWriterName>(const <port.type.aadlInputType.name> <port.name>);
>>

writePortReaderPrototype(port) ::= <<
bool <port.localReaderName>(<port.type.aadlOutputType.name> <port.name>);
>>



///////////////////////////////////////////////////////////////////////////
//
// C File templates
//
///////////////////////////////////////////////////////////////////////////


componentLocalWriteFunction(port) ::= <<

/************************************************************************
 *  <port.localWriterName>:
 * Invoked by local thread.
 *
 * This is the function that is invoked to write to a data port.
 *
 ************************************************************************/

bool <port.localWriterName>(<port.type.aadlOutputType.name> <port.name>) {
    <port.lockStmt>
    <if(port.type.isBaseType)><port.dataExpr> = *<port.name>;
    <else><camkesInputToValMemcpy(port.type, port.dataExpr, port.name)>
    <endif>
    <port.unlockStmt>
    return true;
}

>>

componentLocalReadFunction(port) ::= <<
/************************************************************************
 *  <port.localReaderName>:
 * Invoked from local active thread.
 *
 * This is the function invoked to read from a data port.
 *
 ************************************************************************/

bool <port.localReaderName>(<port.type.aadlOutputType.name> <port.name>) {
    <port.lockStmt>
    <if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.dataExpr>;
    <else><valToAadlOutputMemcpy(port.type, port.name, port.dataExpr)>
    <endif>
    <port.unlockStmt>
    return true;
}

>>


componentRemoteWriteFunction(port, name) ::= <<

/************************************************************************
 *  <name>:
 * Invoked by local thread to write to remote data port.
 *
 ************************************************************************/

bool <name>(<port.type.aadlOutputType.name> <port.name>) {
    <port.lockStmt>
    <if(port.type.isBaseType)><port.readerWriterImplVar> = *<port.name>;
    <else><camkesInputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
    <endif>
    <port.unlockStmt>
    return true;
}

>>

writeConnectionDecl(connection) ::= <<
<componentRemoteWriteFunction(connection.destPort, connection.fullyQualifiedName)>
>>

componentLocalReaderDecl(port) ::= <<
<if(port.isInProc)>
<port.backingStoreVarDecl>
<port.sharedMemoryDataType> <port.readerWriterImplVar> = &<port.backingStoreVarDecl>;
<else>
<port.sharedMemoryDataType> <port.readerWriterImplVar>;
<endif>
<componentLocalReadFunction(port)>

>>

writeToRemote(connection) ::= <<
<connection.destPort.qualifiedLocalWriterName>(<connection.srcPort.name>);

>>

localCallerFunction(srcPort) ::= <<
/************************************************************************
 *  <srcPort.localWriterName>:
 * Invoked from user code in the local thread.
 *
 * This is the function invoked by the local thread to make a
 * call to write to a remote data port.
 *
 ************************************************************************/

bool <srcPort.localWriterName>(const <srcPort.type.aadlInputType.name> <srcPort.name>) {
   <srcPort.connections:writeToRemote()>
    bool tb_result = true ; 
    return tb_result;
}
>>

componentLocalWriterDecl(srcPort) ::= <<

<srcPort.connections:writeConnectionDecl()>
<localCallerFunction(srcPort)>
>>



///////////////////////////////////////////////////////////////////////////
//
// linux OS configuration templates
//
// to do (for each port):
//    declare shared memory (if necessary)
//    initialize the mutex
//
///////////////////////////////////////////////////////////////////////////

portInitializer(port) ::= <<
{
    int tb_result;
    pthread_mutexattr_t tb_mutex_attributes;
    tb_mutex_attributes;
    <if(!port.isInProc)>
    <port.readerWriterImplVar> = (<port.sharedDataTypeName> *)mmap(
        NULL, sizeof(<port.sharedDataTypeName>), PROT_READ | PROT_WRITE,
        MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    assert(<port.readerWriterImplVar> != -1);
    <endif>
    pthread_mutexattr_setpshared(&tb_mutex_attributes, PTHREAD_PROCESS_SHARED);
    tb_result = pthread_mutex_init(<port.mutex>, &tb_mutex_attributes);
    assert(tb_result == 0);
}
>>

portDestructor(port) ::= <<
{
    int tb_result;
    tb_result = pthread_mutex_destroy(<port.mutex>);
    assert(tb_result == 0);
    <if(!port.isInProc)>
    munmap(<port.readerWriterImplVar>, sizeof(<port.sharedDataTypeName>));
    tb_result = assert(<port.readerWriterImplVar> != -1);
    assert(tb_result == 0);
    <endif>
}
>>
