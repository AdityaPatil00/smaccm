import "Common.stg"
import "CommonOSSpecificNames.stg"
import "CommonCPrototypes.stg"
import "VxWorksAssemblyHeader.stg"

/*********************************************************************
 *
 *********************************************************************/

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES/eChronos
//
//
////////////////////////////////////////////////////////////////////////////

mainGlueCodeCFilePurpose(name) ::= <<
This C file contains the main function for model <name>.

>>

filePrefix(name, date, path) ::=
    "<stdFilePrefix(date, path, mainGlueCodeCFilePurpose(name))>"

filePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>

constructThreadDispatcher(sem) ::= <<
tb_result = sem_init(&<sem>,
                     /* NOT-SHARED */ 0,
                     /* initial count */ 1);
assert(tb_result != -1);
>>

deleteSem(sem) ::= <<
tb_result = sem_destroy(&sem);
assert(tb_result != -1);
>>

constructMutex(mutex) ::= <<
tb_result = pthread_mutex_init(<mutex>, &tb_mutex_attributes);
assert(tb_result == 0);
>>

deleteMutex(mutex) ::= <<
tb_result = pthread_mutex_destroy(<mutex>);
assert(tb_result == 0);
>>

createActiveThreadMutexes(threadImpl) ::= <<
<constructThreadDispatcher(threadImpl.threadDispatcherMutex)>
<threadImpl.externalMutexes:{ m |<constructMutex(m)>}>
>>

createPassiveThreadMutexes(threadImpl) ::= <<
<constructThreadDispatcher(threadImpl.threadDispatcherMutex)>
<threadImpl.externalMutexes:{ m | <constructMutex(m)>}>
>>

createMutexes(model) ::= <<
/* create system-implementation level external mutexes */
<model.externalMutexList:{ m | <constructMutex(m)>}>

/* create active thread mutexes */
<model.activeThreadImplementations:createActiveThreadMutexes()>

/* create monitor mutexes */
<model.passiveThreadImplementations:createPassiveThreadMutexes()>
>>

deleteActiveThreadMutexes(threadImpl) ::= <<
semDelete(<threadImpl.threadDispatcherMutex>)
<threadImpl.externalMutexes:{ m | mutexDelete(<m>) }>
>>

deletePassiveThreadMutexes(threadImpl) ::= <<
semDelete(<threadImpl.threadDispatcherMutex>)
<threadImpl.externalMutexes:{ m | mutexDelete(<m>) }>
>>

deleteMutexes(model) ::= <<
/* delete system-implementation level external mutexes */
<model.externalMutexList:{ m | mutexDelete(<m>) }>

/* delete active thread mutexes */
<model.activeThreadImplementations:deleteActiveThreadMutexes()>

/* delete monitor mutexes */
<model.passiveThreadImplementations:deletePassiveThreadMutexes()>
>>

threadInitializePorts(threadImpl) ::= <<
    threadImpl.portList{ port | port.linuxAddMainCFileInitializers }
>>

initializePorts(model) ::= <<
<model.activeThreadImplementations:threadInitializePorts()>
>>

threadDeletePorts(threadImpl) ::= <<
    threadImpl.portList{ port | port.linuxAddMainCFileDestructors }
>>

deletePorts(model) ::= <<
<model.activeThreadImplementations:threadDeletePorts()>
>>

createTask(threadImpl) ::= <<
<threadImpl.normalizedName> = taskCreate("<threadImpl.normalizedName>",
    <threadImpl.priority>,
    VX_FP_TASK,
    <threadImpl.osSpecificStackSize>,
    (FUNCPTR)<threadImpl.threadImplMainFnName>,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
assert(<threadImpl.normalizedName> != NULL);

>>

activateTask(threadImpl) ::= <<
status = taskActivate(<threadImpl.normalizedName>);
assert(status == OK);

>>

createTasks(model) ::= <<
<model.ActiveThreadImplementations:createTask()>

<model.ActiveThreadImplementations:activateTask()>
>>

deleteTasks(model) ::= <<
<model.ActiveThreadImplementations:{threadImpl | taskDelete(<threadImpl.normalizedName>);
}>
>>

sharedDataDefinition(sharedData) ::= <<
<sharedData.type.name> <sharedData.varName>;

>>

/////////////////////////////////////////////////////////////////////
//
// Main function
//
/////////////////////////////////////////////////////////////////////
mainFunction(model) ::= <<
int trusted_build_main(uint32_t runDurationInSeconds) {

    // MWW TODO: accruing a little bit of technical debt here; only the
    // cross-process mutexes should really be shared.
    pthread_mutexattr_setpshared(&tb_mutex_attributes, PTHREAD_PROCESS_SHARED);

    STATUS status = sysClkRateSet(<model.threadCalendar.hzTickRate>);
    assert(status == OK);

    <createMutexes(model)>

    <initializePorts(model)>

    <createTasks(model)>

    if (runDurationInSeconds == 0) {
        taskSuspend(0);
    } else {
        sleep(runDurationInSeconds);
    }

    /* if bounded-time run, kill the tasks and delete the mutexes */

    <deleteTasks(model)>

    <deletePorts(model)>

    <deleteMutexes(model)>

    return 0;
}
>>

writeThreadPortIncludes(threadImpl) ::= <<
<threadImpl.portList:{port|port.vxWorksAddMainCFileIncludes}>
>>

writeThreadPortDeclarations(threadImpl) ::= <<
<threadImpl.portList:{port|port.vxWorksAddMainCFileDeclarations}>
>>


///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

body(model) ::= <<

#include <\u0022><model.prefix>_decls.h<\u0022>
#include <\u003C>unistd.h<\u003E>
#include <\u003C>sysLib.h<\u003E>
#include <\u003C>assert.h<\u003E>

<model.threadImplementations:writeThreadPortIncludes()>

static pthread_mutexattr_t tb_mutex_attributes;
int tb_result = 0;

<if(model.sharedData)>
// shared data definitions for tasks
<model.sharedData:sharedDataDefinition()>
<endif>

<writeModelMutexes(model, "")>

<model.threadImplementations:writeThreadPortDeclarations()>

<mainFunction(model)>

>>
