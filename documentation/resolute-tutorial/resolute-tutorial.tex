\documentclass[times, 10pt]{article}
%\usepackage{latex8}
\usepackage{times}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{url}

\usepackage{listings}

\usepackage{tabularx}

\lstdefinelanguage{aadl}
{morekeywords={aadlboolean,aadlinteger,aadlreal,aadlstring,access,all,and,
        annex,applies,binding,bus,calls,classifier,connections,constant,
        data,delta,device,end,enumeration,event,extends,false,features,flow,
        flows,group,implementation,in,inherit,initial,inverse,is,list,memory,
        mode,modes,none,not,of,or,out,package,parameter,path,port,private,
        process,processor,properties,property,provides,public,range,
        reference, check, component,forall,features,
        false,true,contained,has_property,refined,refines,requires,server,set,sink,source,
        subcomponents,subprogram,system,thread,to,true,type,units,value},
morecomment=[l]{--}}

\lstset{language=aadl,
        basicstyle=\scriptsize\sffamily,
        aboveskip=.1cm, % \smallskipamount, % \bigskipamount,
        belowskip=.1cm, % \smallskipamount, % \bigskipamount,
        abovecaptionskip=.1cm, % \smallskipamount, % \medskipamount,
        belowcaptionskip=.1cm, % \smallskipamount, % \bigskipamount,
        xleftmargin=.0cm,
        captionpos=b,
        tabsize=3}


\newcommand{\onemedfig}[3]{%
  \begin{figure}[htbp]
    \centerline{\epsfig{file=#1.pdf,width=.4\textwidth}}
    \caption{#2}
    \label{#3}
  \end{figure}
}



\newcommand{\onefullfig}[3]{%
  \begin{figure}[htbp]
    \centerline{\epsfig{file=#1.pdf,width=.7\textwidth}}
    \caption{#2}
    \label{#3}
  \end{figure}
}



\title{RESOLUTE tutorial}

\author{\textsc{Julien Delange}\\
  Software Engineering Institute\\
  \texttt{jdelange@sei.cmu.edu}
}

\begin{document}

\maketitle

\section{Introduction}
This tutorial gives a tour of the functionality of RESOLUTE.
It does not provide a complete description of the language, which
is rather provided by the user-manual of RESOLUTE\footnote{Documentation
avaialble on
\url{https://github.com/juli1/smaccm-improvements/tree/sei-improvements/documentation/resolute}}. This tutorial assumes that you have a working installation of RESOLUTE
and that you are able to use the validation tool.

This tutorial uses several examples hosted on OSATE github
repository. You can get the examples on the OSATE example
repository (see \url{https://github.com/osate/examples/}) under
the directory \texttt{core-examples/resolute}.

\section{Verifying property definition}
This first example checks the definition of a property
on a component. The related file is \texttt{property\_verification.aadl}.
The instance model is shown in figure \ref{fig:property-verification}.

\onemedfig{imgs/property_verification}{System instance in the \texttt{property\_verification.aadl}}{fig:property-verification}

In this model, each \texttt{thread} has the property
\texttt{resoluteps::foobar} defined:
\begin{itemize}
    \item
        \textbf{t1} has a value of 10
    \item
        \textbf{t1} has a value of 20
\end{itemize}

We define a theorem (\texttt{have\_good\_foobar}, see
file \texttt{theorems.aadl} in the textual model) to check
that all threads have a value for the \texttt{resoluteps::foobar}
greater than 15.

The theorem works as follow:
\begin{enumerate}
    \item
        It retrieves all the \texttt{thread} components
        associated to the process
    \item
        It calls the theorem \texttt{check\_thread} on each component.
    \item
        The \texttt{check\_thread} checks that the value
        of the \texttt{resoluteps::foobar} is greater than 15.
\end{enumerate}

\begin{lstlisting}
have_good_foobar(p : component) <=
	** " Check threads in component " p **
    forall(t : thread). contained(t, p) => check_thread (t)

check_thread(t : thread) <=
  	** "The thread " t " as a foobar bigger than 15"  **
  		(has_property (t, resoluteps::foobar)) and 
  		(property (t, resoluteps::foobar) > 15)
\end{lstlisting}

When running resolute on the initial model, the model
is not validated because \textbf{t1} has
a value of 10. To be able to validate the model,
change the definition of t1 and associate a value greater
than 15. For example, changing the definition
of the task as follow will be sufficient to validate the model.

\begin{lstlisting}
t1 : thread t.i {resoluteps::foobar => 20;};
\end{lstlisting}

After changing the model, run the analysis again, the
model would be validated.

In this part, we introduce the following RESOLUTE concepts:
\begin{enumerate}
    \item
        Call to another RESOLUTE theorem
    \item
        Use the \texttt{forall} keyword
    \item
        Use the \texttt{has\_property} built-in function to check
        that a property is defined on a component.
    \item
        Use the \texttt{property} built-in function to get the value
        of a property.
\end{enumerate}



\section{Analyzing Connections}
Now that we have discussed the verification of property values
in the components, we will present how you can analyze connections.
In this example, we will check that each incoming port
has only one incoming connection. This is a validation
oen might want to validate in the model in order to ensure
that there is only one sender for each communication port.
This type of modeling restriction is required by some tools such
as AGREE\footnote{AGREE actually does not support multiple fan-in, such
a validation tool can then help designers to check compliance of their model
against AGREE constraints}.

\onemedfig{imgs/double-fanin-instance}{System
Instance}{fig:double-fanin-instance}

The file related to this example is \texttt{check\_fanin.aadl}.
The related instance model is shown in figure \ref{fig:double-fanin-instance}.
The theorem \texttt{no\_double\_fanin} retrieves
all components within the model and validate them
using the \texttt{has\_single\_fanin} theorem. This theorem
gets all the incoming component features in a set and checks
that they only have one connection.

\begin{lstlisting}
no_double_fanin() <=
	** " All incoming feature have only one connection" **
    forall (c : component) . true => has_single_fanin (c)
 

has_single_fanin (comp : component) <=
	** " All incoming feature have only one connection on " comp **
	forall (f : features (comp)) . (direction(f) = "in") => (length (connections (f)) = 1) 
\end{lstlisting}

The model is not validated (result shown in figure
\ref{fig:double-fanin-result}) because components \texttt{snd1}
and \texttt{snd2} are connected to \texttt{recv} through
the same incoming feature. In order to be able to validate the model,
one solution is to add a new feature on \texttt{recv} and connect
\texttt{snd1} and \texttt{snd2} to a single and distinct port.

\onemedfig{imgs/double-fanin-result}{Analysis result for the double fanin system}{fig:double-fanin-result}

In this part, we introduce the following RESOLUTE concepts:
\begin{enumerate}
    \item
        Call to another RESOLUTE theorem
    \item
        Use the \texttt{forall} keyword
    \item
        Use the \texttt{direction} built-in function (returns
        either \texttt{"in"}, \texttt{"out"} or \texttt{"inout"}).
    \item
        Use the \texttt{length} built-in function that returns
        the size of a set
\end{enumerate}

\section{Analyzing Connections Consistency}

\section{Checking Compliance of an Architecture}


\end{document}
