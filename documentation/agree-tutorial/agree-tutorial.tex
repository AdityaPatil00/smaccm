\documentclass[times, 10pt]{article}
%\usepackage{latex8}
\usepackage{times}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{url}

\usepackage{listings}

\usepackage{tabularx}

\lstdefinelanguage{aadl}
{morekeywords={aadlboolean,aadlinteger,aadlreal,aadlstring,access,all,and,
        annex,applies,binding,bus,calls,classifier,connections,constant,
        data,delta,device,end,enumeration,event,extends,false,features,flow,
        flows,group,implementation,in,inherit,initial,inverse,is,list,memory,
        mode,modes,none,not,of,or,out,package,parameter,path,port,private,
        process,processor,properties,property,provides,public,range,
        reference, check,
        component,forall,features,eq,assert,assume,guarantee,int,pre,
        false,true,contained,has_property,refined,refines,requires,server,set,sink,source,
        subcomponents,subprogram,system,thread,to,true,type,units,value},
morecomment=[l]{--}}

\lstset{language=aadl,
        basicstyle=\scriptsize\sffamily,
        aboveskip=.1cm, % \smallskipamount, % \bigskipamount,
        belowskip=.1cm, % \smallskipamount, % \bigskipamount,
        abovecaptionskip=.1cm, % \smallskipamount, % \medskipamount,
        belowcaptionskip=.1cm, % \smallskipamount, % \bigskipamount,
        xleftmargin=.0cm,
        captionpos=b,
        tabsize=3}


\newcommand{\onemedfig}[3]{%
  \begin{figure}[htbp]
    \centerline{\epsfig{file=#1.pdf,width=.4\textwidth}}
    \caption{#2}
    \label{#3}
  \end{figure}
}



\newcommand{\onefullfig}[3]{%
  \begin{figure}[htbp]
    \centerline{\epsfig{file=#1.pdf,width=.7\textwidth}}
    \caption{#2}
    \label{#3}
  \end{figure}
}



\title{AGREE tutorial}

\author{\textsc{Julien Delange}\\
  Software Engineering Institute\\
  \texttt{jdelange@sei.cmu.edu}
}

\begin{document}

\maketitle

\section{Introduction}
This document is a tutorial to learn to use the AGREE language and its
associated toolset. This is not a user-manual that covers all aspect of the
language features, all these aspects are described in the AGREE 
user-manual\footnote{\url{https://github.com/smaccm/smaccm/tree/master/documentation/agree}}.
This document is a way to learn how to use the language and its associated tools
through several case studies.

    \subsection{Examples location}
    All the examples used in this tutorial are available online on the public
    OSATE github repository\footnote{\url{https://github.com/osate/examples/}}.
    You can import the model into your workspace directly to reproduce the
    examples presented through this tutorial.


\onemedfig{imgs/agree-usage}{AGREE menu in OSATE outline}{fig:agree-usage}

    \subsection{Use Analysis Tools}
    To use AGREE, model components must be annotated with AGREE annex
    subclauses. Then, invoking AGREE can be done by selecting the top-level
    system instance and make a right-click and select two options:
    \begin{enumerate}
        \item
            \textbf{Verify Single Layer}: analyze and verify only one depth
            of the component hierarchy.
        \item
            \textbf{Verify All Layers}: analyze the complete components
            hierarchy.
    \end{enumerate}

    \subsection{Limitations}
    When using AGREE, your models must enforce some constraints. There is the
    list of the constraints your model has to enforce:
    \begin{itemize}
        \item
            \textbf{Execution Order}: the execution order of the model is
            done in the order of the declaration of the subcomponents.
        \item
            \textbf{Multiple fanin} are \textbf{not} supported. In other words,
            an incoming feature can have only one incoming connection.
        \item
            \textbf{Top-level component} must have an AGREE subclause, even
            if you do not want to verify anything and want to validate the
            subcomponent. Hopefully, you can insert a dummy subclause like the
            one shown below.
    \end{itemize}

\begin{lstlisting}
system mysystem
annex agree {**
	guarantee "dummy" : true;
**};
end mysystem;
\end{lstlisting}


    \subsection{Understanding Analysis Results}
    For each component, AGREE provides the following analysis:
    \begin{enumerate}
        \item
            \textbf{Contract Guarantees}
        \item
            \textbf{Contract Assumptions}
        \item
            \textbf{Contract Consistency}
    \end{enumerate}


\onefullfig{imgs/agree-results}{AGREE Results View in OSATE}{fig:agree-results}


\section{First AGREE model}
To understand AGREE basics, we will design a first model with some basics
validation contracts. In this example, we will design a system with a sender
and a receiver. The sender sends an integer through its outgoing interface.
The related example is located in the \texttt{core-examples/agree/basic.aadl} model on the OSATE
examples repository\footnote{\url{https://github.com/osate/examples/}}.

The integration contract will then guarantee that the value sent through
the interfaces is bound (with a range between 0 and 100) and the one received
by the receiver has the same bound as well.

    \subsection{Defining guarantees}
    In the following listing, we show the guarantee contract in the component type
    (the section defined with the \texttt{guarantee} keyword). The component
    implementation defines the behavior: the integer starts at 1, is incremented at
    each \textit{tick} and eventually set to 10 when the value reached 90.

    \begin{lstlisting}
system sender
features
    dataout : out data port base_types::integer;
annex agree {**
    guarantee "data sent is between 0 and 100": dataout < 100 and dataout > 0;
**};
end sender;

system implementation sender.i
annex agree {**
    eq k : int = 1 -> if (pre(k) > 90) then 10 else pre(k) + 1;
    assert (dataout = k);
**};
end sender.i;
\end{lstlisting}



    \subsection{Defining assumptions}
    We also need to define components assumptions so that the analysis tool
    can check that they are consistent with the guarantees. In the following
    listing, we define the assumption for the receiver, specifying that the
    data received is bound within a range of 0 and 100.
\begin{lstlisting}
system receiver
features
	datain : in data port base_types::integer;
annex agree {**
	assume "data produced between 0 and 100": (datain < 100) and (datain > 0);
**};
end receiver;
\end{lstlisting}

    \subsection{Running the tool}
    Once both \texttt{assume} and \texttt{guarantee} are defined, we integrate
    the components and can start the analysis tool. The results are shown in
    figure \ref{fig:agree-results}.

    To show how AGREE can help you to investigate errors within your system, we
    will introduce an error in the contract. Let's change the \texttt{guarantee}
    of the sender component and specify that the data sent be within a range of
    0 to 150. The component type specification should then looks like the
    following.

    \begin{lstlisting}
system sender
features
    dataout : out data port base_types::integer;
annex agree {**
    guarantee "data sent is between 0 and 150": dataout < 150 and dataout > 0;
**};
end sender;
\end{lstlisting}

When invoking the analysis tool again, it reports that the assumptions of the 
\texttt{rcv} component are not met, as shown in figure \ref{fig:agree-results-ko}.
When a contract is not validated, AGREE can then provide a counter example that
details the different execution paths that lead to the validation error. To get
the trace, right click on the assumption/guarantee/consistency contract not met
and select the option to show a counter example. Counter examples can be shown
in different format: text-based, spreadsheet (with Excel or OpenOffice) or in
Eclipse, as shown in figure \ref{fig:counter-examples}.

\onefullfig{imgs/system1-result-ko}{AGREE Results View in OSATE - Contracts not
validated}{fig:agree-results-ko}

\onefullfig{imgs/system1-counter-example}{Counter Example in
Eclipse}{fig:counter-examples}



\section{The temperature example}
The temperature example with explain how to capture the component 
behavior with SAVI by capturing a redundant example. The example
is available under the file \texttt{agree-temp-control.aadl} on OSATE
github examples repository\footnote{See
\url{https://github.com/osate/examples/tree/master/core-examples/agree}}.

The system instance is shown in figure \ref{fig:temperature-instance}. It
consists of
\begin{itemize}
    \item
        two temperature sensors
    \item
        one control panel (operated by the user) to activate heat or cooling
    \item
        one temperature regulation system that activate cooler or heater.
        It is composed of the following sub-components:
        \begin{itemize}
            \item
                One voter that checks temperature consistency and ensure
                that values from both sensors is similar. Otherwise, it used
                the previous value
             \item
                One controller that activates the heater or cooler according
                to the following rules
                \begin{itemize}
                    \item
                        If the user requests more heat and the temperature is
                        below 20, the heater is activated
                    \item
                        If the user requests to cool down the tempeartur
                        and the temperature is
                        above 0, the cooler is activated
                \end{itemize}
        \end{itemize}
\end{itemize}

The system has the following constraints
\begin{enumerate}
    \item
        Temperature is always between 0 and 20
    \item
        We cannot activate the heater and the cooler at the same time
\end{enumerate}

\onefullfig{imgs/temperature-instance}{Instance Model of the Temperature System}{fig:temperature-instance}

We add \texttt{assume} and \texttt{guarantee} statements in the model
in order to reflect the system constraints. For example, for the temperature,
assume and guarantees are associated in the features that receives or
sends the values. The following code illustrates such statements for the 
\texttt{voter} component.

\begin{lstlisting}
annex agree {**
    assume "incoming temperature on sensor1 between 0 and 20 (both included)": 
        tempin1 <= 20 and tempin1 >= 0;

    assume "incoming temperature on sensor2 between 0 and 20 (both included)": 
        tempin2 <= 20 and tempin2 >= 0;

    guarantee "outgoing temperature is between 0 and 20 (both included)": 
        tempout <= 20 and tempout >= 0;
**}; 
\end{lstlisting}

On the other hand, this guarantee must be validated in the component behavior.
So, engineers has to add the behavior of the component and make sure
that assumptions and guarantees are enforced. In fact, the initial model does
not enforce them, as shown in figure \ref{fig:temperature-initial-report}.

\onefullfig{imgs/temperature-initial-report}{Initial AGREE analysis of the
temprature system}{fig:temperature-initial-report}

When looking at the results, two guarantees are not enforced:
\begin{enumerate}
    \item
        On the controller component: Cannot heat and cool at the same time
    \item
        On the voter component: Outgoing temperature between 0 and 20
\end{enumerate}

These guarantees cannot be verified because the component does not enforce
them in their behavior. Next sections will discuss how to specify
the behavior in order to have them validated.

    \subsection{Fixing the controller guarantee}
    In the controller model, one must ensure that the heater and cooler
    are not activated at the same time. So, the behavior must specify
    how the component activates these functions.

    The component \textit{guarantees} that it cannot activates the
    heater and cooler at the same time using the statement below.

\begin{lstlisting}
system controller
features
	tempin 			: in data port temperature_type;
	user_request 	: in data port command.impl;
	heater_on		: out data port base_types::boolean;
	cooler_on		: out data port base_types::boolean;
annex agree {**
    assume "incoming temperature is between 0 and 20 (both included)": tempin <= 20 and tempin >= 0;

	guarantee "Cannot heat and cool at the same time" : not (heater_on and cooler_on);
**};
end controller;
\end{lstlisting}
    
    In order to validate that, one need also to define the behavior,
    \textit{when} the \texttt{heater\_on} and \texttt{cooler\_on}
    features are activated.

    When looking at the component implementation, the functions
    are always activated.

\begin{lstlisting}
system implementation controller.impl
annex agree {**
	eq heating_request : bool = true;
	eq cooling_request : bool = true;
	assert (heater_on = (heating_request and (tempin <= 20)));
	assert (cooler_on = (cooling_request and (tempin > 0)));
**};
end controller.impl;
\end{lstlisting}

    So, one needs to complete the component behavior. We define
    the activation rules for each features so that:
    \begin{itemize}
        \item
            The \texttt{heater\_on} is true if the user issue a request to activate the heat \textbf{and} does not activate the cooling \textbf{and} the temperature is lower than 20
        \item
            The \texttt{cooler\_on} is true if the user issue a request to activate the cool \textbf{and} does not activate the heating \textbf{and} the temperature is higher than 0
    \end{itemize}

    Using these rules, the controller cannot issue a heating and cooling request
    at the same time. The following code shows how we adress the issue.

\begin{lstlisting}
system implementation controller.impl
annex agree {**
	eq heating_request : bool = false -> if ((user_request.heater_on = true) and 
                                            (user_request.cooler_on = false)) then 
                                            true 
                                                else 
                                            false;
	eq cooling_request  : bool = false -> 
      if ((user_request.cooler_on = true) and (user_request.heater_on = false)) then 
         true 
      else 
         false;
	
	assert (heater_on = (heating_request and (tempin <= 20)));
	assert (cooler_on = (cooling_request and (tempin > 0)));
**};
end controller.impl;
\end{lstlisting}



    \subsection{Fixing the voter guarantee}
    The voter component takes the values from both sensor, check that both
    values are the same and output either the value (if both sensors report the
    same value) or use the previous correct value.

    In the system, the temperature must always be between 0 and 20. So, the
    voter defines the assumptions that the incoming temperature values are
    within 0 and 20 but also that the produced temperature is within this range.
    The following component declaration specifies these contracts.

\begin{lstlisting}
system voter
features
	tempin1 		: in data port temperature_type;
	tempin2 		: in data port temperature_type;
	tempout 		: out data port temperature_type;
annex agree {**
    assume "incoming temperature on sensor1 between 0 and 20 (both included)": 
            tempin1 <= 20 and tempin1 >= 0;
    assume "incoming temperature on sensor2 between 0 and 20 (both included)": 
            tempin2 <= 20 and tempin2 >= 0;
    guarantee "outgoing temperature is between 0 and 20 (both included)": 
            tempout <= 20 and tempout >= 0;
**}; 
end voter;
\end{lstlisting}

    As for the controller, these contracts must be implemented
    by the component behavior. The initial component implementation defines the
    behavior shown below, producing a temperature value outside the expected
    range.

\begin{lstlisting}
system implementation voter.impl
annex agree {**
	eq selected_temp : int = -1;
    assert (tempout = selected_temp);
**}; 
end voter.impl;

\end{lstlisting}

    In order to validate the component, one needs to specifies its behavior. To
    do so, we specify how the incoming values are processed using the following
    behavior (see below):
    \begin{itemize}
        \item
            The initial value (left part of the \texttt{->} symbol) is 0
         \item
            If values from both sensor are similar, it is then sent by the voter
         \item
            If values from both sensor are different, the voter sends the
            previous valid value
    \end{itemize}

\begin{lstlisting}
system implementation voter.impl
annex agree {**
	eq selected_temp : int = 0 -> if (tempin1 = tempin2) then tempin1 else pre(selected_temp);
	
    assert (tempout = selected_temp);
**}; 
end voter.impl;
\end{lstlisting}

    One the behavior is implemented, the system is correctly validated by the
    AGREE analysis tool.

    \section{Conclusion}
    This tutorial outlines the basics of AGREE to check components integration
    within an architecture model. We show how to specify components
    assumptions, guarantees and also define their behavior. Users might want to
    learn the internals of the language and get more details about advanced
    features. This information can be found in the AGREE user manual available
    online.

\end{document}
\end{enumerate}

\end{document}
